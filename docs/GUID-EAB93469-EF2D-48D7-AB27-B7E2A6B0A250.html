<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="DC.type" content="topic" />
<meta name="DC.title" content="How the Library Works" />
<meta name="DC.relation" scheme="URI" content="GUID-0FFCD458-7F10-49C8-B068-E4E4B5439C47.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="how-the-library-works" />
<link rel="stylesheet" type="text/css" href="stylesheets/commonltr.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<link rel="stylesheet" type="text/css" href="./stylesheets/common-extended.css" /><title>How the Library Works</title>
<meta name="Microsoft.Help.Id" content="GUID-EDFB1AB8-CD6B-446F-8E25-F2167287A1AF-how-the-library-works" />
<meta name="Microsoft.Help.TocParent" content="GUID-EDFB1AB8-CD6B-446F-8E25-F2167287A1AF" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLABÂ® Harmony Core Library Reference A 11/2021" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
        function cpy(id, button) {
        
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                    button.textContent = "Copy";
                    button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
              console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
        }
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?GUID-EAB93469-EF2D-48D7-AB27-B7E2A6B0A250"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style></head>
<body id="how-the-library-works">
<h1 class="title topictitle1" id="ariaid-title1">How the Library Works</h1><div class="body"><p class="p">The memory driver library is a multi-client, multi-instance buffer queue model based block driver interface.</p>
<p class="p"><strong class="ph b">Abstraction Model</strong></p>
<p class="p">The Memory driver provides abstraction to communicate with different media devices via a common Media Interface <strong class="ph b">(DRV_MEMORY_DEVICE_INTERFACE)</strong>.</p>
<ul class="ul"><li class="li"><p class="p"><strong class="ph b">Note:</strong> Queue is not present in Synchronous mode of the driver.</p>
</li>
</ul>
<br /><img class="image" src="GUID-82B46292-53B5-4796-8AFB-9DD141FA8CEE-low.png" alt="drv_memory_abstraction_model" /><br /><p class="p"><strong class="ph b">Memory Driver Common Features:</strong></p>
<ul class="ul"><li class="li"><p class="p">Each instance of the driver has its own buffer queue which allows the capability to not block other media operations</p>
</li>
<li class="li"><p class="p">Each instance of the driver can either have File-system as client or an application as client</p>
</li>
<li class="li"><p class="p">Every transfer request expects data in blocks. Block details (Size and number of blocks) can be retrieved by <strong class="ph b">DRV_MEMORY_GeometryGet()</strong></p>
</li>
<li class="li"><p class="p">Driver provides feature to register call back for transfer complete event, which can used by clients to get notified</p>
</li>
<li class="li"><p class="p">When the Memory driver is connected to the File System, the buffer queue is disabled as it is a blocking interface</p>
</li>
</ul>
<p class="p"><strong class="ph b">Overview on behavior of memory driver in below two modes:</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d165721e59"><span>Asynchronous Mode</span></th>
<th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d165721e61"><span>Synchronous Mode</span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d165721e59 "><span>Works in both Bare-Metal and RTOS environment</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d165721e61 "><span>Works only in RTOS Environment</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d165721e59 "><span>Provides Non-Blocking behavior</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d165721e61 "><span>Provides Blocking behavior. Application thread gets blocked on a semaphore until transfer request is completed.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d165721e59 "><span>API's to be used <strong class="ph b">DRV_MEMORY_AsyncXxx()</strong></span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d165721e61 "><span>API's to be used <strong class="ph b">DRV_MEMORY_SyncXxx()</strong></span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d165721e59 "><span>API's return with a valid handle which can be used to check whether transfer request is accepted</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d165721e61 "><span>API's return true or false to indicate whether the whole transfer is completed.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d165721e59 "><span><strong class="ph b">For Bare-Metal</strong> a dedicated task routine DRV_MEMORY_Tasks() is called from SYS_Tasks() to process the data from the instance queue. <strong class="ph b">For RTOS</strong> a blocking dedicated thread is created for task routine DRV_MEMORY_Tasks() to process the data from the instance queue.</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d165721e61 "><span>As the Driver works in complete blocking behavior there is no task routine generated.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d165721e59 "><span>A Client specific handler will be called to indicate the status of transfer.</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d165721e61 "><span>A Client specific handler will be called to indicate the status of transfer before returning from API. Although the return type of API also can be used to identify the status of transfer.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">How to plugin Media's to Memory Driver</strong></p>
<p class="p">The <strong class="ph b">DRV_MEMORY_INIT</strong> data structure allows a Media driver Or Media peripheral library to be plugged into the Memory block driver.</p>
<p class="p">Any media that needs to be plugged into the Memory block driver needs to implement the interface (function pointer signatures) specified by the <strong class="ph b">DRV_MEMORY_DEVICE_INTERFACE</strong> type.</p>
<pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d165721e117', this);">Copy</button><code id="d165721e117" content="// This code snippet shows an example of initializing the Memory Driver&#xA;// with SST26 serial flash device attached and File system Enabled.&#xA;&#xA;SYS_MODULE_OBJ objectHandle;&#xA;&#xA;static uint8_t gDrvMemory0EraseBuffer[DRV_SST26_ERASE_BUFFER_SIZE] CACHE_ALIGN;&#xA;&#xA;static DRV_MEMORY_CLIENT_OBJECT gDrvMemory0ClientObject[DRV_MEMORY_CLIENTS_NUMBER_IDX0] = { 0 };&#xA;&#xA;static DRV_MEMORY_BUFFER_OBJECT gDrvMemory0BufferObject[DRV_MEMORY_BUFFER_QUEUE_SIZE_IDX0] = { 0 };&#xA;&#xA;const DRV_MEMORY_DEVICE_INTERFACE drvMemory0DeviceAPI = {&#xA;    .Open = DRV_SST26_Open,&#xA;    .Close = DRV_SST26_Close,&#xA;    .Status = DRV_SST26_Status,&#xA;    .SectorErase = DRV_SST26_SectorErase,&#xA;    .Read = DRV_SST26_Read,&#xA;    .PageWrite = DRV_SST26_PageWrite,&#xA;    .EventHandlerSet = NULL,&#xA;    .GeometryGet = (DRV_MEMORY_DEVICE_GEOMETRY_GET)DRV_SST26_GeometryGet,&#xA;    .TransferStatusGet = (DRV_MEMORY_DEVICE_TRANSFER_STATUS_GET)DRV_SST26_TransferStatusGet&#xA;};&#xA;&#xA;const DRV_MEMORY_INIT drvMemory0InitData =&#xA;{&#xA;    .memDevIndex = DRV_SST26_INDEX,&#xA;    .memoryDevice = &amp;drvMemory0DeviceAPI,&#xA;    .isFsEnabled = true,&#xA;    .deviceMediaType = (uint8_t)SYS_FS_MEDIA_TYPE_SPIFLASH,&#xA;    .ewBuffer = &amp;gDrvMemory0EraseBuffer[0],&#xA;    .clientObjPool = (uintptr_t)&amp;gDrvMemory0ClientObject[0],&#xA;    .bufferObj = (uintptr_t)&amp;gDrvMemory0BufferObject[0],&#xA;    .queueSize = DRV_MEMORY_BUFFER_QUEUE_SIZE_IDX0,&#xA;    .nClientsMax = DRV_MEMORY_CLIENTS_NUMBER_IDX0&#xA;};&#xA;&#xA;//usage of DRV_MEMORY_INDEX_0 indicates usage of Flash-related APIs&#xA;objectHandle = DRV_MEMORY_Initialize((SYS_MODULE_INDEX)DRV_MEMORY_INDEX_0, (SYS_MODULE_INIT *)&amp;drvMemory0InitData);&#xA;&#xA;if (SYS_MODULE_OBJ_INVALID == objectHandle)&#xA;{&#xA;    // Handle error&#xA;}"><span class="ph token comment">// This code snippet shows an example of initializing the Memory Driver</span>
<span class="ph token comment">// with SST26 serial flash device attached and File system Enabled.</span>

SYS_MODULE_OBJ objectHandle<span class="ph token punctuation">;</span>

<span class="ph token keyword">static</span> uint8_t gDrvMemory0EraseBuffer<span class="ph token punctuation">[</span>DRV_SST26_ERASE_BUFFER_SIZE<span class="ph token punctuation">]</span> CACHE_ALIGN<span class="ph token punctuation">;</span>

<span class="ph token keyword">static</span> DRV_MEMORY_CLIENT_OBJECT gDrvMemory0ClientObject<span class="ph token punctuation">[</span>DRV_MEMORY_CLIENTS_NUMBER_IDX0<span class="ph token punctuation">]</span> <span class="ph token operator">=</span> <span class="ph token punctuation">{</span> <span class="ph token number">0</span> <span class="ph token punctuation">}</span><span class="ph token punctuation">;</span>

<span class="ph token keyword">static</span> DRV_MEMORY_BUFFER_OBJECT gDrvMemory0BufferObject<span class="ph token punctuation">[</span>DRV_MEMORY_BUFFER_QUEUE_SIZE_IDX0<span class="ph token punctuation">]</span> <span class="ph token operator">=</span> <span class="ph token punctuation">{</span> <span class="ph token number">0</span> <span class="ph token punctuation">}</span><span class="ph token punctuation">;</span>

<span class="ph token keyword">const</span> DRV_MEMORY_DEVICE_INTERFACE drvMemory0DeviceAPI <span class="ph token operator">=</span> <span class="ph token punctuation">{</span>
    <span class="ph token punctuation">.</span>Open <span class="ph token operator">=</span> DRV_SST26_Open<span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>Close <span class="ph token operator">=</span> DRV_SST26_Close<span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>Status <span class="ph token operator">=</span> DRV_SST26_Status<span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>SectorErase <span class="ph token operator">=</span> DRV_SST26_SectorErase<span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>Read <span class="ph token operator">=</span> DRV_SST26_Read<span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>PageWrite <span class="ph token operator">=</span> DRV_SST26_PageWrite<span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>EventHandlerSet <span class="ph token operator">=</span> <span class="ph token constant">NULL</span><span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>GeometryGet <span class="ph token operator">=</span> <span class="ph token punctuation">(</span>DRV_MEMORY_DEVICE_GEOMETRY_GET<span class="ph token punctuation">)</span>DRV_SST26_GeometryGet<span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>TransferStatusGet <span class="ph token operator">=</span> <span class="ph token punctuation">(</span>DRV_MEMORY_DEVICE_TRANSFER_STATUS_GET<span class="ph token punctuation">)</span>DRV_SST26_TransferStatusGet
<span class="ph token punctuation">}</span><span class="ph token punctuation">;</span>

<span class="ph token keyword">const</span> DRV_MEMORY_INIT drvMemory0InitData <span class="ph token operator">=</span>
<span class="ph token punctuation">{</span>
    <span class="ph token punctuation">.</span>memDevIndex <span class="ph token operator">=</span> DRV_SST26_INDEX<span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>memoryDevice <span class="ph token operator">=</span> <span class="ph token operator">&amp;</span>drvMemory0DeviceAPI<span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>isFsEnabled <span class="ph token operator">=</span> true<span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>deviceMediaType <span class="ph token operator">=</span> <span class="ph token punctuation">(</span>uint8_t<span class="ph token punctuation">)</span>SYS_FS_MEDIA_TYPE_SPIFLASH<span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>ewBuffer <span class="ph token operator">=</span> <span class="ph token operator">&amp;</span>gDrvMemory0EraseBuffer<span class="ph token punctuation">[</span><span class="ph token number">0</span><span class="ph token punctuation">]</span><span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>clientObjPool <span class="ph token operator">=</span> <span class="ph token punctuation">(</span>uintptr_t<span class="ph token punctuation">)</span><span class="ph token operator">&amp;</span>gDrvMemory0ClientObject<span class="ph token punctuation">[</span><span class="ph token number">0</span><span class="ph token punctuation">]</span><span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>bufferObj <span class="ph token operator">=</span> <span class="ph token punctuation">(</span>uintptr_t<span class="ph token punctuation">)</span><span class="ph token operator">&amp;</span>gDrvMemory0BufferObject<span class="ph token punctuation">[</span><span class="ph token number">0</span><span class="ph token punctuation">]</span><span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>queueSize <span class="ph token operator">=</span> DRV_MEMORY_BUFFER_QUEUE_SIZE_IDX0<span class="ph token punctuation">,</span>
    <span class="ph token punctuation">.</span>nClientsMax <span class="ph token operator">=</span> DRV_MEMORY_CLIENTS_NUMBER_IDX0
<span class="ph token punctuation">}</span><span class="ph token punctuation">;</span>

<span class="ph token comment">//usage of DRV_MEMORY_INDEX_0 indicates usage of Flash-related APIs</span>
objectHandle <span class="ph token operator">=</span> <span class="ph token function">DRV_MEMORY_Initialize</span><span class="ph token punctuation">(</span><span class="ph token punctuation">(</span>SYS_MODULE_INDEX<span class="ph token punctuation">)</span>DRV_MEMORY_INDEX_0<span class="ph token punctuation">,</span> <span class="ph token punctuation">(</span>SYS_MODULE_INIT <span class="ph token operator">*</span><span class="ph token punctuation">)</span><span class="ph token operator">&amp;</span>drvMemory0InitData<span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>

<span class="ph token keyword">if</span> <span class="ph token punctuation">(</span>SYS_MODULE_OBJ_INVALID <span class="ph token operator">==</span> objectHandle<span class="ph token punctuation">)</span>
<span class="ph token punctuation">{</span>
    <span class="ph token comment">// Handle error</span>
<span class="ph token punctuation">}</span></code></pre></div>
<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="GUID-0FFCD458-7F10-49C8-B068-E4E4B5439C47.html">Memory Driver</a></div>
</div>
</div></body>
</html>