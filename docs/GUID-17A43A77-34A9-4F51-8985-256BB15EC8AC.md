# Using The Library

The AT25DF driver provides non-blocking API's to read, write and erase AT25DF Flash memory.

**The AT25DF driver can be used in following ways:**

-   To perform reads, writes and erase from/to any Flash memory address, with number of bytes spanning multiple pages

-   To perform page write to AT25DF Flash. Here, the memory start address must be aligned to the page boundary

-   To perform Sector/Bulk/Chip Erase operations

-   To interface with the Memory driver to perform block operations on the AT25DF Flash

-   Application can either register a callback to get notified once the data transfer is complete or can poll the status of the data transfer


**Example application to Erase, Write and Read AT25DF Flash Memory**

```c
/* Erase-Write-Read 2 Sector of Data (4096 *2)*/
#define BUFFER_SIZE     8192
#define MEM_ADDRESS     0x0

APP_DATA CACHE_ALIGN appData;

static uint32_t erase_index = 0;
static uint32_t write_index = 0;

void APP_FLASH_EventHandler(DRV_AT25DF_TRANSFER_STATUS event, uintptr_t context)
{
    switch(event)
    {
        case DRV_AT25DF_TRANSFER_STATUS_COMPLETED:
        {
            appData.isTransferDone = true;
            break;
        }

        case DRV_AT25DF_TRANSFER_STATUS_ERROR:
        default:
        {
            appData.isTransferDone = false;
            break;
        }
    }
}

void APP_Initialize ( void )
{
    uint32_t i = 0;

    /* Place the App state machine in its initial state. */
    appData.state = APP_STATE_INIT;

    for (i = 0; i < BUFFER_SIZE; i++)
    {
        appData.writeBuffer[i] = i;
    }
}

void APP_Tasks ( void )
{
    /* Check the application's current state. */
    switch ( appData.state )
    {
        /* Application's initial state. */
        case APP_STATE_INIT:
        {
            if (DRV_AT25DF_Status(DRV_AT25DF_INDEX) == SYS_STATUS_READY)
            {
                appData.state = APP_STATE_OPEN_DRIVER;
            }
            break;
        }

        case APP_STATE_OPEN_DRIVER:
        {
            appData.handle = DRV_AT25DF_Open(DRV_AT25DF_INDEX, DRV_IO_INTENT_READWRITE);

            if (appData.handle != DRV_HANDLE_INVALID)
            {
                DRV_AT25DF_EventHandlerSet(appData.handle, APP_FLASH_EventHandler, 0);
                appData.state = APP_STATE_GEOMETRY_GET;
            }

            break;
        }
        case APP_STATE_GEOMETRY_GET:
        {
            if (DRV_AT25DF_GeometryGet(appData.handle, &appData.geometry) != true)
            {
                appData.state = APP_STATE_ERROR;
                break;
            }

            appData.state = APP_STATE_GEOMETRY_WAIT;

            break;
        }

        case APP_STATE_GEOMETRY_WAIT:
        {
            if (appData.isTransferDone == true)
            {
                appData.state = APP_STATE_ERASE_FLASH;

                erase_index = 0;
                write_index = 0;

                appData.isTransferDone = false;
            }
            else if (DRV_AT25DF_TransferStatusGet(appData.handle) == DRV_AT25DF_TRANSFER_STATUS_ERROR)
            {
                appData.state = APP_STATE_ERROR;
            }
            break;
        }

        case APP_STATE_ERASE_FLASH:
        {
            if (DRV_AT25DF_SectorErase(appData.handle, (MEM_ADDRESS + erase_index)) != true)
            {
                appData.state = APP_STATE_ERROR;
            }

            appData.state = APP_STATE_ERASE_WAIT;

            break;
        }

        case APP_STATE_ERASE_WAIT:
        {
            if (appData.isTransferDone == true)
            {
                erase_index += appData.geometry.erase_blockSize;

                if (erase_index < BUFFER_SIZE)
                {
                    appData.state = APP_STATE_ERASE_FLASH;
                }
                else
                {
                    appData.state = APP_STATE_WRITE_MEMORY;
                }

                appData.isTransferDone = false;
            }
            else if (DRV_AT25DF_TransferStatusGet(appData.handle) == DRV_AT25DF_TRANSFER_ERROR_UNKNOWN)
            {
                appData.state = APP_STATE_ERROR;
            }
            break;
        }

        case APP_STATE_WRITE_MEMORY:
        {
            if (DRV_AT25DF_PageWrite(appData.handle, (uint32_t *)&appData.writeBuffer[write_index], (MEM_ADDRESS + write_index)) != true)
            {
                appData.state = APP_STATE_ERROR;
                break;
            }

            appData.state = APP_STATE_WRITE_WAIT;

            break;
        }

        case APP_STATE_WRITE_WAIT:
        {
            if (appData.isTransferDone == true)
            {
                write_index += appData.geometry.write_blockSize;

                if (write_index < BUFFER_SIZE)
                {
                    appData.state = APP_STATE_WRITE_MEMORY;
                }
                else
                {
                    appData.state = APP_STATE_READ_MEMORY;
                }

                appData.isTransferDone = false;
            }
            else if (DRV_AT25DF_TransferStatusGet(appData.handle) == DRV_AT25DF_TRANSFER_ERROR_UNKNOWN)
            {
                appData.state = APP_STATE_ERROR;
            }

            break;
        }

        case APP_STATE_READ_MEMORY:
        {
            if (DRV_AT25DF_Read(appData.handle, (uint32_t *)&appData.readBuffer, BUFFER_SIZE, MEM_ADDRESS) != true)
            {
                appData.state = APP_STATE_ERROR;
            }
            else
            {
                appData.state = APP_STATE_READ_WAIT;
            }

            break;
        }

        case APP_STATE_READ_WAIT:
        {
            if (appData.isTransferDone == true)
            {
                appData.isTransferDone = false;
                appData.state = APP_STATE_VERIFY_DATA;
            }
            else if (DRV_AT25DF_TransferStatusGet(appData.handle) == DRV_AT25DF_TRANSFER_ERROR_UNKNOWN)
            {
                appData.state = APP_STATE_ERROR;
            }

            break;
        }

        case APP_STATE_VERIFY_DATA:
        {
            if (!memcmp(appData.writeBuffer, appData.readBuffer, BUFFER_SIZE))
            {
                appData.state = APP_STATE_SUCCESS;
            }
            else
            {
                appData.state = APP_STATE_ERROR;
            }

            break;
        }

        case APP_STATE_SUCCESS:
        {
            DRV_AT25DF_Close(appData.handle);

            break;
        }

        case APP_STATE_ERROR:
        default:
        {
            DRV_AT25DF_Close(appData.handle);
            break;
        }
    }
}

```

**Parent topic:**[AT25DF Driver](GUID-474B546B-7629-40E2-AF5A-F6A6146CE8DE.md)

