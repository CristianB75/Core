# DRV\_SPI\_WriteReadTransferAdd Function

**Parent topic:**[Library Interface](GUID-2960D7B8-65FA-447F-AD81-B1E62002A04B.md)

## C

```c
void DRV_SPI_WriteReadTransferAdd
(
    const DRV_HANDLE handle,
    void* pTransmitData,
    size_t txSize,
    void* pReceiveData,
    size_t rxSize,
    DRV_SPI_TRANSFER_HANDLE * const transferHandle
);
```

## Summary

Queues a write-read transfer operation.

## Description

This function schedules a non-blocking write-read operation. The function<br />returns with a valid transfer handle in the transferHandle argument if<br />the request was scheduled successfully. The function adds the request to<br />the instance specific software queue and returns immediately. While the<br />request is in the queue, the application buffer is owned by the driver<br />and should not be modified.

This API will write txSize and at the same time counting of rxSize to be<br />read will start. If user wants 'n' bytes to be read after txSize has been<br />written, then he should keep rxSize value as 'txSize + n'.

The function returns DRV\_SPI\_TRANSFER\_HANDLE\_INVALID in the<br />transferHandle argument:

-   if neither of the transmit or receive arguments are valid.

-   if the transfer handle is NULL.

-   if the queue size is full or queue depth is insufficient.

-   if the driver handle is invalid.


If the requesting client registered an event callback with the driver, the<br />driver will issue a DRV\_SPI\_TRANSFER\_EVENT\_COMPLETE event if the transfer<br />was processed successfully or DRV\_SPI\_TRANSFER\_EVENT\_ERROR event if the<br />transfer was not processed successfully.

## Precondition

-   DRV\_SPI\_Open must have been called to obtain a valid opened device handle.

-   DRV\_SPI\_TransferSetup must have been called if GPIO pin has to be used for


chip select or any of the setup parameters has to be changed dynamically.

## Parameters

|Param|Description|
|-----|-----------|
|handle|Handle of the communication channel as returned by the DRV\_SPI\_Open function.|
|\*pTransmitData|Pointer to the data which has to be transmitted. If it is NULL, that means only data receiving is expected.|
|txSize|Number of bytes to be transmitted. The size must be specified in terms of the SPI data width. For example, if the data width is 8-bits, and if 10 bytes are being transmitted, then the txSize must be set to 10. If the data width is 16-bits then transmitting 10 bytes requires specifying the txSize as 10 \(meaning 10 16-bit words\).|
|\*pReceiveData|Pointer to the location where received data has to be stored. It is user's responsibility to ensure pointed location has sufficient memory to store the read data. if it is NULL, that means only data transmission is expected.|
|rxSize|Number of bytes to be received. The size must be specified in terms of the SPI data width. For example, if the data width is 8-bits, and if 10 bytes are being received, then the rxSize must be set to 10. If the data width is 16-bits then receiving 10 bytes requires specifying the rxSize as 10 \(meaning 10 16-bit words\). If "n" number of bytes has to be received AFTER transmitting "m" number of bytes, then "txSize" should be set as "m" and "rxSize" should be set as "m+n".|
|transferHandle|Handle which is returned by transfer add function.|

## Returns

None.

## Example

```c
MY_APP_OBJ myAppObj;
uint8_t myTxBuffer[MY_TX_BUFFER_SIZE];
uint8_t myRxBuffer[MY_RX_BUFFER_SIZE];
DRV_SPI_TRANSFER_HANDLE transferHandle;

// mySPIHandle is the handle returned by the DRV_SPI_Open function.

DRV_SPI_WriteReadTransferAdd(mySPIhandle, myTxBuffer, MY_TX_BUFFER_SIZE,
myRxBuffer, MY_RX_BUFFER_SIZE, &transferHandle);

if(transferHandle == DRV_SPI_TRANSFER_HANDLE_INVALID)
{
    // Error handling here
}

// Event is received when the transfer is processed.
```

## Remarks

-   This function can be called from within the SPI Driver Transfer Event Handler that is registered by the client.

-   It should not be called in the event handler associated with another SPI driver instance or event handler of any other peripheral.

-   It should not be called directly in any ISR.


