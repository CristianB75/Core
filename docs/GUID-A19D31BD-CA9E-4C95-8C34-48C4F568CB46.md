# DRV\_MEMORY\_Initialize Function

**Parent topic:**[Library Interface](GUID-E18B0923-4286-4E08-A2EB-9A482E0063AE.md)

## C

```c
SYS_MODULE_OBJ DRV_MEMORY_Initialize
(
    const SYS_MODULE_INDEX drvIndex,
    const SYS_MODULE_INIT * const init
);
```

## Summary

Initializes the Memory instance for the specified driver index

## Description

This routine initializes the Memory driver instance for the specified<br />driver index, making it ready for clients to open and use it.

## Precondition

None.

## Parameters

|Param|Description|
|-----|-----------|
|drvIndex|Identifier for the instance to be initialized|
|init|Pointer to a data structure containing any data necessary to initialize the driver.|

## Returns

If successful, returns a valid handle to a driver instance object. Otherwise it returns SYS\_MODULE\_OBJ\_INVALID.

## Example

```c
// This code snippet shows an example of initializing the Memory Driver
// with SST26 serial flash device attached and File system Enabled.

SYS_MODULE_OBJ objectHandle;

static uint8_t gDrvMemory0EraseBuffer[DRV_SST26_ERASE_BUFFER_SIZE] CACHE_ALIGN;

static DRV_MEMORY_CLIENT_OBJECT gDrvMemory0ClientObject[DRV_MEMORY_CLIENTS_NUMBER_IDX0] = { 0 };

static DRV_MEMORY_BUFFER_OBJECT gDrvMemory0BufferObject[DRV_MEMORY_BUFFER_QUEUE_SIZE_IDX0] = { 0 };

const DRV_MEMORY_DEVICE_INTERFACE drvMemory0DeviceAPI = {
    .Open = DRV_SST26_Open,
    .Close = DRV_SST26_Close,
    .Status = DRV_SST26_Status,
    .SectorErase = DRV_SST26_SectorErase,
    .Read = DRV_SST26_Read,
    .PageWrite = DRV_SST26_PageWrite,
    .EventHandlerSet = NULL,
    .GeometryGet = (DRV_MEMORY_DEVICE_GEOMETRY_GET)DRV_SST26_GeometryGet,
    .TransferStatusGet = (DRV_MEMORY_DEVICE_TRANSFER_STATUS_GET)DRV_SST26_TransferStatusGet
};

const DRV_MEMORY_INIT drvMemory0InitData =
{
    .memDevIndex = DRV_SST26_INDEX,
    .memoryDevice = &drvMemory0DeviceAPI,
    .isFsEnabled = true,
    .deviceMediaType = (uint8_t)SYS_FS_MEDIA_TYPE_SPIFLASH,
    .ewBuffer = &gDrvMemory0EraseBuffer[0],
    .clientObjPool = (uintptr_t)&gDrvMemory0ClientObject[0],
    .bufferObj = (uintptr_t)&gDrvMemory0BufferObject[0],
    .queueSize = DRV_MEMORY_BUFFER_QUEUE_SIZE_IDX0,
    .nClientsMax = DRV_MEMORY_CLIENTS_NUMBER_IDX0
};

//usage of DRV_MEMORY_INDEX_0 indicates usage of Flash-related APIs
objectHandle = DRV_MEMORY_Initialize((SYS_MODULE_INDEX)DRV_MEMORY_INDEX_0, (SYS_MODULE_INIT *)&drvMemory0InitData);

if (SYS_MODULE_OBJ_INVALID == objectHandle)
{
    // Handle error
}
```

## Remarks

This routine must be called before any other Memory routine is called.

This routine should only be called once during system initialization.

This routine will NEVER block for hardware access. If the operation requires time to allow the hardware to initialize, it will be reported by the DRV\_MEMORY\_Status operation. The system must use DRV\_MEMORY\_Status to find out when the driver is in the ready state.

