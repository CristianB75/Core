<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="DC.type" content="topic" />
<meta name="DC.title" content="How the Library Works" />
<meta name="DC.relation" scheme="URI" content="GUID-89A8332D-B4D0-4989-8602-EACDE3EE74AC.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="how-the-library-works" />
<link rel="stylesheet" type="text/css" href="stylesheets/commonltr.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<link rel="stylesheet" type="text/css" href="./stylesheets/common-extended.css" /><title>How the Library Works</title>
<meta name="Microsoft.Help.Id" content="GUID-EDFB1AB8-CD6B-446F-8E25-F2167287A1AF-how-the-library-works" />
<meta name="Microsoft.Help.TocParent" content="GUID-EDFB1AB8-CD6B-446F-8E25-F2167287A1AF" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLABÂ® Harmony Core Library Reference A 11/2021" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
        function cpy(id, button) {
        
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                    button.textContent = "Copy";
                    button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
              console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
        }
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?GUID-824D74D6-8B88-479A-8E92-981DECBE8204"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style></head>
<body id="how-the-library-works">
<h1 class="title topictitle1" id="ariaid-title1">How the Library Works</h1><div class="body"><p class="p">The SDSPI driver library is a multi-client, multi-instance buffer queue model based block driver interface.</p>
<p class="p"><strong class="ph b">Abstraction Model</strong></p>
<p class="p">The SDSPI driver provides abstraction to communicate with SD card through the SPI peripheral library or SPI driver interface.</p>
<br /><img class="image" src="GUID-2BBFAE25-0714-4ED7-85E7-25736EF749F9-low.png" alt="drv_sdspi_abstraction_model" /><br /><p class="p"><strong class="ph b">SDSPI Driver Features:</strong></p>
<ul class="ul"><li class="li"><p class="p">The SDSPI driver is built on top of SPI peripheral library or SPI driver</p>
</li>
<li class="li"><p class="p">The SDSPI driver Library registers an event handler with the underlying SPI peripheral library or the SPI Driver instance. This event handler is called by the SPI PLIB or the SPI driver from the interrupt context to notify the SDSPI driver that the requested transfer is complete</p>
</li>
<li class="li"><p class="p">When DMA is enabled and SPI PLIB is used, the SDSPI Driver registers an event handler with the DMA peripheral library. This event handler is called by by the DMA PLIB from the interrupt context once the DMA transfer is complete.</p>
</li>
<li class="li"><p class="p">When using SPI driver, the DMA operations are handled internally by the SPI driver. In this case, the SDSPI registers a callback with the SPI driver which in turn registers a callback with the DMA peripheral library.</p>
</li>
<li class="li"><p class="p">The SD Card driver state machine checks for SD Card attach/detach status using command-response mechanism. Once a SD Card is detected,</p>
<ul class="ul"><li class="li"><p class="p">The state machine initializes the SD Card making it ready for the client to submit read/write requests.</p>
</li>
<li class="li"><p class="p">After the SD Card is initialized, the state machine periodically checks if the SD Card is still connected using command/response mechanism.</p>
</li>
<li class="li"><p class="p">The rate at which the SD card driver checks for the SD Card attach/detach event can be specified via an MHC configuration option. In case RTOS is enabled, the RTOS Task Delay value for the SDSPI Driver task also affects the rate at which the SD Card attach/detach is checked.</p>
</li>
</ul>
</li>
</ul>
<p class="p">SDSPI driver is capable of working in both Asynchronous and Synchronous modes.</p>
<p class="p"><strong class="ph b">SDSPI driver in Asynchronous mode</strong></p>
<p class="p">Asynchronous mode APIs are non-blocking in nature. These APIs submit a request and return back to the application.</p>
<p class="p">Typically, if there are no on-going or pending requests in the driver's transfer queue, then the transfer is started by the API and completed from the peripheral interrupt. If there is an on-going transfer or one or more requests pending in the driver's transfer queue, then the request is added to the queue and executed when all the pending requests are complete. The size of the transfer queue is configurable using MCC based on application needs. The SD card driver state machine checks the driver transfer queue and executes any pending requests.</p>
<p class="p">The transfer APIs provide a transfer handle back to the application. If the driver was unable to accept the request, then the transfer handle will be set to NULL. This usually happens if the transfer queue is full or if invalid argruments are passed to the API. Application must check the value of the transfer handle to ensure the request was accepted successfully. Transfer handle can be used to identify/track the request.</p>
<p class="p">Application can either register a callback to get notified when the transfer is complete or poll the status of the request by calling the DRV_SDSPI_CommandStatusGet() API. Asynchronous mode APIs are available in both bare-metal and RTOS mode.</p>
<p class="p"><strong class="ph b">SDSPI driver in Synchronous mode</strong></p>
<p class="p">Synchronous mode APIs are blocking in nature. These APIs block until the transfer/request is complete. Synchronous mode APIs are only supported in RTOS mode. These APIs initate the transfer and then block on a semaphore while the transfer is in progress, thereby allowing other ready tasks to run. Once the transfer is complete, the semaphore is given (from the peripheral interrupt's context) thereby unblocking the calling task. The return value usually provides the status of the transfer.</p>
</div>
<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="GUID-89A8332D-B4D0-4989-8602-EACDE3EE74AC.html">SDSPI Driver</a></div>
</div>
</div></body>
</html>