var SearchFiles = ["GUID-C04D97AB-D6E0-4CF5-9A80-CA64E36B6199.html",
							"GUID-4FA4B38A-8C7F-46A3-9D08-4B8C5CE26712.html",
							"GUID-DFB9A1FE-5BBB-4A10-A4B0-430BA7B9AF94.html",
							"GUID-A702EBE1-F1A3-4196-A8E1-6FDBF06C2661.html",
							"GUID-A702EBE1-F1A3-4196-A8E1-6FDBF06C2661.html",
							"GUID-A702EBE1-F1A3-4196-A8E1-6FDBF06C2661.html",
							"GUID-A702EBE1-F1A3-4196-A8E1-6FDBF06C2661.html",
							"GUID-A702EBE1-F1A3-4196-A8E1-6FDBF06C2661.html",
							"GUID-90AA8C6C-F6A4-4135-9FFA-7BF0A708F5C4.html",
							"GUID-90AA8C6C-F6A4-4135-9FFA-7BF0A708F5C4.html",
							"GUID-90AA8C6C-F6A4-4135-9FFA-7BF0A708F5C4.html",
							"GUID-90AA8C6C-F6A4-4135-9FFA-7BF0A708F5C4.html",
							"GUID-90AA8C6C-F6A4-4135-9FFA-7BF0A708F5C4.html",
							"GUID-B87C652A-21F7-49B9-AD54-E19B3073BBBF.html",
							"GUID-B87C652A-21F7-49B9-AD54-E19B3073BBBF.html",
							"GUID-B87C652A-21F7-49B9-AD54-E19B3073BBBF.html",
							"GUID-B87C652A-21F7-49B9-AD54-E19B3073BBBF.html",
							"GUID-B87C652A-21F7-49B9-AD54-E19B3073BBBF.html",
							"GUID-E2B7203A-B587-450D-B7C1-2AFB4D061604.html",
							"GUID-E2B7203A-B587-450D-B7C1-2AFB4D061604.html",
							"GUID-E2B7203A-B587-450D-B7C1-2AFB4D061604.html",
							"GUID-E2B7203A-B587-450D-B7C1-2AFB4D061604.html",
							"GUID-E2B7203A-B587-450D-B7C1-2AFB4D061604.html",
							"GUID-73B432A5-32F5-40C6-8725-B37D613DFB1B.html",
							"GUID-73B432A5-32F5-40C6-8725-B37D613DFB1B.html",
							"GUID-73B432A5-32F5-40C6-8725-B37D613DFB1B.html",
							"GUID-73B432A5-32F5-40C6-8725-B37D613DFB1B.html",
							"GUID-73B432A5-32F5-40C6-8725-B37D613DFB1B.html",
							"GUID-ED3C040F-446A-4B35-9429-919E36E107D8.html",
							"GUID-ED3C040F-446A-4B35-9429-919E36E107D8.html",
							"GUID-ED3C040F-446A-4B35-9429-919E36E107D8.html",
							"GUID-ED3C040F-446A-4B35-9429-919E36E107D8.html",
							"GUID-ED3C040F-446A-4B35-9429-919E36E107D8.html",
							"GUID-26BFCB4C-9CD6-4D18-AD58-CB6437C8600F.html",
							"GUID-26BFCB4C-9CD6-4D18-AD58-CB6437C8600F.html",
							"GUID-26BFCB4C-9CD6-4D18-AD58-CB6437C8600F.html",
							"GUID-26BFCB4C-9CD6-4D18-AD58-CB6437C8600F.html",
							"GUID-26BFCB4C-9CD6-4D18-AD58-CB6437C8600F.html",
							"GUID-A49573DD-1DA6-4F69-AEF5-FFCB008FC6B4.html",
							"GUID-A49573DD-1DA6-4F69-AEF5-FFCB008FC6B4.html",
							"GUID-A49573DD-1DA6-4F69-AEF5-FFCB008FC6B4.html",
							"GUID-A49573DD-1DA6-4F69-AEF5-FFCB008FC6B4.html",
							"GUID-4321CAFA-57B5-4633-9D43-0AE24B87C101.html",
							"GUID-A420B807-5F28-4CED-9759-6E0F87209108.html",
							"GUID-8916AA7D-64C7-4477-8D26-664F6B3C242A.html",
							"GUID-5260AC5A-5DD0-4B08-9F03-7BB8E150DBE9.html",
							"GUID-5A5146D2-73C2-43B1-8ADE-95E0184AF1A5.html",
							"GUID-3BAF137E-6031-4F79-9871-CAF48B3CAFCF.html",
							"GUID-3BAF137E-6031-4F79-9871-CAF48B3CAFCF.html",
							"GUID-3BAF137E-6031-4F79-9871-CAF48B3CAFCF.html",
							"GUID-3BAF137E-6031-4F79-9871-CAF48B3CAFCF.html",
							"GUID-3BAF137E-6031-4F79-9871-CAF48B3CAFCF.html",
							"GUID-3BAF137E-6031-4F79-9871-CAF48B3CAFCF.html",
							"GUID-3BAF137E-6031-4F79-9871-CAF48B3CAFCF.html",
							"GUID-3BAF137E-6031-4F79-9871-CAF48B3CAFCF.html",
							"GUID-3BAF137E-6031-4F79-9871-CAF48B3CAFCF.html",
							"GUID-C649F093-C4DE-429B-A6FF-30C56927D08D.html",
							"GUID-C649F093-C4DE-429B-A6FF-30C56927D08D.html",
							"GUID-C649F093-C4DE-429B-A6FF-30C56927D08D.html",
							"GUID-C649F093-C4DE-429B-A6FF-30C56927D08D.html",
							"GUID-C649F093-C4DE-429B-A6FF-30C56927D08D.html",
							"GUID-C649F093-C4DE-429B-A6FF-30C56927D08D.html",
							"GUID-C649F093-C4DE-429B-A6FF-30C56927D08D.html",
							"GUID-C649F093-C4DE-429B-A6FF-30C56927D08D.html",
							"GUID-C649F093-C4DE-429B-A6FF-30C56927D08D.html",
							"GUID-01BBCD2F-0A31-4AAD-B9FF-C3079B145319.html",
							"GUID-01BBCD2F-0A31-4AAD-B9FF-C3079B145319.html",
							"GUID-01BBCD2F-0A31-4AAD-B9FF-C3079B145319.html",
							"GUID-01BBCD2F-0A31-4AAD-B9FF-C3079B145319.html",
							"GUID-01BBCD2F-0A31-4AAD-B9FF-C3079B145319.html",
							"GUID-01BBCD2F-0A31-4AAD-B9FF-C3079B145319.html",
							"GUID-01BBCD2F-0A31-4AAD-B9FF-C3079B145319.html",
							"GUID-01BBCD2F-0A31-4AAD-B9FF-C3079B145319.html",
							"GUID-01BBCD2F-0A31-4AAD-B9FF-C3079B145319.html",
							"GUID-CD039798-442A-45FD-8AE6-109618785CDE.html",
							"GUID-CD039798-442A-45FD-8AE6-109618785CDE.html",
							"GUID-CD039798-442A-45FD-8AE6-109618785CDE.html",
							"GUID-CD039798-442A-45FD-8AE6-109618785CDE.html",
							"GUID-CD039798-442A-45FD-8AE6-109618785CDE.html",
							"GUID-CD039798-442A-45FD-8AE6-109618785CDE.html",
							"GUID-CD039798-442A-45FD-8AE6-109618785CDE.html",
							"GUID-CD039798-442A-45FD-8AE6-109618785CDE.html",
							"GUID-CD039798-442A-45FD-8AE6-109618785CDE.html",
							"GUID-7C69A2E0-DCC4-4C21-A0B8-E9D7B1C9FB68.html",
							"GUID-7C69A2E0-DCC4-4C21-A0B8-E9D7B1C9FB68.html",
							"GUID-7C69A2E0-DCC4-4C21-A0B8-E9D7B1C9FB68.html",
							"GUID-7C69A2E0-DCC4-4C21-A0B8-E9D7B1C9FB68.html",
							"GUID-7C69A2E0-DCC4-4C21-A0B8-E9D7B1C9FB68.html",
							"GUID-7C69A2E0-DCC4-4C21-A0B8-E9D7B1C9FB68.html",
							"GUID-7C69A2E0-DCC4-4C21-A0B8-E9D7B1C9FB68.html",
							"GUID-7C69A2E0-DCC4-4C21-A0B8-E9D7B1C9FB68.html",
							"GUID-7C69A2E0-DCC4-4C21-A0B8-E9D7B1C9FB68.html",
							"GUID-4B36A81C-1035-4808-8990-AE3FC1A9E066.html",
							"GUID-4B36A81C-1035-4808-8990-AE3FC1A9E066.html",
							"GUID-4B36A81C-1035-4808-8990-AE3FC1A9E066.html",
							"GUID-4B36A81C-1035-4808-8990-AE3FC1A9E066.html",
							"GUID-4B36A81C-1035-4808-8990-AE3FC1A9E066.html",
							"GUID-4B36A81C-1035-4808-8990-AE3FC1A9E066.html",
							"GUID-4B36A81C-1035-4808-8990-AE3FC1A9E066.html",
							"GUID-4B36A81C-1035-4808-8990-AE3FC1A9E066.html",
							"GUID-4B36A81C-1035-4808-8990-AE3FC1A9E066.html",
							"GUID-5D54B76D-93EA-4179-8B1C-0CB174452F8D.html",
							"GUID-5D54B76D-93EA-4179-8B1C-0CB174452F8D.html",
							"GUID-5D54B76D-93EA-4179-8B1C-0CB174452F8D.html",
							"GUID-5D54B76D-93EA-4179-8B1C-0CB174452F8D.html",
							"GUID-5D54B76D-93EA-4179-8B1C-0CB174452F8D.html",
							"GUID-5D54B76D-93EA-4179-8B1C-0CB174452F8D.html",
							"GUID-5D54B76D-93EA-4179-8B1C-0CB174452F8D.html",
							"GUID-5D54B76D-93EA-4179-8B1C-0CB174452F8D.html",
							"GUID-5D54B76D-93EA-4179-8B1C-0CB174452F8D.html",
							"GUID-E09A5542-C013-412A-8E0A-BB14DF4B75DC.html",
							"GUID-E09A5542-C013-412A-8E0A-BB14DF4B75DC.html",
							"GUID-E09A5542-C013-412A-8E0A-BB14DF4B75DC.html",
							"GUID-E09A5542-C013-412A-8E0A-BB14DF4B75DC.html",
							"GUID-E09A5542-C013-412A-8E0A-BB14DF4B75DC.html",
							"GUID-E09A5542-C013-412A-8E0A-BB14DF4B75DC.html",
							"GUID-E09A5542-C013-412A-8E0A-BB14DF4B75DC.html",
							"GUID-E09A5542-C013-412A-8E0A-BB14DF4B75DC.html",
							"GUID-E09A5542-C013-412A-8E0A-BB14DF4B75DC.html",
							"GUID-16324E3F-ED9E-4290-8C2F-C346F4737630.html",
							"GUID-16324E3F-ED9E-4290-8C2F-C346F4737630.html",
							"GUID-16324E3F-ED9E-4290-8C2F-C346F4737630.html",
							"GUID-16324E3F-ED9E-4290-8C2F-C346F4737630.html",
							"GUID-16324E3F-ED9E-4290-8C2F-C346F4737630.html",
							"GUID-16324E3F-ED9E-4290-8C2F-C346F4737630.html",
							"GUID-16324E3F-ED9E-4290-8C2F-C346F4737630.html",
							"GUID-16324E3F-ED9E-4290-8C2F-C346F4737630.html",
							"GUID-16324E3F-ED9E-4290-8C2F-C346F4737630.html",
							"GUID-1CD0D245-E950-41C2-A344-8F1AEE6D25E7.html",
							"GUID-1CD0D245-E950-41C2-A344-8F1AEE6D25E7.html",
							"GUID-1CD0D245-E950-41C2-A344-8F1AEE6D25E7.html",
							"GUID-1CD0D245-E950-41C2-A344-8F1AEE6D25E7.html",
							"GUID-1CD0D245-E950-41C2-A344-8F1AEE6D25E7.html",
							"GUID-1CD0D245-E950-41C2-A344-8F1AEE6D25E7.html",
							"GUID-1CD0D245-E950-41C2-A344-8F1AEE6D25E7.html",
							"GUID-1CD0D245-E950-41C2-A344-8F1AEE6D25E7.html",
							"GUID-1CD0D245-E950-41C2-A344-8F1AEE6D25E7.html",
							"GUID-C99FBA78-A80D-40EE-B863-E40151E30C73.html",
							"GUID-C99FBA78-A80D-40EE-B863-E40151E30C73.html",
							"GUID-C99FBA78-A80D-40EE-B863-E40151E30C73.html",
							"GUID-C99FBA78-A80D-40EE-B863-E40151E30C73.html",
							"GUID-C99FBA78-A80D-40EE-B863-E40151E30C73.html",
							"GUID-C99FBA78-A80D-40EE-B863-E40151E30C73.html",
							"GUID-C99FBA78-A80D-40EE-B863-E40151E30C73.html",
							"GUID-C99FBA78-A80D-40EE-B863-E40151E30C73.html",
							"GUID-C99FBA78-A80D-40EE-B863-E40151E30C73.html",
							"GUID-EAE26434-377A-466D-AE23-BE529EE5B9A5.html",
							"GUID-EAE26434-377A-466D-AE23-BE529EE5B9A5.html",
							"GUID-EAE26434-377A-466D-AE23-BE529EE5B9A5.html",
							"GUID-EAE26434-377A-466D-AE23-BE529EE5B9A5.html",
							"GUID-EAE26434-377A-466D-AE23-BE529EE5B9A5.html",
							"GUID-EAE26434-377A-466D-AE23-BE529EE5B9A5.html",
							"GUID-EAE26434-377A-466D-AE23-BE529EE5B9A5.html",
							"GUID-EAE26434-377A-466D-AE23-BE529EE5B9A5.html",
							"GUID-EAE26434-377A-466D-AE23-BE529EE5B9A5.html",
							"GUID-7B27717C-849D-4E48-B9A2-96EE42486C40.html",
							"GUID-7B27717C-849D-4E48-B9A2-96EE42486C40.html",
							"GUID-7B27717C-849D-4E48-B9A2-96EE42486C40.html",
							"GUID-7B27717C-849D-4E48-B9A2-96EE42486C40.html",
							"GUID-7B27717C-849D-4E48-B9A2-96EE42486C40.html",
							"GUID-7B27717C-849D-4E48-B9A2-96EE42486C40.html",
							"GUID-7B27717C-849D-4E48-B9A2-96EE42486C40.html",
							"GUID-7B27717C-849D-4E48-B9A2-96EE42486C40.html",
							"GUID-7B27717C-849D-4E48-B9A2-96EE42486C40.html",
							"GUID-4196C380-7832-482B-95AB-EE6132ADBA1A.html",
							"GUID-4196C380-7832-482B-95AB-EE6132ADBA1A.html",
							"GUID-4196C380-7832-482B-95AB-EE6132ADBA1A.html",
							"GUID-4196C380-7832-482B-95AB-EE6132ADBA1A.html",
							"GUID-4196C380-7832-482B-95AB-EE6132ADBA1A.html",
							"GUID-4196C380-7832-482B-95AB-EE6132ADBA1A.html",
							"GUID-4196C380-7832-482B-95AB-EE6132ADBA1A.html",
							"GUID-4196C380-7832-482B-95AB-EE6132ADBA1A.html",
							"GUID-4196C380-7832-482B-95AB-EE6132ADBA1A.html",
							"GUID-F70A4A09-5846-4D15-80AC-3CCE1C614881.html",
							"GUID-F70A4A09-5846-4D15-80AC-3CCE1C614881.html",
							"GUID-F70A4A09-5846-4D15-80AC-3CCE1C614881.html",
							"GUID-F70A4A09-5846-4D15-80AC-3CCE1C614881.html",
							"GUID-F70A4A09-5846-4D15-80AC-3CCE1C614881.html",
							"GUID-F70A4A09-5846-4D15-80AC-3CCE1C614881.html",
							"GUID-F70A4A09-5846-4D15-80AC-3CCE1C614881.html",
							"GUID-F70A4A09-5846-4D15-80AC-3CCE1C614881.html",
							"GUID-F70A4A09-5846-4D15-80AC-3CCE1C614881.html",
							"GUID-025A300A-C4E6-40B2-9673-947AE4B14B2F.html",
							"GUID-025A300A-C4E6-40B2-9673-947AE4B14B2F.html",
							"GUID-025A300A-C4E6-40B2-9673-947AE4B14B2F.html",
							"GUID-025A300A-C4E6-40B2-9673-947AE4B14B2F.html",
							"GUID-025A300A-C4E6-40B2-9673-947AE4B14B2F.html",
							"GUID-025A300A-C4E6-40B2-9673-947AE4B14B2F.html",
							"GUID-025A300A-C4E6-40B2-9673-947AE4B14B2F.html",
							"GUID-025A300A-C4E6-40B2-9673-947AE4B14B2F.html",
							"GUID-025A300A-C4E6-40B2-9673-947AE4B14B2F.html",
							"GUID-E6644E02-AFFF-4E4A-9E5C-FD76D8FC49F9.html",
							"GUID-E6644E02-AFFF-4E4A-9E5C-FD76D8FC49F9.html",
							"GUID-E6644E02-AFFF-4E4A-9E5C-FD76D8FC49F9.html",
							"GUID-E6644E02-AFFF-4E4A-9E5C-FD76D8FC49F9.html",
							"GUID-E6644E02-AFFF-4E4A-9E5C-FD76D8FC49F9.html",
							"GUID-B94F1995-7F71-4184-96C7-A882FFCC32FA.html",
							"GUID-B94F1995-7F71-4184-96C7-A882FFCC32FA.html",
							"GUID-B94F1995-7F71-4184-96C7-A882FFCC32FA.html",
							"GUID-B94F1995-7F71-4184-96C7-A882FFCC32FA.html",
							"GUID-B94F1995-7F71-4184-96C7-A882FFCC32FA.html",
							"GUID-95F7ABE3-6864-4FC9-B11B-97B31ACF683C.html",
							"GUID-95F7ABE3-6864-4FC9-B11B-97B31ACF683C.html",
							"GUID-95F7ABE3-6864-4FC9-B11B-97B31ACF683C.html",
							"GUID-95F7ABE3-6864-4FC9-B11B-97B31ACF683C.html",
							"GUID-95F7ABE3-6864-4FC9-B11B-97B31ACF683C.html",
							"GUID-CE04AD55-D265-459E-AAD4-E2EC9FE3938F.html",
							"GUID-CE04AD55-D265-459E-AAD4-E2EC9FE3938F.html",
							"GUID-CE04AD55-D265-459E-AAD4-E2EC9FE3938F.html",
							"GUID-CE04AD55-D265-459E-AAD4-E2EC9FE3938F.html",
							"GUID-CE04AD55-D265-459E-AAD4-E2EC9FE3938F.html",
							"GUID-CE04AD55-D265-459E-AAD4-E2EC9FE3938F.html",
							"GUID-CE04AD55-D265-459E-AAD4-E2EC9FE3938F.html",
							"GUID-CE04AD55-D265-459E-AAD4-E2EC9FE3938F.html",
							"GUID-097B9FB1-23AD-4116-9FD4-C39462A4DC25.html",
							"GUID-097B9FB1-23AD-4116-9FD4-C39462A4DC25.html",
							"GUID-097B9FB1-23AD-4116-9FD4-C39462A4DC25.html",
							"GUID-097B9FB1-23AD-4116-9FD4-C39462A4DC25.html",
							"GUID-097B9FB1-23AD-4116-9FD4-C39462A4DC25.html",
							"GUID-0FFCD458-7F10-49C8-B068-E4E4B5439C47.html",
							"GUID-EAB93469-EF2D-48D7-AB27-B7E2A6B0A250.html",
							"GUID-8A5BD4DE-CB7C-4469-8159-D2A013406C01.html",
							"GUID-524A96DC-3A65-435E-97E1-C8D40A5C927B.html",
							"GUID-E18B0923-4286-4E08-A2EB-9A482E0063AE.html",
							"GUID-A19D31BD-CA9E-4C95-8C34-48C4F568CB46.html",
							"GUID-A19D31BD-CA9E-4C95-8C34-48C4F568CB46.html",
							"GUID-A19D31BD-CA9E-4C95-8C34-48C4F568CB46.html",
							"GUID-A19D31BD-CA9E-4C95-8C34-48C4F568CB46.html",
							"GUID-A19D31BD-CA9E-4C95-8C34-48C4F568CB46.html",
							"GUID-A19D31BD-CA9E-4C95-8C34-48C4F568CB46.html",
							"GUID-A19D31BD-CA9E-4C95-8C34-48C4F568CB46.html",
							"GUID-A19D31BD-CA9E-4C95-8C34-48C4F568CB46.html",
							"GUID-A19D31BD-CA9E-4C95-8C34-48C4F568CB46.html",
							"GUID-78A40801-3070-4F90-8BBC-C21C8AD1B362.html",
							"GUID-78A40801-3070-4F90-8BBC-C21C8AD1B362.html",
							"GUID-78A40801-3070-4F90-8BBC-C21C8AD1B362.html",
							"GUID-78A40801-3070-4F90-8BBC-C21C8AD1B362.html",
							"GUID-78A40801-3070-4F90-8BBC-C21C8AD1B362.html",
							"GUID-78A40801-3070-4F90-8BBC-C21C8AD1B362.html",
							"GUID-78A40801-3070-4F90-8BBC-C21C8AD1B362.html",
							"GUID-78A40801-3070-4F90-8BBC-C21C8AD1B362.html",
							"GUID-78A40801-3070-4F90-8BBC-C21C8AD1B362.html",
							"GUID-9C3DFDAE-818D-415D-8331-0F56F2817EBA.html",
							"GUID-9C3DFDAE-818D-415D-8331-0F56F2817EBA.html",
							"GUID-9C3DFDAE-818D-415D-8331-0F56F2817EBA.html",
							"GUID-9C3DFDAE-818D-415D-8331-0F56F2817EBA.html",
							"GUID-9C3DFDAE-818D-415D-8331-0F56F2817EBA.html",
							"GUID-9C3DFDAE-818D-415D-8331-0F56F2817EBA.html",
							"GUID-9C3DFDAE-818D-415D-8331-0F56F2817EBA.html",
							"GUID-9C3DFDAE-818D-415D-8331-0F56F2817EBA.html",
							"GUID-9C3DFDAE-818D-415D-8331-0F56F2817EBA.html",
							"GUID-E11AD2F4-E78A-41F1-A573-10270C7796D7.html",
							"GUID-E11AD2F4-E78A-41F1-A573-10270C7796D7.html",
							"GUID-E11AD2F4-E78A-41F1-A573-10270C7796D7.html",
							"GUID-E11AD2F4-E78A-41F1-A573-10270C7796D7.html",
							"GUID-E11AD2F4-E78A-41F1-A573-10270C7796D7.html",
							"GUID-E11AD2F4-E78A-41F1-A573-10270C7796D7.html",
							"GUID-E11AD2F4-E78A-41F1-A573-10270C7796D7.html",
							"GUID-E11AD2F4-E78A-41F1-A573-10270C7796D7.html",
							"GUID-E11AD2F4-E78A-41F1-A573-10270C7796D7.html",
							"GUID-8137CC20-0230-4197-A5B0-C6400C2617BC.html",
							"GUID-8137CC20-0230-4197-A5B0-C6400C2617BC.html",
							"GUID-8137CC20-0230-4197-A5B0-C6400C2617BC.html",
							"GUID-8137CC20-0230-4197-A5B0-C6400C2617BC.html",
							"GUID-8137CC20-0230-4197-A5B0-C6400C2617BC.html",
							"GUID-8137CC20-0230-4197-A5B0-C6400C2617BC.html",
							"GUID-8137CC20-0230-4197-A5B0-C6400C2617BC.html",
							"GUID-8137CC20-0230-4197-A5B0-C6400C2617BC.html",
							"GUID-8137CC20-0230-4197-A5B0-C6400C2617BC.html",
							"GUID-244989FC-1190-4854-8A64-9F0FAEF1B07C.html",
							"GUID-244989FC-1190-4854-8A64-9F0FAEF1B07C.html",
							"GUID-244989FC-1190-4854-8A64-9F0FAEF1B07C.html",
							"GUID-244989FC-1190-4854-8A64-9F0FAEF1B07C.html",
							"GUID-244989FC-1190-4854-8A64-9F0FAEF1B07C.html",
							"GUID-244989FC-1190-4854-8A64-9F0FAEF1B07C.html",
							"GUID-244989FC-1190-4854-8A64-9F0FAEF1B07C.html",
							"GUID-244989FC-1190-4854-8A64-9F0FAEF1B07C.html",
							"GUID-244989FC-1190-4854-8A64-9F0FAEF1B07C.html",
							"GUID-F499493F-2392-4CEC-B4B4-E61FD279CABE.html",
							"GUID-F499493F-2392-4CEC-B4B4-E61FD279CABE.html",
							"GUID-F499493F-2392-4CEC-B4B4-E61FD279CABE.html",
							"GUID-F499493F-2392-4CEC-B4B4-E61FD279CABE.html",
							"GUID-F499493F-2392-4CEC-B4B4-E61FD279CABE.html",
							"GUID-F499493F-2392-4CEC-B4B4-E61FD279CABE.html",
							"GUID-F499493F-2392-4CEC-B4B4-E61FD279CABE.html",
							"GUID-F499493F-2392-4CEC-B4B4-E61FD279CABE.html",
							"GUID-F499493F-2392-4CEC-B4B4-E61FD279CABE.html",
							"GUID-8D0CD4FB-C2B2-4AF4-8DB0-D6424CB9EAE1.html",
							"GUID-8D0CD4FB-C2B2-4AF4-8DB0-D6424CB9EAE1.html",
							"GUID-8D0CD4FB-C2B2-4AF4-8DB0-D6424CB9EAE1.html",
							"GUID-8D0CD4FB-C2B2-4AF4-8DB0-D6424CB9EAE1.html",
							"GUID-8D0CD4FB-C2B2-4AF4-8DB0-D6424CB9EAE1.html",
							"GUID-8D0CD4FB-C2B2-4AF4-8DB0-D6424CB9EAE1.html",
							"GUID-8D0CD4FB-C2B2-4AF4-8DB0-D6424CB9EAE1.html",
							"GUID-8D0CD4FB-C2B2-4AF4-8DB0-D6424CB9EAE1.html",
							"GUID-8D0CD4FB-C2B2-4AF4-8DB0-D6424CB9EAE1.html",
							"GUID-0B4A66DB-3680-46D5-BC13-EEA9E8A84481.html",
							"GUID-0B4A66DB-3680-46D5-BC13-EEA9E8A84481.html",
							"GUID-0B4A66DB-3680-46D5-BC13-EEA9E8A84481.html",
							"GUID-0B4A66DB-3680-46D5-BC13-EEA9E8A84481.html",
							"GUID-0B4A66DB-3680-46D5-BC13-EEA9E8A84481.html",
							"GUID-0B4A66DB-3680-46D5-BC13-EEA9E8A84481.html",
							"GUID-0B4A66DB-3680-46D5-BC13-EEA9E8A84481.html",
							"GUID-0B4A66DB-3680-46D5-BC13-EEA9E8A84481.html",
							"GUID-0B4A66DB-3680-46D5-BC13-EEA9E8A84481.html",
							"GUID-6655C843-3384-4DCB-8625-657E0EAD198B.html",
							"GUID-6655C843-3384-4DCB-8625-657E0EAD198B.html",
							"GUID-6655C843-3384-4DCB-8625-657E0EAD198B.html",
							"GUID-6655C843-3384-4DCB-8625-657E0EAD198B.html",
							"GUID-6655C843-3384-4DCB-8625-657E0EAD198B.html",
							"GUID-6655C843-3384-4DCB-8625-657E0EAD198B.html",
							"GUID-6655C843-3384-4DCB-8625-657E0EAD198B.html",
							"GUID-6655C843-3384-4DCB-8625-657E0EAD198B.html",
							"GUID-6655C843-3384-4DCB-8625-657E0EAD198B.html",
							"GUID-C8F255A5-C992-465D-A4B5-B62A2B89421F.html",
							"GUID-C8F255A5-C992-465D-A4B5-B62A2B89421F.html",
							"GUID-C8F255A5-C992-465D-A4B5-B62A2B89421F.html",
							"GUID-C8F255A5-C992-465D-A4B5-B62A2B89421F.html",
							"GUID-C8F255A5-C992-465D-A4B5-B62A2B89421F.html",
							"GUID-C8F255A5-C992-465D-A4B5-B62A2B89421F.html",
							"GUID-C8F255A5-C992-465D-A4B5-B62A2B89421F.html",
							"GUID-C8F255A5-C992-465D-A4B5-B62A2B89421F.html",
							"GUID-C8F255A5-C992-465D-A4B5-B62A2B89421F.html",
							"GUID-422BF1E5-FCA5-4BDA-86FF-1D69B0F9EE60.html",
							"GUID-422BF1E5-FCA5-4BDA-86FF-1D69B0F9EE60.html",
							"GUID-422BF1E5-FCA5-4BDA-86FF-1D69B0F9EE60.html",
							"GUID-422BF1E5-FCA5-4BDA-86FF-1D69B0F9EE60.html",
							"GUID-422BF1E5-FCA5-4BDA-86FF-1D69B0F9EE60.html",
							"GUID-422BF1E5-FCA5-4BDA-86FF-1D69B0F9EE60.html",
							"GUID-422BF1E5-FCA5-4BDA-86FF-1D69B0F9EE60.html",
							"GUID-422BF1E5-FCA5-4BDA-86FF-1D69B0F9EE60.html",
							"GUID-422BF1E5-FCA5-4BDA-86FF-1D69B0F9EE60.html",
							"GUID-76235F7D-E608-44C6-AFA4-73A09FF0EA9C.html",
							"GUID-76235F7D-E608-44C6-AFA4-73A09FF0EA9C.html",
							"GUID-76235F7D-E608-44C6-AFA4-73A09FF0EA9C.html",
							"GUID-76235F7D-E608-44C6-AFA4-73A09FF0EA9C.html",
							"GUID-76235F7D-E608-44C6-AFA4-73A09FF0EA9C.html",
							"GUID-76235F7D-E608-44C6-AFA4-73A09FF0EA9C.html",
							"GUID-76235F7D-E608-44C6-AFA4-73A09FF0EA9C.html",
							"GUID-76235F7D-E608-44C6-AFA4-73A09FF0EA9C.html",
							"GUID-76235F7D-E608-44C6-AFA4-73A09FF0EA9C.html",
							"GUID-40F0EA45-9E7D-4BE2-8DBF-31942FA1BD7D.html",
							"GUID-40F0EA45-9E7D-4BE2-8DBF-31942FA1BD7D.html",
							"GUID-40F0EA45-9E7D-4BE2-8DBF-31942FA1BD7D.html",
							"GUID-40F0EA45-9E7D-4BE2-8DBF-31942FA1BD7D.html",
							"GUID-40F0EA45-9E7D-4BE2-8DBF-31942FA1BD7D.html",
							"GUID-40F0EA45-9E7D-4BE2-8DBF-31942FA1BD7D.html",
							"GUID-40F0EA45-9E7D-4BE2-8DBF-31942FA1BD7D.html",
							"GUID-40F0EA45-9E7D-4BE2-8DBF-31942FA1BD7D.html",
							"GUID-40F0EA45-9E7D-4BE2-8DBF-31942FA1BD7D.html",
							"GUID-B409B252-4361-430D-8B89-48AAE39FD066.html",
							"GUID-B409B252-4361-430D-8B89-48AAE39FD066.html",
							"GUID-B409B252-4361-430D-8B89-48AAE39FD066.html",
							"GUID-B409B252-4361-430D-8B89-48AAE39FD066.html",
							"GUID-B409B252-4361-430D-8B89-48AAE39FD066.html",
							"GUID-B409B252-4361-430D-8B89-48AAE39FD066.html",
							"GUID-B409B252-4361-430D-8B89-48AAE39FD066.html",
							"GUID-B409B252-4361-430D-8B89-48AAE39FD066.html",
							"GUID-B409B252-4361-430D-8B89-48AAE39FD066.html",
							"GUID-6E6BFBF9-12EB-436D-9D2F-4611B260D7EF.html",
							"GUID-6E6BFBF9-12EB-436D-9D2F-4611B260D7EF.html",
							"GUID-6E6BFBF9-12EB-436D-9D2F-4611B260D7EF.html",
							"GUID-6E6BFBF9-12EB-436D-9D2F-4611B260D7EF.html",
							"GUID-6E6BFBF9-12EB-436D-9D2F-4611B260D7EF.html",
							"GUID-6E6BFBF9-12EB-436D-9D2F-4611B260D7EF.html",
							"GUID-6E6BFBF9-12EB-436D-9D2F-4611B260D7EF.html",
							"GUID-6E6BFBF9-12EB-436D-9D2F-4611B260D7EF.html",
							"GUID-6E6BFBF9-12EB-436D-9D2F-4611B260D7EF.html",
							"GUID-066D0FA7-453C-4736-8064-5E4224C50558.html",
							"GUID-066D0FA7-453C-4736-8064-5E4224C50558.html",
							"GUID-066D0FA7-453C-4736-8064-5E4224C50558.html",
							"GUID-066D0FA7-453C-4736-8064-5E4224C50558.html",
							"GUID-066D0FA7-453C-4736-8064-5E4224C50558.html",
							"GUID-066D0FA7-453C-4736-8064-5E4224C50558.html",
							"GUID-066D0FA7-453C-4736-8064-5E4224C50558.html",
							"GUID-066D0FA7-453C-4736-8064-5E4224C50558.html",
							"GUID-066D0FA7-453C-4736-8064-5E4224C50558.html",
							"GUID-3488A96B-8C3E-4967-9197-2376AB3B45E6.html",
							"GUID-3488A96B-8C3E-4967-9197-2376AB3B45E6.html",
							"GUID-3488A96B-8C3E-4967-9197-2376AB3B45E6.html",
							"GUID-3488A96B-8C3E-4967-9197-2376AB3B45E6.html",
							"GUID-3488A96B-8C3E-4967-9197-2376AB3B45E6.html",
							"GUID-3488A96B-8C3E-4967-9197-2376AB3B45E6.html",
							"GUID-3488A96B-8C3E-4967-9197-2376AB3B45E6.html",
							"GUID-3488A96B-8C3E-4967-9197-2376AB3B45E6.html",
							"GUID-3488A96B-8C3E-4967-9197-2376AB3B45E6.html",
							"GUID-47211219-744B-487E-975A-C6D963B11DE7.html",
							"GUID-47211219-744B-487E-975A-C6D963B11DE7.html",
							"GUID-47211219-744B-487E-975A-C6D963B11DE7.html",
							"GUID-47211219-744B-487E-975A-C6D963B11DE7.html",
							"GUID-47211219-744B-487E-975A-C6D963B11DE7.html",
							"GUID-47211219-744B-487E-975A-C6D963B11DE7.html",
							"GUID-47211219-744B-487E-975A-C6D963B11DE7.html",
							"GUID-47211219-744B-487E-975A-C6D963B11DE7.html",
							"GUID-47211219-744B-487E-975A-C6D963B11DE7.html",
							"GUID-B4934CBC-6AF2-495C-AC8D-576C20729D5F.html",
							"GUID-B4934CBC-6AF2-495C-AC8D-576C20729D5F.html",
							"GUID-B4934CBC-6AF2-495C-AC8D-576C20729D5F.html",
							"GUID-B4934CBC-6AF2-495C-AC8D-576C20729D5F.html",
							"GUID-B4934CBC-6AF2-495C-AC8D-576C20729D5F.html",
							"GUID-B4934CBC-6AF2-495C-AC8D-576C20729D5F.html",
							"GUID-B4934CBC-6AF2-495C-AC8D-576C20729D5F.html",
							"GUID-B4934CBC-6AF2-495C-AC8D-576C20729D5F.html",
							"GUID-B4934CBC-6AF2-495C-AC8D-576C20729D5F.html",
							"GUID-5587D300-1C17-4DCA-B342-9B2E74824EFB.html",
							"GUID-5587D300-1C17-4DCA-B342-9B2E74824EFB.html",
							"GUID-5587D300-1C17-4DCA-B342-9B2E74824EFB.html",
							"GUID-5587D300-1C17-4DCA-B342-9B2E74824EFB.html",
							"GUID-5587D300-1C17-4DCA-B342-9B2E74824EFB.html",
							"GUID-5587D300-1C17-4DCA-B342-9B2E74824EFB.html",
							"GUID-5587D300-1C17-4DCA-B342-9B2E74824EFB.html",
							"GUID-5587D300-1C17-4DCA-B342-9B2E74824EFB.html",
							"GUID-509B01EA-57F1-449C-A03F-EE3761F22F4E.html",
							"GUID-509B01EA-57F1-449C-A03F-EE3761F22F4E.html",
							"GUID-509B01EA-57F1-449C-A03F-EE3761F22F4E.html",
							"GUID-509B01EA-57F1-449C-A03F-EE3761F22F4E.html",
							"GUID-509B01EA-57F1-449C-A03F-EE3761F22F4E.html",
							"GUID-509B01EA-57F1-449C-A03F-EE3761F22F4E.html",
							"GUID-509B01EA-57F1-449C-A03F-EE3761F22F4E.html",
							"GUID-509B01EA-57F1-449C-A03F-EE3761F22F4E.html",
							"GUID-EF2E2FE9-A7F4-41F0-B5F3-3002C0E9396B.html",
							"GUID-EF2E2FE9-A7F4-41F0-B5F3-3002C0E9396B.html",
							"GUID-EF2E2FE9-A7F4-41F0-B5F3-3002C0E9396B.html",
							"GUID-EF2E2FE9-A7F4-41F0-B5F3-3002C0E9396B.html",
							"GUID-EF2E2FE9-A7F4-41F0-B5F3-3002C0E9396B.html",
							"GUID-EF2E2FE9-A7F4-41F0-B5F3-3002C0E9396B.html",
							"GUID-EF2E2FE9-A7F4-41F0-B5F3-3002C0E9396B.html",
							"GUID-EF2E2FE9-A7F4-41F0-B5F3-3002C0E9396B.html",
							"GUID-C59F079A-EB80-4DFE-9FD1-B83486B907CE.html",
							"GUID-C59F079A-EB80-4DFE-9FD1-B83486B907CE.html",
							"GUID-C59F079A-EB80-4DFE-9FD1-B83486B907CE.html",
							"GUID-C59F079A-EB80-4DFE-9FD1-B83486B907CE.html",
							"GUID-C59F079A-EB80-4DFE-9FD1-B83486B907CE.html",
							"GUID-C59F079A-EB80-4DFE-9FD1-B83486B907CE.html",
							"GUID-C59F079A-EB80-4DFE-9FD1-B83486B907CE.html",
							"GUID-C59F079A-EB80-4DFE-9FD1-B83486B907CE.html",
							"GUID-1F0928CE-E0E0-45E3-8717-E96769FA7B9F.html",
							"GUID-1F0928CE-E0E0-45E3-8717-E96769FA7B9F.html",
							"GUID-1F0928CE-E0E0-45E3-8717-E96769FA7B9F.html",
							"GUID-1F0928CE-E0E0-45E3-8717-E96769FA7B9F.html",
							"GUID-1F0928CE-E0E0-45E3-8717-E96769FA7B9F.html",
							"GUID-8095D76B-9C45-4295-94E8-D01CCCACAC91.html",
							"GUID-8095D76B-9C45-4295-94E8-D01CCCACAC91.html",
							"GUID-8095D76B-9C45-4295-94E8-D01CCCACAC91.html",
							"GUID-8095D76B-9C45-4295-94E8-D01CCCACAC91.html",
							"GUID-8095D76B-9C45-4295-94E8-D01CCCACAC91.html",
							"GUID-F6ADE0BF-13E7-4331-80CE-9FA9B5C33750.html",
							"GUID-F6ADE0BF-13E7-4331-80CE-9FA9B5C33750.html",
							"GUID-F6ADE0BF-13E7-4331-80CE-9FA9B5C33750.html",
							"GUID-F6ADE0BF-13E7-4331-80CE-9FA9B5C33750.html",
							"GUID-F6ADE0BF-13E7-4331-80CE-9FA9B5C33750.html",
							"GUID-3C10B2F9-8190-47F4-864D-813923E49E2F.html",
							"GUID-3C10B2F9-8190-47F4-864D-813923E49E2F.html",
							"GUID-3C10B2F9-8190-47F4-864D-813923E49E2F.html",
							"GUID-3C10B2F9-8190-47F4-864D-813923E49E2F.html",
							"GUID-3C10B2F9-8190-47F4-864D-813923E49E2F.html",
							"GUID-377058D8-9B13-47BE-A92A-47523CB84B3B.html",
							"GUID-377058D8-9B13-47BE-A92A-47523CB84B3B.html",
							"GUID-377058D8-9B13-47BE-A92A-47523CB84B3B.html",
							"GUID-377058D8-9B13-47BE-A92A-47523CB84B3B.html",
							"GUID-377058D8-9B13-47BE-A92A-47523CB84B3B.html",
							"GUID-377058D8-9B13-47BE-A92A-47523CB84B3B.html",
							"GUID-377058D8-9B13-47BE-A92A-47523CB84B3B.html",
							"GUID-377058D8-9B13-47BE-A92A-47523CB84B3B.html",
							"GUID-FC3149C2-1EB6-47A0-8FA6-89584991B2BD.html",
							"GUID-FC3149C2-1EB6-47A0-8FA6-89584991B2BD.html",
							"GUID-FC3149C2-1EB6-47A0-8FA6-89584991B2BD.html",
							"GUID-FC3149C2-1EB6-47A0-8FA6-89584991B2BD.html",
							"GUID-FC3149C2-1EB6-47A0-8FA6-89584991B2BD.html",
							"GUID-5E1BD4E4-2CE2-43D1-B83A-CA20B9F7F3DD.html",
							"GUID-5E1BD4E4-2CE2-43D1-B83A-CA20B9F7F3DD.html",
							"GUID-5E1BD4E4-2CE2-43D1-B83A-CA20B9F7F3DD.html",
							"GUID-5E1BD4E4-2CE2-43D1-B83A-CA20B9F7F3DD.html",
							"GUID-5E1BD4E4-2CE2-43D1-B83A-CA20B9F7F3DD.html",
							"GUID-65ACFCA1-A979-4EE6-B224-6CC63491ACED.html",
							"GUID-65ACFCA1-A979-4EE6-B224-6CC63491ACED.html",
							"GUID-65ACFCA1-A979-4EE6-B224-6CC63491ACED.html",
							"GUID-65ACFCA1-A979-4EE6-B224-6CC63491ACED.html",
							"GUID-65ACFCA1-A979-4EE6-B224-6CC63491ACED.html",
							"GUID-FCE79155-DFAA-434F-B53C-FB851BD38651.html",
							"GUID-FCE79155-DFAA-434F-B53C-FB851BD38651.html",
							"GUID-FCE79155-DFAA-434F-B53C-FB851BD38651.html",
							"GUID-FCE79155-DFAA-434F-B53C-FB851BD38651.html",
							"GUID-FCE79155-DFAA-434F-B53C-FB851BD38651.html",
							"GUID-BFFB8AD8-CD11-49AB-8C23-F860A883EFE6.html",
							"GUID-349C448C-06FF-4386-B995-DB152263E91D.html",
							"GUID-593ADB30-88DF-480D-A357-40AFF127A20F.html",
							"GUID-670AE57E-73F2-4D46-A66C-8A60E8B4D5DC.html",
							"GUID-B826AB75-F4E4-4A5B-8189-23C99CCF9936.html",
							"GUID-B788B85C-F76E-45BC-BFEE-675AB9F65F24.html",
							"GUID-B788B85C-F76E-45BC-BFEE-675AB9F65F24.html",
							"GUID-B788B85C-F76E-45BC-BFEE-675AB9F65F24.html",
							"GUID-B788B85C-F76E-45BC-BFEE-675AB9F65F24.html",
							"GUID-B788B85C-F76E-45BC-BFEE-675AB9F65F24.html",
							"GUID-B788B85C-F76E-45BC-BFEE-675AB9F65F24.html",
							"GUID-B788B85C-F76E-45BC-BFEE-675AB9F65F24.html",
							"GUID-B788B85C-F76E-45BC-BFEE-675AB9F65F24.html",
							"GUID-B788B85C-F76E-45BC-BFEE-675AB9F65F24.html",
							"GUID-40FC6C8F-A9BE-4F4C-8018-023DDA62F25C.html",
							"GUID-40FC6C8F-A9BE-4F4C-8018-023DDA62F25C.html",
							"GUID-40FC6C8F-A9BE-4F4C-8018-023DDA62F25C.html",
							"GUID-40FC6C8F-A9BE-4F4C-8018-023DDA62F25C.html",
							"GUID-40FC6C8F-A9BE-4F4C-8018-023DDA62F25C.html",
							"GUID-40FC6C8F-A9BE-4F4C-8018-023DDA62F25C.html",
							"GUID-40FC6C8F-A9BE-4F4C-8018-023DDA62F25C.html",
							"GUID-40FC6C8F-A9BE-4F4C-8018-023DDA62F25C.html",
							"GUID-40FC6C8F-A9BE-4F4C-8018-023DDA62F25C.html",
							"GUID-B7F44552-2789-45AD-9991-863E7393A4D1.html",
							"GUID-B7F44552-2789-45AD-9991-863E7393A4D1.html",
							"GUID-B7F44552-2789-45AD-9991-863E7393A4D1.html",
							"GUID-B7F44552-2789-45AD-9991-863E7393A4D1.html",
							"GUID-B7F44552-2789-45AD-9991-863E7393A4D1.html",
							"GUID-B7F44552-2789-45AD-9991-863E7393A4D1.html",
							"GUID-B7F44552-2789-45AD-9991-863E7393A4D1.html",
							"GUID-B7F44552-2789-45AD-9991-863E7393A4D1.html",
							"GUID-B7F44552-2789-45AD-9991-863E7393A4D1.html",
							"GUID-B1338A2F-44F5-4552-BDC3-CFEE94C95352.html",
							"GUID-B1338A2F-44F5-4552-BDC3-CFEE94C95352.html",
							"GUID-B1338A2F-44F5-4552-BDC3-CFEE94C95352.html",
							"GUID-B1338A2F-44F5-4552-BDC3-CFEE94C95352.html",
							"GUID-B1338A2F-44F5-4552-BDC3-CFEE94C95352.html",
							"GUID-B1338A2F-44F5-4552-BDC3-CFEE94C95352.html",
							"GUID-B1338A2F-44F5-4552-BDC3-CFEE94C95352.html",
							"GUID-B1338A2F-44F5-4552-BDC3-CFEE94C95352.html",
							"GUID-B1338A2F-44F5-4552-BDC3-CFEE94C95352.html",
							"GUID-EA1BD8AC-C8F2-4384-BD6E-69E98116CD12.html",
							"GUID-EA1BD8AC-C8F2-4384-BD6E-69E98116CD12.html",
							"GUID-EA1BD8AC-C8F2-4384-BD6E-69E98116CD12.html",
							"GUID-EA1BD8AC-C8F2-4384-BD6E-69E98116CD12.html",
							"GUID-EA1BD8AC-C8F2-4384-BD6E-69E98116CD12.html",
							"GUID-EA1BD8AC-C8F2-4384-BD6E-69E98116CD12.html",
							"GUID-EA1BD8AC-C8F2-4384-BD6E-69E98116CD12.html",
							"GUID-EA1BD8AC-C8F2-4384-BD6E-69E98116CD12.html",
							"GUID-EA1BD8AC-C8F2-4384-BD6E-69E98116CD12.html",
							"GUID-9D71A235-3591-4967-B36E-784C76F51D77.html",
							"GUID-9D71A235-3591-4967-B36E-784C76F51D77.html",
							"GUID-9D71A235-3591-4967-B36E-784C76F51D77.html",
							"GUID-9D71A235-3591-4967-B36E-784C76F51D77.html",
							"GUID-9D71A235-3591-4967-B36E-784C76F51D77.html",
							"GUID-9D71A235-3591-4967-B36E-784C76F51D77.html",
							"GUID-9D71A235-3591-4967-B36E-784C76F51D77.html",
							"GUID-9D71A235-3591-4967-B36E-784C76F51D77.html",
							"GUID-9D71A235-3591-4967-B36E-784C76F51D77.html",
							"GUID-50C9DFD3-F88C-465B-B427-B5F2FDDE3683.html",
							"GUID-50C9DFD3-F88C-465B-B427-B5F2FDDE3683.html",
							"GUID-50C9DFD3-F88C-465B-B427-B5F2FDDE3683.html",
							"GUID-50C9DFD3-F88C-465B-B427-B5F2FDDE3683.html",
							"GUID-50C9DFD3-F88C-465B-B427-B5F2FDDE3683.html",
							"GUID-50C9DFD3-F88C-465B-B427-B5F2FDDE3683.html",
							"GUID-50C9DFD3-F88C-465B-B427-B5F2FDDE3683.html",
							"GUID-50C9DFD3-F88C-465B-B427-B5F2FDDE3683.html",
							"GUID-50C9DFD3-F88C-465B-B427-B5F2FDDE3683.html",
							"GUID-1A13AEB3-150C-408D-B529-1E3561FEDF5C.html",
							"GUID-1A13AEB3-150C-408D-B529-1E3561FEDF5C.html",
							"GUID-1A13AEB3-150C-408D-B529-1E3561FEDF5C.html",
							"GUID-1A13AEB3-150C-408D-B529-1E3561FEDF5C.html",
							"GUID-1A13AEB3-150C-408D-B529-1E3561FEDF5C.html",
							"GUID-1A13AEB3-150C-408D-B529-1E3561FEDF5C.html",
							"GUID-1A13AEB3-150C-408D-B529-1E3561FEDF5C.html",
							"GUID-1A13AEB3-150C-408D-B529-1E3561FEDF5C.html",
							"GUID-1A13AEB3-150C-408D-B529-1E3561FEDF5C.html",
							"GUID-A95E6C8D-4FD6-4826-9FB5-E19136C3BA6D.html",
							"GUID-A95E6C8D-4FD6-4826-9FB5-E19136C3BA6D.html",
							"GUID-A95E6C8D-4FD6-4826-9FB5-E19136C3BA6D.html",
							"GUID-A95E6C8D-4FD6-4826-9FB5-E19136C3BA6D.html",
							"GUID-A95E6C8D-4FD6-4826-9FB5-E19136C3BA6D.html",
							"GUID-A95E6C8D-4FD6-4826-9FB5-E19136C3BA6D.html",
							"GUID-A95E6C8D-4FD6-4826-9FB5-E19136C3BA6D.html",
							"GUID-A95E6C8D-4FD6-4826-9FB5-E19136C3BA6D.html",
							"GUID-A95E6C8D-4FD6-4826-9FB5-E19136C3BA6D.html",
							"GUID-4D20130A-177C-4FBC-844D-B327AA396FBB.html",
							"GUID-4D20130A-177C-4FBC-844D-B327AA396FBB.html",
							"GUID-4D20130A-177C-4FBC-844D-B327AA396FBB.html",
							"GUID-4D20130A-177C-4FBC-844D-B327AA396FBB.html",
							"GUID-4D20130A-177C-4FBC-844D-B327AA396FBB.html",
							"GUID-4D20130A-177C-4FBC-844D-B327AA396FBB.html",
							"GUID-4D20130A-177C-4FBC-844D-B327AA396FBB.html",
							"GUID-4D20130A-177C-4FBC-844D-B327AA396FBB.html",
							"GUID-4D20130A-177C-4FBC-844D-B327AA396FBB.html",
							"GUID-A59EF3BD-F9F2-408B-9816-E96D313A2838.html",
							"GUID-A59EF3BD-F9F2-408B-9816-E96D313A2838.html",
							"GUID-A59EF3BD-F9F2-408B-9816-E96D313A2838.html",
							"GUID-A59EF3BD-F9F2-408B-9816-E96D313A2838.html",
							"GUID-A59EF3BD-F9F2-408B-9816-E96D313A2838.html",
							"GUID-A59EF3BD-F9F2-408B-9816-E96D313A2838.html",
							"GUID-A59EF3BD-F9F2-408B-9816-E96D313A2838.html",
							"GUID-A59EF3BD-F9F2-408B-9816-E96D313A2838.html",
							"GUID-A59EF3BD-F9F2-408B-9816-E96D313A2838.html",
							"GUID-C8718125-6D8E-466C-A17B-8DF5DEC4DCBA.html",
							"GUID-C8718125-6D8E-466C-A17B-8DF5DEC4DCBA.html",
							"GUID-C8718125-6D8E-466C-A17B-8DF5DEC4DCBA.html",
							"GUID-C8718125-6D8E-466C-A17B-8DF5DEC4DCBA.html",
							"GUID-C8718125-6D8E-466C-A17B-8DF5DEC4DCBA.html",
							"GUID-C8718125-6D8E-466C-A17B-8DF5DEC4DCBA.html",
							"GUID-C8718125-6D8E-466C-A17B-8DF5DEC4DCBA.html",
							"GUID-C8718125-6D8E-466C-A17B-8DF5DEC4DCBA.html",
							"GUID-C8718125-6D8E-466C-A17B-8DF5DEC4DCBA.html",
							"GUID-33272D9A-46EB-4956-877E-4AEEEACE9754.html",
							"GUID-33272D9A-46EB-4956-877E-4AEEEACE9754.html",
							"GUID-33272D9A-46EB-4956-877E-4AEEEACE9754.html",
							"GUID-33272D9A-46EB-4956-877E-4AEEEACE9754.html",
							"GUID-33272D9A-46EB-4956-877E-4AEEEACE9754.html",
							"GUID-33272D9A-46EB-4956-877E-4AEEEACE9754.html",
							"GUID-33272D9A-46EB-4956-877E-4AEEEACE9754.html",
							"GUID-33272D9A-46EB-4956-877E-4AEEEACE9754.html",
							"GUID-33272D9A-46EB-4956-877E-4AEEEACE9754.html",
							"GUID-60A80FBD-F98D-41E9-B327-6D11B3F893D7.html",
							"GUID-60A80FBD-F98D-41E9-B327-6D11B3F893D7.html",
							"GUID-60A80FBD-F98D-41E9-B327-6D11B3F893D7.html",
							"GUID-60A80FBD-F98D-41E9-B327-6D11B3F893D7.html",
							"GUID-60A80FBD-F98D-41E9-B327-6D11B3F893D7.html",
							"GUID-60A80FBD-F98D-41E9-B327-6D11B3F893D7.html",
							"GUID-60A80FBD-F98D-41E9-B327-6D11B3F893D7.html",
							"GUID-60A80FBD-F98D-41E9-B327-6D11B3F893D7.html",
							"GUID-60A80FBD-F98D-41E9-B327-6D11B3F893D7.html",
							"GUID-599D11ED-E619-435F-9863-AD6D603CAD5B.html",
							"GUID-599D11ED-E619-435F-9863-AD6D603CAD5B.html",
							"GUID-599D11ED-E619-435F-9863-AD6D603CAD5B.html",
							"GUID-599D11ED-E619-435F-9863-AD6D603CAD5B.html",
							"GUID-599D11ED-E619-435F-9863-AD6D603CAD5B.html",
							"GUID-599D11ED-E619-435F-9863-AD6D603CAD5B.html",
							"GUID-599D11ED-E619-435F-9863-AD6D603CAD5B.html",
							"GUID-599D11ED-E619-435F-9863-AD6D603CAD5B.html",
							"GUID-599D11ED-E619-435F-9863-AD6D603CAD5B.html",
							"GUID-188D4B15-E781-43B9-8C34-E28EF8C25CCB.html",
							"GUID-188D4B15-E781-43B9-8C34-E28EF8C25CCB.html",
							"GUID-188D4B15-E781-43B9-8C34-E28EF8C25CCB.html",
							"GUID-188D4B15-E781-43B9-8C34-E28EF8C25CCB.html",
							"GUID-188D4B15-E781-43B9-8C34-E28EF8C25CCB.html",
							"GUID-188D4B15-E781-43B9-8C34-E28EF8C25CCB.html",
							"GUID-188D4B15-E781-43B9-8C34-E28EF8C25CCB.html",
							"GUID-188D4B15-E781-43B9-8C34-E28EF8C25CCB.html",
							"GUID-188D4B15-E781-43B9-8C34-E28EF8C25CCB.html",
							"GUID-D590C514-65D1-4433-A1AE-0BE56EDF6E51.html",
							"GUID-D590C514-65D1-4433-A1AE-0BE56EDF6E51.html",
							"GUID-D590C514-65D1-4433-A1AE-0BE56EDF6E51.html",
							"GUID-D590C514-65D1-4433-A1AE-0BE56EDF6E51.html",
							"GUID-D590C514-65D1-4433-A1AE-0BE56EDF6E51.html",
							"GUID-D590C514-65D1-4433-A1AE-0BE56EDF6E51.html",
							"GUID-D590C514-65D1-4433-A1AE-0BE56EDF6E51.html",
							"GUID-D590C514-65D1-4433-A1AE-0BE56EDF6E51.html",
							"GUID-D590C514-65D1-4433-A1AE-0BE56EDF6E51.html",
							"GUID-FDFE5A0D-A28F-461F-836F-1AB2362E816C.html",
							"GUID-FDFE5A0D-A28F-461F-836F-1AB2362E816C.html",
							"GUID-FDFE5A0D-A28F-461F-836F-1AB2362E816C.html",
							"GUID-FDFE5A0D-A28F-461F-836F-1AB2362E816C.html",
							"GUID-FDFE5A0D-A28F-461F-836F-1AB2362E816C.html",
							"GUID-FDFE5A0D-A28F-461F-836F-1AB2362E816C.html",
							"GUID-FDFE5A0D-A28F-461F-836F-1AB2362E816C.html",
							"GUID-FDFE5A0D-A28F-461F-836F-1AB2362E816C.html",
							"GUID-FDFE5A0D-A28F-461F-836F-1AB2362E816C.html",
							"GUID-95BCA67A-3CF8-4901-A09E-D2003C14EB2E.html",
							"GUID-95BCA67A-3CF8-4901-A09E-D2003C14EB2E.html",
							"GUID-95BCA67A-3CF8-4901-A09E-D2003C14EB2E.html",
							"GUID-95BCA67A-3CF8-4901-A09E-D2003C14EB2E.html",
							"GUID-95BCA67A-3CF8-4901-A09E-D2003C14EB2E.html",
							"GUID-6A1C053B-AC44-4CB2-9C84-AC5A697F538E.html",
							"GUID-6A1C053B-AC44-4CB2-9C84-AC5A697F538E.html",
							"GUID-6A1C053B-AC44-4CB2-9C84-AC5A697F538E.html",
							"GUID-6A1C053B-AC44-4CB2-9C84-AC5A697F538E.html",
							"GUID-6A1C053B-AC44-4CB2-9C84-AC5A697F538E.html",
							"GUID-7A97D0B1-ED36-47E8-B474-A223196C311E.html",
							"GUID-7A97D0B1-ED36-47E8-B474-A223196C311E.html",
							"GUID-7A97D0B1-ED36-47E8-B474-A223196C311E.html",
							"GUID-7A97D0B1-ED36-47E8-B474-A223196C311E.html",
							"GUID-7A97D0B1-ED36-47E8-B474-A223196C311E.html",
							"GUID-013A85E2-6948-44FA-907E-7DC945B5CE82.html",
							"GUID-1E7EF838-CFDF-4322-9E2B-B5AF123EBE19.html",
							"GUID-10A54591-77AF-4FC3-9EEE-6F1C1E18DA17.html",
							"GUID-079021A9-BC3F-4BB9-8BF9-04E8459E69C3.html",
							"GUID-D15D1321-065D-4EA7-A00C-D277A8A66F8D.html",
							"GUID-9D56B23B-286F-46C8-AF68-FE5C2B1A3770.html",
							"GUID-9D56B23B-286F-46C8-AF68-FE5C2B1A3770.html",
							"GUID-9D56B23B-286F-46C8-AF68-FE5C2B1A3770.html",
							"GUID-9D56B23B-286F-46C8-AF68-FE5C2B1A3770.html",
							"GUID-9D56B23B-286F-46C8-AF68-FE5C2B1A3770.html",
							"GUID-9D56B23B-286F-46C8-AF68-FE5C2B1A3770.html",
							"GUID-9D56B23B-286F-46C8-AF68-FE5C2B1A3770.html",
							"GUID-9D56B23B-286F-46C8-AF68-FE5C2B1A3770.html",
							"GUID-9D56B23B-286F-46C8-AF68-FE5C2B1A3770.html",
							"GUID-C78B1D72-8668-4502-827D-78DE59A2C8F6.html",
							"GUID-C78B1D72-8668-4502-827D-78DE59A2C8F6.html",
							"GUID-C78B1D72-8668-4502-827D-78DE59A2C8F6.html",
							"GUID-C78B1D72-8668-4502-827D-78DE59A2C8F6.html",
							"GUID-C78B1D72-8668-4502-827D-78DE59A2C8F6.html",
							"GUID-C78B1D72-8668-4502-827D-78DE59A2C8F6.html",
							"GUID-C78B1D72-8668-4502-827D-78DE59A2C8F6.html",
							"GUID-C78B1D72-8668-4502-827D-78DE59A2C8F6.html",
							"GUID-C78B1D72-8668-4502-827D-78DE59A2C8F6.html",
							"GUID-270CFE41-7A8D-4C82-BE72-BDF750BD0962.html",
							"GUID-270CFE41-7A8D-4C82-BE72-BDF750BD0962.html",
							"GUID-270CFE41-7A8D-4C82-BE72-BDF750BD0962.html",
							"GUID-270CFE41-7A8D-4C82-BE72-BDF750BD0962.html",
							"GUID-270CFE41-7A8D-4C82-BE72-BDF750BD0962.html",
							"GUID-270CFE41-7A8D-4C82-BE72-BDF750BD0962.html",
							"GUID-270CFE41-7A8D-4C82-BE72-BDF750BD0962.html",
							"GUID-270CFE41-7A8D-4C82-BE72-BDF750BD0962.html",
							"GUID-270CFE41-7A8D-4C82-BE72-BDF750BD0962.html",
							"GUID-C5F288D2-FAAA-425F-8BED-9D9A5A81474C.html",
							"GUID-C5F288D2-FAAA-425F-8BED-9D9A5A81474C.html",
							"GUID-C5F288D2-FAAA-425F-8BED-9D9A5A81474C.html",
							"GUID-C5F288D2-FAAA-425F-8BED-9D9A5A81474C.html",
							"GUID-C5F288D2-FAAA-425F-8BED-9D9A5A81474C.html",
							"GUID-C5F288D2-FAAA-425F-8BED-9D9A5A81474C.html",
							"GUID-C5F288D2-FAAA-425F-8BED-9D9A5A81474C.html",
							"GUID-C5F288D2-FAAA-425F-8BED-9D9A5A81474C.html",
							"GUID-C5F288D2-FAAA-425F-8BED-9D9A5A81474C.html",
							"GUID-866A6CB9-874F-4392-B16F-1DEC65C72720.html",
							"GUID-866A6CB9-874F-4392-B16F-1DEC65C72720.html",
							"GUID-866A6CB9-874F-4392-B16F-1DEC65C72720.html",
							"GUID-866A6CB9-874F-4392-B16F-1DEC65C72720.html",
							"GUID-866A6CB9-874F-4392-B16F-1DEC65C72720.html",
							"GUID-866A6CB9-874F-4392-B16F-1DEC65C72720.html",
							"GUID-866A6CB9-874F-4392-B16F-1DEC65C72720.html",
							"GUID-866A6CB9-874F-4392-B16F-1DEC65C72720.html",
							"GUID-866A6CB9-874F-4392-B16F-1DEC65C72720.html",
							"GUID-4EA4F1C3-1007-4B14-8C52-82D2AEE2C02C.html",
							"GUID-4EA4F1C3-1007-4B14-8C52-82D2AEE2C02C.html",
							"GUID-4EA4F1C3-1007-4B14-8C52-82D2AEE2C02C.html",
							"GUID-4EA4F1C3-1007-4B14-8C52-82D2AEE2C02C.html",
							"GUID-4EA4F1C3-1007-4B14-8C52-82D2AEE2C02C.html",
							"GUID-4EA4F1C3-1007-4B14-8C52-82D2AEE2C02C.html",
							"GUID-4EA4F1C3-1007-4B14-8C52-82D2AEE2C02C.html",
							"GUID-4EA4F1C3-1007-4B14-8C52-82D2AEE2C02C.html",
							"GUID-4EA4F1C3-1007-4B14-8C52-82D2AEE2C02C.html",
							"GUID-AA699B4B-601C-47E7-9424-2394151CDADC.html",
							"GUID-AA699B4B-601C-47E7-9424-2394151CDADC.html",
							"GUID-AA699B4B-601C-47E7-9424-2394151CDADC.html",
							"GUID-AA699B4B-601C-47E7-9424-2394151CDADC.html",
							"GUID-AA699B4B-601C-47E7-9424-2394151CDADC.html",
							"GUID-AA699B4B-601C-47E7-9424-2394151CDADC.html",
							"GUID-AA699B4B-601C-47E7-9424-2394151CDADC.html",
							"GUID-AA699B4B-601C-47E7-9424-2394151CDADC.html",
							"GUID-AA699B4B-601C-47E7-9424-2394151CDADC.html",
							"GUID-334EFC50-4493-4BB9-868E-C45946AC5666.html",
							"GUID-334EFC50-4493-4BB9-868E-C45946AC5666.html",
							"GUID-334EFC50-4493-4BB9-868E-C45946AC5666.html",
							"GUID-334EFC50-4493-4BB9-868E-C45946AC5666.html",
							"GUID-334EFC50-4493-4BB9-868E-C45946AC5666.html",
							"GUID-334EFC50-4493-4BB9-868E-C45946AC5666.html",
							"GUID-334EFC50-4493-4BB9-868E-C45946AC5666.html",
							"GUID-334EFC50-4493-4BB9-868E-C45946AC5666.html",
							"GUID-334EFC50-4493-4BB9-868E-C45946AC5666.html",
							"GUID-184BEB58-3960-409F-9875-790B476A679D.html",
							"GUID-184BEB58-3960-409F-9875-790B476A679D.html",
							"GUID-184BEB58-3960-409F-9875-790B476A679D.html",
							"GUID-184BEB58-3960-409F-9875-790B476A679D.html",
							"GUID-184BEB58-3960-409F-9875-790B476A679D.html",
							"GUID-184BEB58-3960-409F-9875-790B476A679D.html",
							"GUID-184BEB58-3960-409F-9875-790B476A679D.html",
							"GUID-184BEB58-3960-409F-9875-790B476A679D.html",
							"GUID-184BEB58-3960-409F-9875-790B476A679D.html",
							"GUID-6CE613A7-B427-4DC2-A744-EF8C8D72D1C8.html",
							"GUID-6CE613A7-B427-4DC2-A744-EF8C8D72D1C8.html",
							"GUID-6CE613A7-B427-4DC2-A744-EF8C8D72D1C8.html",
							"GUID-6CE613A7-B427-4DC2-A744-EF8C8D72D1C8.html",
							"GUID-6CE613A7-B427-4DC2-A744-EF8C8D72D1C8.html",
							"GUID-6CE613A7-B427-4DC2-A744-EF8C8D72D1C8.html",
							"GUID-6CE613A7-B427-4DC2-A744-EF8C8D72D1C8.html",
							"GUID-6CE613A7-B427-4DC2-A744-EF8C8D72D1C8.html",
							"GUID-6CE613A7-B427-4DC2-A744-EF8C8D72D1C8.html",
							"GUID-1A162AB8-8001-4AF9-AFB9-B66AED10D4AE.html",
							"GUID-1A162AB8-8001-4AF9-AFB9-B66AED10D4AE.html",
							"GUID-1A162AB8-8001-4AF9-AFB9-B66AED10D4AE.html",
							"GUID-1A162AB8-8001-4AF9-AFB9-B66AED10D4AE.html",
							"GUID-1A162AB8-8001-4AF9-AFB9-B66AED10D4AE.html",
							"GUID-1A162AB8-8001-4AF9-AFB9-B66AED10D4AE.html",
							"GUID-1A162AB8-8001-4AF9-AFB9-B66AED10D4AE.html",
							"GUID-1A162AB8-8001-4AF9-AFB9-B66AED10D4AE.html",
							"GUID-1A162AB8-8001-4AF9-AFB9-B66AED10D4AE.html",
							"GUID-05D542C0-88AB-429B-8C82-574332D86DB3.html",
							"GUID-05D542C0-88AB-429B-8C82-574332D86DB3.html",
							"GUID-05D542C0-88AB-429B-8C82-574332D86DB3.html",
							"GUID-05D542C0-88AB-429B-8C82-574332D86DB3.html",
							"GUID-05D542C0-88AB-429B-8C82-574332D86DB3.html",
							"GUID-05D542C0-88AB-429B-8C82-574332D86DB3.html",
							"GUID-05D542C0-88AB-429B-8C82-574332D86DB3.html",
							"GUID-05D542C0-88AB-429B-8C82-574332D86DB3.html",
							"GUID-05D542C0-88AB-429B-8C82-574332D86DB3.html",
							"GUID-C4DCEBA3-EE0D-436C-B72F-D93475C26968.html",
							"GUID-C4DCEBA3-EE0D-436C-B72F-D93475C26968.html",
							"GUID-C4DCEBA3-EE0D-436C-B72F-D93475C26968.html",
							"GUID-C4DCEBA3-EE0D-436C-B72F-D93475C26968.html",
							"GUID-C4DCEBA3-EE0D-436C-B72F-D93475C26968.html",
							"GUID-FF110E8F-BB9F-45E9-AB13-7F19C7D3DD20.html",
							"GUID-FF110E8F-BB9F-45E9-AB13-7F19C7D3DD20.html",
							"GUID-FF110E8F-BB9F-45E9-AB13-7F19C7D3DD20.html",
							"GUID-FF110E8F-BB9F-45E9-AB13-7F19C7D3DD20.html",
							"GUID-FF110E8F-BB9F-45E9-AB13-7F19C7D3DD20.html",
							"GUID-C371060E-60A1-40CC-AE70-B27AE8C15B32.html",
							"GUID-C371060E-60A1-40CC-AE70-B27AE8C15B32.html",
							"GUID-C371060E-60A1-40CC-AE70-B27AE8C15B32.html",
							"GUID-C371060E-60A1-40CC-AE70-B27AE8C15B32.html",
							"GUID-C371060E-60A1-40CC-AE70-B27AE8C15B32.html",
							"GUID-9B9CC3A1-8B69-41C7-AA41-838DFFF0EE1E.html",
							"GUID-9B9CC3A1-8B69-41C7-AA41-838DFFF0EE1E.html",
							"GUID-9B9CC3A1-8B69-41C7-AA41-838DFFF0EE1E.html",
							"GUID-9B9CC3A1-8B69-41C7-AA41-838DFFF0EE1E.html",
							"GUID-9B9CC3A1-8B69-41C7-AA41-838DFFF0EE1E.html",
							"GUID-A6CEDD40-C9C6-4F17-AF36-3CA35E2F09F3.html",
							"GUID-A6CEDD40-C9C6-4F17-AF36-3CA35E2F09F3.html",
							"GUID-A6CEDD40-C9C6-4F17-AF36-3CA35E2F09F3.html",
							"GUID-A6CEDD40-C9C6-4F17-AF36-3CA35E2F09F3.html",
							"GUID-A6CEDD40-C9C6-4F17-AF36-3CA35E2F09F3.html",
							"GUID-A6CEDD40-C9C6-4F17-AF36-3CA35E2F09F3.html",
							"GUID-A6CEDD40-C9C6-4F17-AF36-3CA35E2F09F3.html",
							"GUID-A6CEDD40-C9C6-4F17-AF36-3CA35E2F09F3.html",
							"GUID-89A8332D-B4D0-4989-8602-EACDE3EE74AC.html",
							"GUID-824D74D6-8B88-479A-8E92-981DECBE8204.html",
							"GUID-FF457C0B-00B0-4727-AC3E-2B9A6F5B62EE.html",
							"GUID-BB7E4A95-11F5-4B68-AB77-983B571454FF.html",
							"GUID-7A1B4F41-7CC6-49CF-941E-25265059D247.html",
							"GUID-3045AE88-9A21-4BE2-B1D3-3BD2832A31CF.html",
							"GUID-3045AE88-9A21-4BE2-B1D3-3BD2832A31CF.html",
							"GUID-3045AE88-9A21-4BE2-B1D3-3BD2832A31CF.html",
							"GUID-3045AE88-9A21-4BE2-B1D3-3BD2832A31CF.html",
							"GUID-3045AE88-9A21-4BE2-B1D3-3BD2832A31CF.html",
							"GUID-3045AE88-9A21-4BE2-B1D3-3BD2832A31CF.html",
							"GUID-3045AE88-9A21-4BE2-B1D3-3BD2832A31CF.html",
							"GUID-3045AE88-9A21-4BE2-B1D3-3BD2832A31CF.html",
							"GUID-3045AE88-9A21-4BE2-B1D3-3BD2832A31CF.html",
							"GUID-FDE6412C-17D7-4AF5-B4A6-FD8E0FA2CCDD.html",
							"GUID-FDE6412C-17D7-4AF5-B4A6-FD8E0FA2CCDD.html",
							"GUID-FDE6412C-17D7-4AF5-B4A6-FD8E0FA2CCDD.html",
							"GUID-FDE6412C-17D7-4AF5-B4A6-FD8E0FA2CCDD.html",
							"GUID-FDE6412C-17D7-4AF5-B4A6-FD8E0FA2CCDD.html",
							"GUID-FDE6412C-17D7-4AF5-B4A6-FD8E0FA2CCDD.html",
							"GUID-FDE6412C-17D7-4AF5-B4A6-FD8E0FA2CCDD.html",
							"GUID-FDE6412C-17D7-4AF5-B4A6-FD8E0FA2CCDD.html",
							"GUID-FDE6412C-17D7-4AF5-B4A6-FD8E0FA2CCDD.html",
							"GUID-ABCA7342-A189-40BE-81B4-8F7AFB54DBB7.html",
							"GUID-ABCA7342-A189-40BE-81B4-8F7AFB54DBB7.html",
							"GUID-ABCA7342-A189-40BE-81B4-8F7AFB54DBB7.html",
							"GUID-ABCA7342-A189-40BE-81B4-8F7AFB54DBB7.html",
							"GUID-ABCA7342-A189-40BE-81B4-8F7AFB54DBB7.html",
							"GUID-ABCA7342-A189-40BE-81B4-8F7AFB54DBB7.html",
							"GUID-ABCA7342-A189-40BE-81B4-8F7AFB54DBB7.html",
							"GUID-ABCA7342-A189-40BE-81B4-8F7AFB54DBB7.html",
							"GUID-ABCA7342-A189-40BE-81B4-8F7AFB54DBB7.html",
							"GUID-7BF4B98B-08BD-4EF8-804E-E98FBBB58962.html",
							"GUID-7BF4B98B-08BD-4EF8-804E-E98FBBB58962.html",
							"GUID-7BF4B98B-08BD-4EF8-804E-E98FBBB58962.html",
							"GUID-7BF4B98B-08BD-4EF8-804E-E98FBBB58962.html",
							"GUID-7BF4B98B-08BD-4EF8-804E-E98FBBB58962.html",
							"GUID-7BF4B98B-08BD-4EF8-804E-E98FBBB58962.html",
							"GUID-7BF4B98B-08BD-4EF8-804E-E98FBBB58962.html",
							"GUID-7BF4B98B-08BD-4EF8-804E-E98FBBB58962.html",
							"GUID-7BF4B98B-08BD-4EF8-804E-E98FBBB58962.html",
							"GUID-C31A72D0-6E22-4F3B-BA96-8B71473F16FE.html",
							"GUID-C31A72D0-6E22-4F3B-BA96-8B71473F16FE.html",
							"GUID-C31A72D0-6E22-4F3B-BA96-8B71473F16FE.html",
							"GUID-C31A72D0-6E22-4F3B-BA96-8B71473F16FE.html",
							"GUID-C31A72D0-6E22-4F3B-BA96-8B71473F16FE.html",
							"GUID-C31A72D0-6E22-4F3B-BA96-8B71473F16FE.html",
							"GUID-C31A72D0-6E22-4F3B-BA96-8B71473F16FE.html",
							"GUID-C31A72D0-6E22-4F3B-BA96-8B71473F16FE.html",
							"GUID-C31A72D0-6E22-4F3B-BA96-8B71473F16FE.html",
							"GUID-9431E4B8-75C5-4EDD-92AB-E408501BE694.html",
							"GUID-9431E4B8-75C5-4EDD-92AB-E408501BE694.html",
							"GUID-9431E4B8-75C5-4EDD-92AB-E408501BE694.html",
							"GUID-9431E4B8-75C5-4EDD-92AB-E408501BE694.html",
							"GUID-9431E4B8-75C5-4EDD-92AB-E408501BE694.html",
							"GUID-9431E4B8-75C5-4EDD-92AB-E408501BE694.html",
							"GUID-9431E4B8-75C5-4EDD-92AB-E408501BE694.html",
							"GUID-9431E4B8-75C5-4EDD-92AB-E408501BE694.html",
							"GUID-9431E4B8-75C5-4EDD-92AB-E408501BE694.html",
							"GUID-DD0C5C28-401A-4FD6-9BA8-1EDD0812FE8C.html",
							"GUID-DD0C5C28-401A-4FD6-9BA8-1EDD0812FE8C.html",
							"GUID-DD0C5C28-401A-4FD6-9BA8-1EDD0812FE8C.html",
							"GUID-DD0C5C28-401A-4FD6-9BA8-1EDD0812FE8C.html",
							"GUID-DD0C5C28-401A-4FD6-9BA8-1EDD0812FE8C.html",
							"GUID-DD0C5C28-401A-4FD6-9BA8-1EDD0812FE8C.html",
							"GUID-DD0C5C28-401A-4FD6-9BA8-1EDD0812FE8C.html",
							"GUID-DD0C5C28-401A-4FD6-9BA8-1EDD0812FE8C.html",
							"GUID-DD0C5C28-401A-4FD6-9BA8-1EDD0812FE8C.html",
							"GUID-EE2EE0D7-5780-4446-95C7-B11743E46F36.html",
							"GUID-EE2EE0D7-5780-4446-95C7-B11743E46F36.html",
							"GUID-EE2EE0D7-5780-4446-95C7-B11743E46F36.html",
							"GUID-EE2EE0D7-5780-4446-95C7-B11743E46F36.html",
							"GUID-EE2EE0D7-5780-4446-95C7-B11743E46F36.html",
							"GUID-EE2EE0D7-5780-4446-95C7-B11743E46F36.html",
							"GUID-EE2EE0D7-5780-4446-95C7-B11743E46F36.html",
							"GUID-EE2EE0D7-5780-4446-95C7-B11743E46F36.html",
							"GUID-EE2EE0D7-5780-4446-95C7-B11743E46F36.html",
							"GUID-3051F828-5F5D-4349-B949-CF78BADC3D9B.html",
							"GUID-3051F828-5F5D-4349-B949-CF78BADC3D9B.html",
							"GUID-3051F828-5F5D-4349-B949-CF78BADC3D9B.html",
							"GUID-3051F828-5F5D-4349-B949-CF78BADC3D9B.html",
							"GUID-3051F828-5F5D-4349-B949-CF78BADC3D9B.html",
							"GUID-3051F828-5F5D-4349-B949-CF78BADC3D9B.html",
							"GUID-3051F828-5F5D-4349-B949-CF78BADC3D9B.html",
							"GUID-3051F828-5F5D-4349-B949-CF78BADC3D9B.html",
							"GUID-3051F828-5F5D-4349-B949-CF78BADC3D9B.html",
							"GUID-D11F782D-EA66-4244-8C49-B870CB8A8954.html",
							"GUID-D11F782D-EA66-4244-8C49-B870CB8A8954.html",
							"GUID-D11F782D-EA66-4244-8C49-B870CB8A8954.html",
							"GUID-D11F782D-EA66-4244-8C49-B870CB8A8954.html",
							"GUID-D11F782D-EA66-4244-8C49-B870CB8A8954.html",
							"GUID-D11F782D-EA66-4244-8C49-B870CB8A8954.html",
							"GUID-D11F782D-EA66-4244-8C49-B870CB8A8954.html",
							"GUID-D11F782D-EA66-4244-8C49-B870CB8A8954.html",
							"GUID-D11F782D-EA66-4244-8C49-B870CB8A8954.html",
							"GUID-CF9D8C02-CDCC-4109-98A9-596F8B97FA6E.html",
							"GUID-CF9D8C02-CDCC-4109-98A9-596F8B97FA6E.html",
							"GUID-CF9D8C02-CDCC-4109-98A9-596F8B97FA6E.html",
							"GUID-CF9D8C02-CDCC-4109-98A9-596F8B97FA6E.html",
							"GUID-CF9D8C02-CDCC-4109-98A9-596F8B97FA6E.html",
							"GUID-CF9D8C02-CDCC-4109-98A9-596F8B97FA6E.html",
							"GUID-CF9D8C02-CDCC-4109-98A9-596F8B97FA6E.html",
							"GUID-CF9D8C02-CDCC-4109-98A9-596F8B97FA6E.html",
							"GUID-CF9D8C02-CDCC-4109-98A9-596F8B97FA6E.html",
							"GUID-73CFC4AE-26EC-41F4-9A2A-A541704C1312.html",
							"GUID-73CFC4AE-26EC-41F4-9A2A-A541704C1312.html",
							"GUID-73CFC4AE-26EC-41F4-9A2A-A541704C1312.html",
							"GUID-73CFC4AE-26EC-41F4-9A2A-A541704C1312.html",
							"GUID-73CFC4AE-26EC-41F4-9A2A-A541704C1312.html",
							"GUID-73CFC4AE-26EC-41F4-9A2A-A541704C1312.html",
							"GUID-73CFC4AE-26EC-41F4-9A2A-A541704C1312.html",
							"GUID-73CFC4AE-26EC-41F4-9A2A-A541704C1312.html",
							"GUID-73CFC4AE-26EC-41F4-9A2A-A541704C1312.html",
							"GUID-3D91A8FB-8652-4510-B84B-28C44F4BE7B9.html",
							"GUID-3D91A8FB-8652-4510-B84B-28C44F4BE7B9.html",
							"GUID-3D91A8FB-8652-4510-B84B-28C44F4BE7B9.html",
							"GUID-3D91A8FB-8652-4510-B84B-28C44F4BE7B9.html",
							"GUID-3D91A8FB-8652-4510-B84B-28C44F4BE7B9.html",
							"GUID-3D91A8FB-8652-4510-B84B-28C44F4BE7B9.html",
							"GUID-3D91A8FB-8652-4510-B84B-28C44F4BE7B9.html",
							"GUID-3D91A8FB-8652-4510-B84B-28C44F4BE7B9.html",
							"GUID-3D91A8FB-8652-4510-B84B-28C44F4BE7B9.html",
							"GUID-7A650304-68A4-4AF2-A839-E0C386199636.html",
							"GUID-7A650304-68A4-4AF2-A839-E0C386199636.html",
							"GUID-7A650304-68A4-4AF2-A839-E0C386199636.html",
							"GUID-7A650304-68A4-4AF2-A839-E0C386199636.html",
							"GUID-7A650304-68A4-4AF2-A839-E0C386199636.html",
							"GUID-7A650304-68A4-4AF2-A839-E0C386199636.html",
							"GUID-7A650304-68A4-4AF2-A839-E0C386199636.html",
							"GUID-7A650304-68A4-4AF2-A839-E0C386199636.html",
							"GUID-7A650304-68A4-4AF2-A839-E0C386199636.html",
							"GUID-2A607243-AAFB-446B-B743-F33F83344DD0.html",
							"GUID-2A607243-AAFB-446B-B743-F33F83344DD0.html",
							"GUID-2A607243-AAFB-446B-B743-F33F83344DD0.html",
							"GUID-2A607243-AAFB-446B-B743-F33F83344DD0.html",
							"GUID-2A607243-AAFB-446B-B743-F33F83344DD0.html",
							"GUID-2A607243-AAFB-446B-B743-F33F83344DD0.html",
							"GUID-2A607243-AAFB-446B-B743-F33F83344DD0.html",
							"GUID-2A607243-AAFB-446B-B743-F33F83344DD0.html",
							"GUID-2A607243-AAFB-446B-B743-F33F83344DD0.html",
							"GUID-F28E022E-CE8C-4121-A9DD-6599C9EC4F8D.html",
							"GUID-F28E022E-CE8C-4121-A9DD-6599C9EC4F8D.html",
							"GUID-F28E022E-CE8C-4121-A9DD-6599C9EC4F8D.html",
							"GUID-F28E022E-CE8C-4121-A9DD-6599C9EC4F8D.html",
							"GUID-F28E022E-CE8C-4121-A9DD-6599C9EC4F8D.html",
							"GUID-F28E022E-CE8C-4121-A9DD-6599C9EC4F8D.html",
							"GUID-F28E022E-CE8C-4121-A9DD-6599C9EC4F8D.html",
							"GUID-F28E022E-CE8C-4121-A9DD-6599C9EC4F8D.html",
							"GUID-F28E022E-CE8C-4121-A9DD-6599C9EC4F8D.html",
							"GUID-56EFD842-90D6-4F89-A21C-7085F873C4D7.html",
							"GUID-56EFD842-90D6-4F89-A21C-7085F873C4D7.html",
							"GUID-56EFD842-90D6-4F89-A21C-7085F873C4D7.html",
							"GUID-56EFD842-90D6-4F89-A21C-7085F873C4D7.html",
							"GUID-56EFD842-90D6-4F89-A21C-7085F873C4D7.html",
							"GUID-16CA62B0-B63E-4BF8-B2D2-82960FB3B4D4.html",
							"GUID-16CA62B0-B63E-4BF8-B2D2-82960FB3B4D4.html",
							"GUID-16CA62B0-B63E-4BF8-B2D2-82960FB3B4D4.html",
							"GUID-16CA62B0-B63E-4BF8-B2D2-82960FB3B4D4.html",
							"GUID-16CA62B0-B63E-4BF8-B2D2-82960FB3B4D4.html",
							"GUID-2BD06221-FD9C-403C-B3E2-CBAAF7A4F445.html",
							"GUID-2BD06221-FD9C-403C-B3E2-CBAAF7A4F445.html",
							"GUID-2BD06221-FD9C-403C-B3E2-CBAAF7A4F445.html",
							"GUID-2BD06221-FD9C-403C-B3E2-CBAAF7A4F445.html",
							"GUID-2BD06221-FD9C-403C-B3E2-CBAAF7A4F445.html",
							"GUID-2CD6DE9A-6F65-4E4E-A370-6F4227534CE1.html",
							"GUID-2CD6DE9A-6F65-4E4E-A370-6F4227534CE1.html",
							"GUID-2CD6DE9A-6F65-4E4E-A370-6F4227534CE1.html",
							"GUID-2CD6DE9A-6F65-4E4E-A370-6F4227534CE1.html",
							"GUID-2CD6DE9A-6F65-4E4E-A370-6F4227534CE1.html",
							"GUID-2CD6DE9A-6F65-4E4E-A370-6F4227534CE1.html",
							"GUID-5AF7D1CF-A561-4B79-96A1-2E37C455D70C.html",
							"GUID-5AF7D1CF-A561-4B79-96A1-2E37C455D70C.html",
							"GUID-5AF7D1CF-A561-4B79-96A1-2E37C455D70C.html",
							"GUID-5AF7D1CF-A561-4B79-96A1-2E37C455D70C.html",
							"GUID-5AF7D1CF-A561-4B79-96A1-2E37C455D70C.html",
							"GUID-5AF7D1CF-A561-4B79-96A1-2E37C455D70C.html",
							"GUID-5AF7D1CF-A561-4B79-96A1-2E37C455D70C.html",
							"GUID-5AF7D1CF-A561-4B79-96A1-2E37C455D70C.html",
							"GUID-B2925496-394D-47ED-BD1E-1AB2149934FA.html",
							"GUID-5BFF0AFD-E1B5-43FE-AB0F-1786AE731A44.html",
							"GUID-03194F57-0DB7-4821-A8AA-CE37A033C333.html",
							"GUID-9B2ED9D8-3DFB-4FA7-BAA7-228E011BA99B.html",
							"GUID-2960D7B8-65FA-447F-AD81-B1E62002A04B.html",
							"GUID-156F2C8E-1429-4D4E-A212-B9248988F48E.html",
							"GUID-156F2C8E-1429-4D4E-A212-B9248988F48E.html",
							"GUID-156F2C8E-1429-4D4E-A212-B9248988F48E.html",
							"GUID-156F2C8E-1429-4D4E-A212-B9248988F48E.html",
							"GUID-156F2C8E-1429-4D4E-A212-B9248988F48E.html",
							"GUID-156F2C8E-1429-4D4E-A212-B9248988F48E.html",
							"GUID-156F2C8E-1429-4D4E-A212-B9248988F48E.html",
							"GUID-156F2C8E-1429-4D4E-A212-B9248988F48E.html",
							"GUID-156F2C8E-1429-4D4E-A212-B9248988F48E.html",
							"GUID-65CDE798-3D26-42EF-A56C-C6759587D8CA.html",
							"GUID-65CDE798-3D26-42EF-A56C-C6759587D8CA.html",
							"GUID-65CDE798-3D26-42EF-A56C-C6759587D8CA.html",
							"GUID-65CDE798-3D26-42EF-A56C-C6759587D8CA.html",
							"GUID-65CDE798-3D26-42EF-A56C-C6759587D8CA.html",
							"GUID-65CDE798-3D26-42EF-A56C-C6759587D8CA.html",
							"GUID-65CDE798-3D26-42EF-A56C-C6759587D8CA.html",
							"GUID-65CDE798-3D26-42EF-A56C-C6759587D8CA.html",
							"GUID-65CDE798-3D26-42EF-A56C-C6759587D8CA.html",
							"GUID-5450365C-5439-468F-BC38-F1DFB6A9CD19.html",
							"GUID-5450365C-5439-468F-BC38-F1DFB6A9CD19.html",
							"GUID-5450365C-5439-468F-BC38-F1DFB6A9CD19.html",
							"GUID-5450365C-5439-468F-BC38-F1DFB6A9CD19.html",
							"GUID-5450365C-5439-468F-BC38-F1DFB6A9CD19.html",
							"GUID-5450365C-5439-468F-BC38-F1DFB6A9CD19.html",
							"GUID-5450365C-5439-468F-BC38-F1DFB6A9CD19.html",
							"GUID-5450365C-5439-468F-BC38-F1DFB6A9CD19.html",
							"GUID-5450365C-5439-468F-BC38-F1DFB6A9CD19.html",
							"GUID-C2260882-60A1-4B82-8500-CF9284CEA0AF.html",
							"GUID-C2260882-60A1-4B82-8500-CF9284CEA0AF.html",
							"GUID-C2260882-60A1-4B82-8500-CF9284CEA0AF.html",
							"GUID-C2260882-60A1-4B82-8500-CF9284CEA0AF.html",
							"GUID-C2260882-60A1-4B82-8500-CF9284CEA0AF.html",
							"GUID-C2260882-60A1-4B82-8500-CF9284CEA0AF.html",
							"GUID-C2260882-60A1-4B82-8500-CF9284CEA0AF.html",
							"GUID-C2260882-60A1-4B82-8500-CF9284CEA0AF.html",
							"GUID-C2260882-60A1-4B82-8500-CF9284CEA0AF.html",
							"GUID-B2CFEC5B-C6BE-43F7-B525-B6CBB46600BA.html",
							"GUID-B2CFEC5B-C6BE-43F7-B525-B6CBB46600BA.html",
							"GUID-B2CFEC5B-C6BE-43F7-B525-B6CBB46600BA.html",
							"GUID-B2CFEC5B-C6BE-43F7-B525-B6CBB46600BA.html",
							"GUID-B2CFEC5B-C6BE-43F7-B525-B6CBB46600BA.html",
							"GUID-B2CFEC5B-C6BE-43F7-B525-B6CBB46600BA.html",
							"GUID-B2CFEC5B-C6BE-43F7-B525-B6CBB46600BA.html",
							"GUID-B2CFEC5B-C6BE-43F7-B525-B6CBB46600BA.html",
							"GUID-B2CFEC5B-C6BE-43F7-B525-B6CBB46600BA.html",
							"GUID-B592E4B0-C24A-4BD0-8EA2-D97A7391DB8E.html",
							"GUID-B592E4B0-C24A-4BD0-8EA2-D97A7391DB8E.html",
							"GUID-B592E4B0-C24A-4BD0-8EA2-D97A7391DB8E.html",
							"GUID-B592E4B0-C24A-4BD0-8EA2-D97A7391DB8E.html",
							"GUID-B592E4B0-C24A-4BD0-8EA2-D97A7391DB8E.html",
							"GUID-B592E4B0-C24A-4BD0-8EA2-D97A7391DB8E.html",
							"GUID-B592E4B0-C24A-4BD0-8EA2-D97A7391DB8E.html",
							"GUID-B592E4B0-C24A-4BD0-8EA2-D97A7391DB8E.html",
							"GUID-B592E4B0-C24A-4BD0-8EA2-D97A7391DB8E.html",
							"GUID-28F55864-F969-436B-BFD3-93463186F072.html",
							"GUID-28F55864-F969-436B-BFD3-93463186F072.html",
							"GUID-28F55864-F969-436B-BFD3-93463186F072.html",
							"GUID-28F55864-F969-436B-BFD3-93463186F072.html",
							"GUID-28F55864-F969-436B-BFD3-93463186F072.html",
							"GUID-28F55864-F969-436B-BFD3-93463186F072.html",
							"GUID-28F55864-F969-436B-BFD3-93463186F072.html",
							"GUID-28F55864-F969-436B-BFD3-93463186F072.html",
							"GUID-28F55864-F969-436B-BFD3-93463186F072.html",
							"GUID-40D584E2-0A2B-45E9-B3D7-92BA4A138871.html",
							"GUID-40D584E2-0A2B-45E9-B3D7-92BA4A138871.html",
							"GUID-40D584E2-0A2B-45E9-B3D7-92BA4A138871.html",
							"GUID-40D584E2-0A2B-45E9-B3D7-92BA4A138871.html",
							"GUID-40D584E2-0A2B-45E9-B3D7-92BA4A138871.html",
							"GUID-40D584E2-0A2B-45E9-B3D7-92BA4A138871.html",
							"GUID-40D584E2-0A2B-45E9-B3D7-92BA4A138871.html",
							"GUID-40D584E2-0A2B-45E9-B3D7-92BA4A138871.html",
							"GUID-40D584E2-0A2B-45E9-B3D7-92BA4A138871.html",
							"GUID-35C5FE76-A326-410C-8189-A9F87D976CC8.html",
							"GUID-35C5FE76-A326-410C-8189-A9F87D976CC8.html",
							"GUID-35C5FE76-A326-410C-8189-A9F87D976CC8.html",
							"GUID-35C5FE76-A326-410C-8189-A9F87D976CC8.html",
							"GUID-35C5FE76-A326-410C-8189-A9F87D976CC8.html",
							"GUID-35C5FE76-A326-410C-8189-A9F87D976CC8.html",
							"GUID-35C5FE76-A326-410C-8189-A9F87D976CC8.html",
							"GUID-35C5FE76-A326-410C-8189-A9F87D976CC8.html",
							"GUID-35C5FE76-A326-410C-8189-A9F87D976CC8.html",
							"GUID-3B71F472-0CB2-433D-BD5E-39C5E2F065F6.html",
							"GUID-3B71F472-0CB2-433D-BD5E-39C5E2F065F6.html",
							"GUID-3B71F472-0CB2-433D-BD5E-39C5E2F065F6.html",
							"GUID-3B71F472-0CB2-433D-BD5E-39C5E2F065F6.html",
							"GUID-3B71F472-0CB2-433D-BD5E-39C5E2F065F6.html",
							"GUID-3B71F472-0CB2-433D-BD5E-39C5E2F065F6.html",
							"GUID-3B71F472-0CB2-433D-BD5E-39C5E2F065F6.html",
							"GUID-3B71F472-0CB2-433D-BD5E-39C5E2F065F6.html",
							"GUID-3B71F472-0CB2-433D-BD5E-39C5E2F065F6.html",
							"GUID-C171E575-0A6B-4403-BBE1-4B593649E038.html",
							"GUID-C171E575-0A6B-4403-BBE1-4B593649E038.html",
							"GUID-C171E575-0A6B-4403-BBE1-4B593649E038.html",
							"GUID-C171E575-0A6B-4403-BBE1-4B593649E038.html",
							"GUID-C171E575-0A6B-4403-BBE1-4B593649E038.html",
							"GUID-C171E575-0A6B-4403-BBE1-4B593649E038.html",
							"GUID-C171E575-0A6B-4403-BBE1-4B593649E038.html",
							"GUID-C171E575-0A6B-4403-BBE1-4B593649E038.html",
							"GUID-C171E575-0A6B-4403-BBE1-4B593649E038.html",
							"GUID-4DF8B0C7-1447-4A6E-BF63-7A01ECCE498E.html",
							"GUID-4DF8B0C7-1447-4A6E-BF63-7A01ECCE498E.html",
							"GUID-4DF8B0C7-1447-4A6E-BF63-7A01ECCE498E.html",
							"GUID-4DF8B0C7-1447-4A6E-BF63-7A01ECCE498E.html",
							"GUID-4DF8B0C7-1447-4A6E-BF63-7A01ECCE498E.html",
							"GUID-4DF8B0C7-1447-4A6E-BF63-7A01ECCE498E.html",
							"GUID-4DF8B0C7-1447-4A6E-BF63-7A01ECCE498E.html",
							"GUID-4DF8B0C7-1447-4A6E-BF63-7A01ECCE498E.html",
							"GUID-4DF8B0C7-1447-4A6E-BF63-7A01ECCE498E.html",
							"GUID-6B0132A8-8996-4B69-A2E7-28EA0712B624.html",
							"GUID-6B0132A8-8996-4B69-A2E7-28EA0712B624.html",
							"GUID-6B0132A8-8996-4B69-A2E7-28EA0712B624.html",
							"GUID-6B0132A8-8996-4B69-A2E7-28EA0712B624.html",
							"GUID-6B0132A8-8996-4B69-A2E7-28EA0712B624.html",
							"GUID-6B0132A8-8996-4B69-A2E7-28EA0712B624.html",
							"GUID-6B0132A8-8996-4B69-A2E7-28EA0712B624.html",
							"GUID-6B0132A8-8996-4B69-A2E7-28EA0712B624.html",
							"GUID-6B0132A8-8996-4B69-A2E7-28EA0712B624.html",
							"GUID-13559EF2-4A66-45EE-A200-6C2A80BA30B9.html",
							"GUID-13559EF2-4A66-45EE-A200-6C2A80BA30B9.html",
							"GUID-13559EF2-4A66-45EE-A200-6C2A80BA30B9.html",
							"GUID-13559EF2-4A66-45EE-A200-6C2A80BA30B9.html",
							"GUID-13559EF2-4A66-45EE-A200-6C2A80BA30B9.html",
							"GUID-13559EF2-4A66-45EE-A200-6C2A80BA30B9.html",
							"GUID-13559EF2-4A66-45EE-A200-6C2A80BA30B9.html",
							"GUID-13559EF2-4A66-45EE-A200-6C2A80BA30B9.html",
							"GUID-13559EF2-4A66-45EE-A200-6C2A80BA30B9.html",
							"GUID-2028B78C-A652-404B-ACF0-963F1622CB67.html",
							"GUID-2028B78C-A652-404B-ACF0-963F1622CB67.html",
							"GUID-2028B78C-A652-404B-ACF0-963F1622CB67.html",
							"GUID-2028B78C-A652-404B-ACF0-963F1622CB67.html",
							"GUID-2028B78C-A652-404B-ACF0-963F1622CB67.html",
							"GUID-E4F5279A-ECF6-4330-B801-8FEDF3AD373D.html",
							"GUID-E4F5279A-ECF6-4330-B801-8FEDF3AD373D.html",
							"GUID-E4F5279A-ECF6-4330-B801-8FEDF3AD373D.html",
							"GUID-E4F5279A-ECF6-4330-B801-8FEDF3AD373D.html",
							"GUID-E4F5279A-ECF6-4330-B801-8FEDF3AD373D.html",
							"GUID-3C6053B3-EFE9-4B28-844C-92FF7C41D48C.html",
							"GUID-3C6053B3-EFE9-4B28-844C-92FF7C41D48C.html",
							"GUID-3C6053B3-EFE9-4B28-844C-92FF7C41D48C.html",
							"GUID-3C6053B3-EFE9-4B28-844C-92FF7C41D48C.html",
							"GUID-3C6053B3-EFE9-4B28-844C-92FF7C41D48C.html",
							"GUID-5230216C-08DD-4C01-BDF6-F914852BF1C7.html",
							"GUID-5230216C-08DD-4C01-BDF6-F914852BF1C7.html",
							"GUID-5230216C-08DD-4C01-BDF6-F914852BF1C7.html",
							"GUID-5230216C-08DD-4C01-BDF6-F914852BF1C7.html",
							"GUID-5230216C-08DD-4C01-BDF6-F914852BF1C7.html",
							"GUID-5230216C-08DD-4C01-BDF6-F914852BF1C7.html",
							"GUID-5230216C-08DD-4C01-BDF6-F914852BF1C7.html",
							"GUID-5230216C-08DD-4C01-BDF6-F914852BF1C7.html",
							"GUID-D4256706-715F-48F4-9870-30C2A2F834E7.html",
							"GUID-D4256706-715F-48F4-9870-30C2A2F834E7.html",
							"GUID-D4256706-715F-48F4-9870-30C2A2F834E7.html",
							"GUID-D4256706-715F-48F4-9870-30C2A2F834E7.html",
							"GUID-D4256706-715F-48F4-9870-30C2A2F834E7.html",
							"GUID-E4466627-D222-4C75-949F-360F4DF69FAB.html",
							"GUID-E4466627-D222-4C75-949F-360F4DF69FAB.html",
							"GUID-E4466627-D222-4C75-949F-360F4DF69FAB.html",
							"GUID-E4466627-D222-4C75-949F-360F4DF69FAB.html",
							"GUID-E4466627-D222-4C75-949F-360F4DF69FAB.html",
							"GUID-30394233-2FAC-4A34-80F4-9FCF29158508.html",
							"GUID-30394233-2FAC-4A34-80F4-9FCF29158508.html",
							"GUID-30394233-2FAC-4A34-80F4-9FCF29158508.html",
							"GUID-30394233-2FAC-4A34-80F4-9FCF29158508.html",
							"GUID-30394233-2FAC-4A34-80F4-9FCF29158508.html",
							"GUID-E79EE776-77FB-4E0D-B49A-EA524C6CF1B6.html",
							"GUID-E79EE776-77FB-4E0D-B49A-EA524C6CF1B6.html",
							"GUID-E79EE776-77FB-4E0D-B49A-EA524C6CF1B6.html",
							"GUID-E79EE776-77FB-4E0D-B49A-EA524C6CF1B6.html",
							"GUID-E79EE776-77FB-4E0D-B49A-EA524C6CF1B6.html",
							"GUID-E79EE776-77FB-4E0D-B49A-EA524C6CF1B6.html",
							"GUID-E79EE776-77FB-4E0D-B49A-EA524C6CF1B6.html",
							"GUID-E79EE776-77FB-4E0D-B49A-EA524C6CF1B6.html",
							"GUID-3DC66955-0F7E-4747-9790-893CA81987A6.html",
							"GUID-3801A70C-6DBD-42D0-9B59-A612CCBDE59E.html",
							"GUID-4605973A-5C41-42CE-9E62-DD8AFA902969.html",
							"GUID-EAC52160-4BCB-47FB-B079-291174FC1B48.html",
							"GUID-80FC4C27-64D2-411F-BE4A-4C4A8BD80604.html",
							"GUID-91E325DB-2320-47FF-B5A6-5ABD322CB8BC.html",
							"GUID-91E325DB-2320-47FF-B5A6-5ABD322CB8BC.html",
							"GUID-91E325DB-2320-47FF-B5A6-5ABD322CB8BC.html",
							"GUID-91E325DB-2320-47FF-B5A6-5ABD322CB8BC.html",
							"GUID-91E325DB-2320-47FF-B5A6-5ABD322CB8BC.html",
							"GUID-91E325DB-2320-47FF-B5A6-5ABD322CB8BC.html",
							"GUID-91E325DB-2320-47FF-B5A6-5ABD322CB8BC.html",
							"GUID-91E325DB-2320-47FF-B5A6-5ABD322CB8BC.html",
							"GUID-91E325DB-2320-47FF-B5A6-5ABD322CB8BC.html",
							"GUID-7733BE76-6885-410D-8F50-8E771FEC8BF2.html",
							"GUID-7733BE76-6885-410D-8F50-8E771FEC8BF2.html",
							"GUID-7733BE76-6885-410D-8F50-8E771FEC8BF2.html",
							"GUID-7733BE76-6885-410D-8F50-8E771FEC8BF2.html",
							"GUID-7733BE76-6885-410D-8F50-8E771FEC8BF2.html",
							"GUID-7733BE76-6885-410D-8F50-8E771FEC8BF2.html",
							"GUID-7733BE76-6885-410D-8F50-8E771FEC8BF2.html",
							"GUID-7733BE76-6885-410D-8F50-8E771FEC8BF2.html",
							"GUID-7733BE76-6885-410D-8F50-8E771FEC8BF2.html",
							"GUID-D75AEB40-83E2-4649-B704-AE0FABABA920.html",
							"GUID-D75AEB40-83E2-4649-B704-AE0FABABA920.html",
							"GUID-D75AEB40-83E2-4649-B704-AE0FABABA920.html",
							"GUID-D75AEB40-83E2-4649-B704-AE0FABABA920.html",
							"GUID-D75AEB40-83E2-4649-B704-AE0FABABA920.html",
							"GUID-D75AEB40-83E2-4649-B704-AE0FABABA920.html",
							"GUID-D75AEB40-83E2-4649-B704-AE0FABABA920.html",
							"GUID-D75AEB40-83E2-4649-B704-AE0FABABA920.html",
							"GUID-D75AEB40-83E2-4649-B704-AE0FABABA920.html",
							"GUID-8F48061B-62C0-48D8-9FC6-35BCF04E2CF4.html",
							"GUID-8F48061B-62C0-48D8-9FC6-35BCF04E2CF4.html",
							"GUID-8F48061B-62C0-48D8-9FC6-35BCF04E2CF4.html",
							"GUID-8F48061B-62C0-48D8-9FC6-35BCF04E2CF4.html",
							"GUID-8F48061B-62C0-48D8-9FC6-35BCF04E2CF4.html",
							"GUID-8F48061B-62C0-48D8-9FC6-35BCF04E2CF4.html",
							"GUID-8F48061B-62C0-48D8-9FC6-35BCF04E2CF4.html",
							"GUID-8F48061B-62C0-48D8-9FC6-35BCF04E2CF4.html",
							"GUID-8F48061B-62C0-48D8-9FC6-35BCF04E2CF4.html",
							"GUID-A118DA5A-D2B3-4D22-8A52-4C23FE1DB218.html",
							"GUID-A118DA5A-D2B3-4D22-8A52-4C23FE1DB218.html",
							"GUID-A118DA5A-D2B3-4D22-8A52-4C23FE1DB218.html",
							"GUID-A118DA5A-D2B3-4D22-8A52-4C23FE1DB218.html",
							"GUID-A118DA5A-D2B3-4D22-8A52-4C23FE1DB218.html",
							"GUID-A118DA5A-D2B3-4D22-8A52-4C23FE1DB218.html",
							"GUID-A118DA5A-D2B3-4D22-8A52-4C23FE1DB218.html",
							"GUID-A118DA5A-D2B3-4D22-8A52-4C23FE1DB218.html",
							"GUID-A118DA5A-D2B3-4D22-8A52-4C23FE1DB218.html",
							"GUID-26C6A14A-2B42-456C-9E8A-06DF30F2DE21.html",
							"GUID-26C6A14A-2B42-456C-9E8A-06DF30F2DE21.html",
							"GUID-26C6A14A-2B42-456C-9E8A-06DF30F2DE21.html",
							"GUID-26C6A14A-2B42-456C-9E8A-06DF30F2DE21.html",
							"GUID-26C6A14A-2B42-456C-9E8A-06DF30F2DE21.html",
							"GUID-26C6A14A-2B42-456C-9E8A-06DF30F2DE21.html",
							"GUID-26C6A14A-2B42-456C-9E8A-06DF30F2DE21.html",
							"GUID-26C6A14A-2B42-456C-9E8A-06DF30F2DE21.html",
							"GUID-26C6A14A-2B42-456C-9E8A-06DF30F2DE21.html",
							"GUID-0E0F508F-835A-47CF-B94C-6965642EDAFF.html",
							"GUID-0E0F508F-835A-47CF-B94C-6965642EDAFF.html",
							"GUID-0E0F508F-835A-47CF-B94C-6965642EDAFF.html",
							"GUID-0E0F508F-835A-47CF-B94C-6965642EDAFF.html",
							"GUID-0E0F508F-835A-47CF-B94C-6965642EDAFF.html",
							"GUID-0E0F508F-835A-47CF-B94C-6965642EDAFF.html",
							"GUID-0E0F508F-835A-47CF-B94C-6965642EDAFF.html",
							"GUID-0E0F508F-835A-47CF-B94C-6965642EDAFF.html",
							"GUID-0E0F508F-835A-47CF-B94C-6965642EDAFF.html",
							"GUID-DBD152A0-8CC4-47B1-ACFC-AFCC60233376.html",
							"GUID-DBD152A0-8CC4-47B1-ACFC-AFCC60233376.html",
							"GUID-DBD152A0-8CC4-47B1-ACFC-AFCC60233376.html",
							"GUID-DBD152A0-8CC4-47B1-ACFC-AFCC60233376.html",
							"GUID-DBD152A0-8CC4-47B1-ACFC-AFCC60233376.html",
							"GUID-DBD152A0-8CC4-47B1-ACFC-AFCC60233376.html",
							"GUID-DBD152A0-8CC4-47B1-ACFC-AFCC60233376.html",
							"GUID-DBD152A0-8CC4-47B1-ACFC-AFCC60233376.html",
							"GUID-DBD152A0-8CC4-47B1-ACFC-AFCC60233376.html",
							"GUID-4D75630E-7B1C-4A75-B6CF-BAA0923F0460.html",
							"GUID-4D75630E-7B1C-4A75-B6CF-BAA0923F0460.html",
							"GUID-4D75630E-7B1C-4A75-B6CF-BAA0923F0460.html",
							"GUID-4D75630E-7B1C-4A75-B6CF-BAA0923F0460.html",
							"GUID-4D75630E-7B1C-4A75-B6CF-BAA0923F0460.html",
							"GUID-4D75630E-7B1C-4A75-B6CF-BAA0923F0460.html",
							"GUID-4D75630E-7B1C-4A75-B6CF-BAA0923F0460.html",
							"GUID-4D75630E-7B1C-4A75-B6CF-BAA0923F0460.html",
							"GUID-4D75630E-7B1C-4A75-B6CF-BAA0923F0460.html",
							"GUID-BBDB3D4A-93BB-45C2-9C58-C725BF0799F2.html",
							"GUID-BBDB3D4A-93BB-45C2-9C58-C725BF0799F2.html",
							"GUID-BBDB3D4A-93BB-45C2-9C58-C725BF0799F2.html",
							"GUID-BBDB3D4A-93BB-45C2-9C58-C725BF0799F2.html",
							"GUID-BBDB3D4A-93BB-45C2-9C58-C725BF0799F2.html",
							"GUID-BBDB3D4A-93BB-45C2-9C58-C725BF0799F2.html",
							"GUID-BBDB3D4A-93BB-45C2-9C58-C725BF0799F2.html",
							"GUID-BBDB3D4A-93BB-45C2-9C58-C725BF0799F2.html",
							"GUID-BBDB3D4A-93BB-45C2-9C58-C725BF0799F2.html",
							"GUID-987AC199-226F-49A3-AED1-CA0EE34D5328.html",
							"GUID-987AC199-226F-49A3-AED1-CA0EE34D5328.html",
							"GUID-987AC199-226F-49A3-AED1-CA0EE34D5328.html",
							"GUID-987AC199-226F-49A3-AED1-CA0EE34D5328.html",
							"GUID-987AC199-226F-49A3-AED1-CA0EE34D5328.html",
							"GUID-987AC199-226F-49A3-AED1-CA0EE34D5328.html",
							"GUID-987AC199-226F-49A3-AED1-CA0EE34D5328.html",
							"GUID-987AC199-226F-49A3-AED1-CA0EE34D5328.html",
							"GUID-987AC199-226F-49A3-AED1-CA0EE34D5328.html",
							"GUID-8CBE201E-43FE-4A88-8AB5-8379140F5A40.html",
							"GUID-8CBE201E-43FE-4A88-8AB5-8379140F5A40.html",
							"GUID-8CBE201E-43FE-4A88-8AB5-8379140F5A40.html",
							"GUID-8CBE201E-43FE-4A88-8AB5-8379140F5A40.html",
							"GUID-8CBE201E-43FE-4A88-8AB5-8379140F5A40.html",
							"GUID-8CBE201E-43FE-4A88-8AB5-8379140F5A40.html",
							"GUID-8CBE201E-43FE-4A88-8AB5-8379140F5A40.html",
							"GUID-8CBE201E-43FE-4A88-8AB5-8379140F5A40.html",
							"GUID-8CBE201E-43FE-4A88-8AB5-8379140F5A40.html",
							"GUID-3607AD2F-9343-496E-A447-CEA81CDA32DD.html",
							"GUID-3607AD2F-9343-496E-A447-CEA81CDA32DD.html",
							"GUID-3607AD2F-9343-496E-A447-CEA81CDA32DD.html",
							"GUID-3607AD2F-9343-496E-A447-CEA81CDA32DD.html",
							"GUID-3607AD2F-9343-496E-A447-CEA81CDA32DD.html",
							"GUID-3607AD2F-9343-496E-A447-CEA81CDA32DD.html",
							"GUID-3607AD2F-9343-496E-A447-CEA81CDA32DD.html",
							"GUID-3607AD2F-9343-496E-A447-CEA81CDA32DD.html",
							"GUID-3607AD2F-9343-496E-A447-CEA81CDA32DD.html",
							"GUID-8E9FFDEF-B064-46E0-A2B8-DFA88E8F1C00.html",
							"GUID-8E9FFDEF-B064-46E0-A2B8-DFA88E8F1C00.html",
							"GUID-8E9FFDEF-B064-46E0-A2B8-DFA88E8F1C00.html",
							"GUID-8E9FFDEF-B064-46E0-A2B8-DFA88E8F1C00.html",
							"GUID-8E9FFDEF-B064-46E0-A2B8-DFA88E8F1C00.html",
							"GUID-8E9FFDEF-B064-46E0-A2B8-DFA88E8F1C00.html",
							"GUID-8E9FFDEF-B064-46E0-A2B8-DFA88E8F1C00.html",
							"GUID-8E9FFDEF-B064-46E0-A2B8-DFA88E8F1C00.html",
							"GUID-8E9FFDEF-B064-46E0-A2B8-DFA88E8F1C00.html",
							"GUID-1E139F9C-7F58-4B46-A04D-6FE5BBA261B7.html",
							"GUID-1E139F9C-7F58-4B46-A04D-6FE5BBA261B7.html",
							"GUID-1E139F9C-7F58-4B46-A04D-6FE5BBA261B7.html",
							"GUID-1E139F9C-7F58-4B46-A04D-6FE5BBA261B7.html",
							"GUID-1E139F9C-7F58-4B46-A04D-6FE5BBA261B7.html",
							"GUID-1E139F9C-7F58-4B46-A04D-6FE5BBA261B7.html",
							"GUID-1E139F9C-7F58-4B46-A04D-6FE5BBA261B7.html",
							"GUID-1E139F9C-7F58-4B46-A04D-6FE5BBA261B7.html",
							"GUID-1E139F9C-7F58-4B46-A04D-6FE5BBA261B7.html",
							"GUID-889F54F6-7A1A-45D7-95FF-3E7AFAE137BA.html",
							"GUID-889F54F6-7A1A-45D7-95FF-3E7AFAE137BA.html",
							"GUID-889F54F6-7A1A-45D7-95FF-3E7AFAE137BA.html",
							"GUID-889F54F6-7A1A-45D7-95FF-3E7AFAE137BA.html",
							"GUID-889F54F6-7A1A-45D7-95FF-3E7AFAE137BA.html",
							"GUID-889F54F6-7A1A-45D7-95FF-3E7AFAE137BA.html",
							"GUID-889F54F6-7A1A-45D7-95FF-3E7AFAE137BA.html",
							"GUID-889F54F6-7A1A-45D7-95FF-3E7AFAE137BA.html",
							"GUID-889F54F6-7A1A-45D7-95FF-3E7AFAE137BA.html",
							"GUID-E9965026-96F1-4634-9193-8863D21C1B8F.html",
							"GUID-E9965026-96F1-4634-9193-8863D21C1B8F.html",
							"GUID-E9965026-96F1-4634-9193-8863D21C1B8F.html",
							"GUID-E9965026-96F1-4634-9193-8863D21C1B8F.html",
							"GUID-E9965026-96F1-4634-9193-8863D21C1B8F.html",
							"GUID-C64CA1F5-4C6A-4C51-A7A4-BF9836636D5C.html",
							"GUID-C64CA1F5-4C6A-4C51-A7A4-BF9836636D5C.html",
							"GUID-C64CA1F5-4C6A-4C51-A7A4-BF9836636D5C.html",
							"GUID-C64CA1F5-4C6A-4C51-A7A4-BF9836636D5C.html",
							"GUID-C64CA1F5-4C6A-4C51-A7A4-BF9836636D5C.html",
							"GUID-C6F5D125-631C-4D09-BD49-2A88CF38D39E.html",
							"GUID-C6F5D125-631C-4D09-BD49-2A88CF38D39E.html",
							"GUID-C6F5D125-631C-4D09-BD49-2A88CF38D39E.html",
							"GUID-C6F5D125-631C-4D09-BD49-2A88CF38D39E.html",
							"GUID-C6F5D125-631C-4D09-BD49-2A88CF38D39E.html",
							"GUID-780154C9-7B3A-4937-A4B9-EE697C66BA7D.html",
							"GUID-780154C9-7B3A-4937-A4B9-EE697C66BA7D.html",
							"GUID-780154C9-7B3A-4937-A4B9-EE697C66BA7D.html",
							"GUID-780154C9-7B3A-4937-A4B9-EE697C66BA7D.html",
							"GUID-780154C9-7B3A-4937-A4B9-EE697C66BA7D.html",
							"GUID-780154C9-7B3A-4937-A4B9-EE697C66BA7D.html",
							"GUID-780154C9-7B3A-4937-A4B9-EE697C66BA7D.html",
							"GUID-780154C9-7B3A-4937-A4B9-EE697C66BA7D.html",
							"GUID-C45D3957-41A4-43F5-8287-8EB57F20F46F.html",
							"GUID-C45D3957-41A4-43F5-8287-8EB57F20F46F.html",
							"GUID-C45D3957-41A4-43F5-8287-8EB57F20F46F.html",
							"GUID-C45D3957-41A4-43F5-8287-8EB57F20F46F.html",
							"GUID-C45D3957-41A4-43F5-8287-8EB57F20F46F.html",
							"GUID-8E3A7168-6CEA-4CDF-9DE9-345AA82E1499.html",
							"GUID-8E3A7168-6CEA-4CDF-9DE9-345AA82E1499.html",
							"GUID-8E3A7168-6CEA-4CDF-9DE9-345AA82E1499.html",
							"GUID-8E3A7168-6CEA-4CDF-9DE9-345AA82E1499.html",
							"GUID-8E3A7168-6CEA-4CDF-9DE9-345AA82E1499.html",
							"GUID-26AE1A76-5DC9-4184-A41E-9608DC5AB589.html",
							"GUID-26AE1A76-5DC9-4184-A41E-9608DC5AB589.html",
							"GUID-26AE1A76-5DC9-4184-A41E-9608DC5AB589.html",
							"GUID-26AE1A76-5DC9-4184-A41E-9608DC5AB589.html",
							"GUID-26AE1A76-5DC9-4184-A41E-9608DC5AB589.html",
							"GUID-84AD8BE3-4D9F-4F36-AB5F-160B9B90F177.html",
							"GUID-BA1691E2-6B02-4CCD-94F8-7936A71EC069.html",
							"GUID-26A4668F-DD5C-48D2-8FBA-9419B8BB9681.html",
							"GUID-E750E768-6A15-4F9B-9C11-ED2C8D758455.html",
							"GUID-19E37632-5F52-4834-93D4-BB61F5ED1FE5.html",
							"GUID-354A36E3-7E0B-4DD0-8485-DDFD792B525C.html",
							"GUID-0CD901F4-15C6-4FA7-8805-3934D2C6C250.html",
							"GUID-0CD901F4-15C6-4FA7-8805-3934D2C6C250.html",
							"GUID-0CD901F4-15C6-4FA7-8805-3934D2C6C250.html",
							"GUID-0CD901F4-15C6-4FA7-8805-3934D2C6C250.html",
							"GUID-0CD901F4-15C6-4FA7-8805-3934D2C6C250.html",
							"GUID-0CD901F4-15C6-4FA7-8805-3934D2C6C250.html",
							"GUID-0CD901F4-15C6-4FA7-8805-3934D2C6C250.html",
							"GUID-0CD901F4-15C6-4FA7-8805-3934D2C6C250.html",
							"GUID-0CD901F4-15C6-4FA7-8805-3934D2C6C250.html",
							"GUID-C8072D14-9165-491A-9742-322455F3C27C.html",
							"GUID-C8072D14-9165-491A-9742-322455F3C27C.html",
							"GUID-C8072D14-9165-491A-9742-322455F3C27C.html",
							"GUID-C8072D14-9165-491A-9742-322455F3C27C.html",
							"GUID-C8072D14-9165-491A-9742-322455F3C27C.html",
							"GUID-C8072D14-9165-491A-9742-322455F3C27C.html",
							"GUID-C8072D14-9165-491A-9742-322455F3C27C.html",
							"GUID-C8072D14-9165-491A-9742-322455F3C27C.html",
							"GUID-C8072D14-9165-491A-9742-322455F3C27C.html",
							"GUID-F2C0E62F-7E9C-467D-8630-BD1CD1612C78.html",
							"GUID-F2C0E62F-7E9C-467D-8630-BD1CD1612C78.html",
							"GUID-F2C0E62F-7E9C-467D-8630-BD1CD1612C78.html",
							"GUID-F2C0E62F-7E9C-467D-8630-BD1CD1612C78.html",
							"GUID-F2C0E62F-7E9C-467D-8630-BD1CD1612C78.html",
							"GUID-F2C0E62F-7E9C-467D-8630-BD1CD1612C78.html",
							"GUID-F2C0E62F-7E9C-467D-8630-BD1CD1612C78.html",
							"GUID-F2C0E62F-7E9C-467D-8630-BD1CD1612C78.html",
							"GUID-F2C0E62F-7E9C-467D-8630-BD1CD1612C78.html",
							"GUID-725B8066-3554-40FF-8707-CCF041AE750D.html",
							"GUID-725B8066-3554-40FF-8707-CCF041AE750D.html",
							"GUID-725B8066-3554-40FF-8707-CCF041AE750D.html",
							"GUID-725B8066-3554-40FF-8707-CCF041AE750D.html",
							"GUID-725B8066-3554-40FF-8707-CCF041AE750D.html",
							"GUID-725B8066-3554-40FF-8707-CCF041AE750D.html",
							"GUID-725B8066-3554-40FF-8707-CCF041AE750D.html",
							"GUID-725B8066-3554-40FF-8707-CCF041AE750D.html",
							"GUID-725B8066-3554-40FF-8707-CCF041AE750D.html",
							"GUID-3FAA6B0C-C235-4068-8AC9-082528572159.html",
							"GUID-3FAA6B0C-C235-4068-8AC9-082528572159.html",
							"GUID-3FAA6B0C-C235-4068-8AC9-082528572159.html",
							"GUID-3FAA6B0C-C235-4068-8AC9-082528572159.html",
							"GUID-3FAA6B0C-C235-4068-8AC9-082528572159.html",
							"GUID-3FAA6B0C-C235-4068-8AC9-082528572159.html",
							"GUID-3FAA6B0C-C235-4068-8AC9-082528572159.html",
							"GUID-3FAA6B0C-C235-4068-8AC9-082528572159.html",
							"GUID-3FAA6B0C-C235-4068-8AC9-082528572159.html",
							"GUID-773AD55E-F0E3-4ACF-9EF1-E5BDADF3F717.html",
							"GUID-773AD55E-F0E3-4ACF-9EF1-E5BDADF3F717.html",
							"GUID-773AD55E-F0E3-4ACF-9EF1-E5BDADF3F717.html",
							"GUID-773AD55E-F0E3-4ACF-9EF1-E5BDADF3F717.html",
							"GUID-773AD55E-F0E3-4ACF-9EF1-E5BDADF3F717.html",
							"GUID-773AD55E-F0E3-4ACF-9EF1-E5BDADF3F717.html",
							"GUID-773AD55E-F0E3-4ACF-9EF1-E5BDADF3F717.html",
							"GUID-773AD55E-F0E3-4ACF-9EF1-E5BDADF3F717.html",
							"GUID-773AD55E-F0E3-4ACF-9EF1-E5BDADF3F717.html",
							"GUID-85741DCE-B74D-4437-83CA-57B624B5FF0C.html",
							"GUID-85741DCE-B74D-4437-83CA-57B624B5FF0C.html",
							"GUID-85741DCE-B74D-4437-83CA-57B624B5FF0C.html",
							"GUID-85741DCE-B74D-4437-83CA-57B624B5FF0C.html",
							"GUID-85741DCE-B74D-4437-83CA-57B624B5FF0C.html",
							"GUID-85741DCE-B74D-4437-83CA-57B624B5FF0C.html",
							"GUID-85741DCE-B74D-4437-83CA-57B624B5FF0C.html",
							"GUID-85741DCE-B74D-4437-83CA-57B624B5FF0C.html",
							"GUID-85741DCE-B74D-4437-83CA-57B624B5FF0C.html",
							"GUID-46FD911A-9659-4B46-86E4-67B7CABE6FC5.html",
							"GUID-46FD911A-9659-4B46-86E4-67B7CABE6FC5.html",
							"GUID-46FD911A-9659-4B46-86E4-67B7CABE6FC5.html",
							"GUID-46FD911A-9659-4B46-86E4-67B7CABE6FC5.html",
							"GUID-46FD911A-9659-4B46-86E4-67B7CABE6FC5.html",
							"GUID-46FD911A-9659-4B46-86E4-67B7CABE6FC5.html",
							"GUID-46FD911A-9659-4B46-86E4-67B7CABE6FC5.html",
							"GUID-46FD911A-9659-4B46-86E4-67B7CABE6FC5.html",
							"GUID-46FD911A-9659-4B46-86E4-67B7CABE6FC5.html",
							"GUID-D731134D-102A-429A-B118-D5D578AEDF2D.html",
							"GUID-D731134D-102A-429A-B118-D5D578AEDF2D.html",
							"GUID-D731134D-102A-429A-B118-D5D578AEDF2D.html",
							"GUID-D731134D-102A-429A-B118-D5D578AEDF2D.html",
							"GUID-D731134D-102A-429A-B118-D5D578AEDF2D.html",
							"GUID-D731134D-102A-429A-B118-D5D578AEDF2D.html",
							"GUID-D731134D-102A-429A-B118-D5D578AEDF2D.html",
							"GUID-D731134D-102A-429A-B118-D5D578AEDF2D.html",
							"GUID-D731134D-102A-429A-B118-D5D578AEDF2D.html",
							"GUID-332FFD9B-7D05-463A-95C2-A6D12026790A.html",
							"GUID-332FFD9B-7D05-463A-95C2-A6D12026790A.html",
							"GUID-332FFD9B-7D05-463A-95C2-A6D12026790A.html",
							"GUID-332FFD9B-7D05-463A-95C2-A6D12026790A.html",
							"GUID-332FFD9B-7D05-463A-95C2-A6D12026790A.html",
							"GUID-332FFD9B-7D05-463A-95C2-A6D12026790A.html",
							"GUID-332FFD9B-7D05-463A-95C2-A6D12026790A.html",
							"GUID-332FFD9B-7D05-463A-95C2-A6D12026790A.html",
							"GUID-332FFD9B-7D05-463A-95C2-A6D12026790A.html",
							"GUID-EDA9A289-D4F9-4DD5-A12C-37D0B9FAEDB3.html",
							"GUID-EDA9A289-D4F9-4DD5-A12C-37D0B9FAEDB3.html",
							"GUID-EDA9A289-D4F9-4DD5-A12C-37D0B9FAEDB3.html",
							"GUID-EDA9A289-D4F9-4DD5-A12C-37D0B9FAEDB3.html",
							"GUID-EDA9A289-D4F9-4DD5-A12C-37D0B9FAEDB3.html",
							"GUID-84BB608D-F6D3-4470-B973-E6994D51F15D.html",
							"GUID-84BB608D-F6D3-4470-B973-E6994D51F15D.html",
							"GUID-84BB608D-F6D3-4470-B973-E6994D51F15D.html",
							"GUID-84BB608D-F6D3-4470-B973-E6994D51F15D.html",
							"GUID-84BB608D-F6D3-4470-B973-E6994D51F15D.html",
							"GUID-DDCADB94-22A8-4DE1-9089-322E15134590.html",
							"GUID-DDCADB94-22A8-4DE1-9089-322E15134590.html",
							"GUID-DDCADB94-22A8-4DE1-9089-322E15134590.html",
							"GUID-DDCADB94-22A8-4DE1-9089-322E15134590.html",
							"GUID-DDCADB94-22A8-4DE1-9089-322E15134590.html",
							"GUID-DDCADB94-22A8-4DE1-9089-322E15134590.html",
							"GUID-DDCADB94-22A8-4DE1-9089-322E15134590.html",
							"GUID-DDCADB94-22A8-4DE1-9089-322E15134590.html",
							"GUID-E5D1E930-88E3-47F4-9ECD-EDE02BF9B07D.html",
							"GUID-78C407C0-91E3-468C-9D3A-F01AF5A9CCB9.html",
							"GUID-CF08AF4F-D730-496F-A968-50434978EBE7.html",
							"GUID-B41F23CB-0677-425E-8B1F-545E056AF24D.html",
							"GUID-1B89EE19-DD90-4347-9D86-6B91B89FD073.html",
							"GUID-FC2766BD-E5AF-4007-BA9A-D1E179E8AF51.html",
							"GUID-09CD262E-94FF-4332-B87D-B39C2EB24755.html",
							"GUID-09CD262E-94FF-4332-B87D-B39C2EB24755.html",
							"GUID-09CD262E-94FF-4332-B87D-B39C2EB24755.html",
							"GUID-09CD262E-94FF-4332-B87D-B39C2EB24755.html",
							"GUID-09CD262E-94FF-4332-B87D-B39C2EB24755.html",
							"GUID-09CD262E-94FF-4332-B87D-B39C2EB24755.html",
							"GUID-09CD262E-94FF-4332-B87D-B39C2EB24755.html",
							"GUID-09CD262E-94FF-4332-B87D-B39C2EB24755.html",
							"GUID-09CD262E-94FF-4332-B87D-B39C2EB24755.html",
							"GUID-DCC39687-E45F-46D1-B489-0AFC1262B40B.html",
							"GUID-DCC39687-E45F-46D1-B489-0AFC1262B40B.html",
							"GUID-DCC39687-E45F-46D1-B489-0AFC1262B40B.html",
							"GUID-DCC39687-E45F-46D1-B489-0AFC1262B40B.html",
							"GUID-DCC39687-E45F-46D1-B489-0AFC1262B40B.html",
							"GUID-DCC39687-E45F-46D1-B489-0AFC1262B40B.html",
							"GUID-DCC39687-E45F-46D1-B489-0AFC1262B40B.html",
							"GUID-DCC39687-E45F-46D1-B489-0AFC1262B40B.html",
							"GUID-DCC39687-E45F-46D1-B489-0AFC1262B40B.html",
							"GUID-12F1A1E3-E31A-45D6-9D59-6CEF9F0B1684.html",
							"GUID-12F1A1E3-E31A-45D6-9D59-6CEF9F0B1684.html",
							"GUID-12F1A1E3-E31A-45D6-9D59-6CEF9F0B1684.html",
							"GUID-12F1A1E3-E31A-45D6-9D59-6CEF9F0B1684.html",
							"GUID-12F1A1E3-E31A-45D6-9D59-6CEF9F0B1684.html",
							"GUID-12F1A1E3-E31A-45D6-9D59-6CEF9F0B1684.html",
							"GUID-12F1A1E3-E31A-45D6-9D59-6CEF9F0B1684.html",
							"GUID-12F1A1E3-E31A-45D6-9D59-6CEF9F0B1684.html",
							"GUID-12F1A1E3-E31A-45D6-9D59-6CEF9F0B1684.html",
							"GUID-68C15981-33D0-4B83-9016-A7F1A10940AB.html",
							"GUID-68C15981-33D0-4B83-9016-A7F1A10940AB.html",
							"GUID-68C15981-33D0-4B83-9016-A7F1A10940AB.html",
							"GUID-68C15981-33D0-4B83-9016-A7F1A10940AB.html",
							"GUID-68C15981-33D0-4B83-9016-A7F1A10940AB.html",
							"GUID-68C15981-33D0-4B83-9016-A7F1A10940AB.html",
							"GUID-68C15981-33D0-4B83-9016-A7F1A10940AB.html",
							"GUID-68C15981-33D0-4B83-9016-A7F1A10940AB.html",
							"GUID-68C15981-33D0-4B83-9016-A7F1A10940AB.html",
							"GUID-3D691B46-43E2-44A8-8FDF-855290108FAC.html",
							"GUID-3D691B46-43E2-44A8-8FDF-855290108FAC.html",
							"GUID-3D691B46-43E2-44A8-8FDF-855290108FAC.html",
							"GUID-3D691B46-43E2-44A8-8FDF-855290108FAC.html",
							"GUID-3D691B46-43E2-44A8-8FDF-855290108FAC.html",
							"GUID-3D691B46-43E2-44A8-8FDF-855290108FAC.html",
							"GUID-3D691B46-43E2-44A8-8FDF-855290108FAC.html",
							"GUID-3D691B46-43E2-44A8-8FDF-855290108FAC.html",
							"GUID-3D691B46-43E2-44A8-8FDF-855290108FAC.html",
							"GUID-6666B157-1614-4C2E-8B25-F23A183D36E0.html",
							"GUID-6666B157-1614-4C2E-8B25-F23A183D36E0.html",
							"GUID-6666B157-1614-4C2E-8B25-F23A183D36E0.html",
							"GUID-6666B157-1614-4C2E-8B25-F23A183D36E0.html",
							"GUID-6666B157-1614-4C2E-8B25-F23A183D36E0.html",
							"GUID-6666B157-1614-4C2E-8B25-F23A183D36E0.html",
							"GUID-6666B157-1614-4C2E-8B25-F23A183D36E0.html",
							"GUID-6666B157-1614-4C2E-8B25-F23A183D36E0.html",
							"GUID-6666B157-1614-4C2E-8B25-F23A183D36E0.html",
							"GUID-DECFF1FB-9C12-4E95-8C07-6244681BB99A.html",
							"GUID-DECFF1FB-9C12-4E95-8C07-6244681BB99A.html",
							"GUID-DECFF1FB-9C12-4E95-8C07-6244681BB99A.html",
							"GUID-DECFF1FB-9C12-4E95-8C07-6244681BB99A.html",
							"GUID-DECFF1FB-9C12-4E95-8C07-6244681BB99A.html",
							"GUID-DECFF1FB-9C12-4E95-8C07-6244681BB99A.html",
							"GUID-DECFF1FB-9C12-4E95-8C07-6244681BB99A.html",
							"GUID-DECFF1FB-9C12-4E95-8C07-6244681BB99A.html",
							"GUID-DECFF1FB-9C12-4E95-8C07-6244681BB99A.html",
							"GUID-AAF0F727-6A9B-4935-AF27-0921A436A210.html",
							"GUID-AAF0F727-6A9B-4935-AF27-0921A436A210.html",
							"GUID-AAF0F727-6A9B-4935-AF27-0921A436A210.html",
							"GUID-AAF0F727-6A9B-4935-AF27-0921A436A210.html",
							"GUID-AAF0F727-6A9B-4935-AF27-0921A436A210.html",
							"GUID-AAF0F727-6A9B-4935-AF27-0921A436A210.html",
							"GUID-AAF0F727-6A9B-4935-AF27-0921A436A210.html",
							"GUID-AAF0F727-6A9B-4935-AF27-0921A436A210.html",
							"GUID-AAF0F727-6A9B-4935-AF27-0921A436A210.html",
							"GUID-94CD1F4B-606F-483B-985B-58EE4E5C6A27.html",
							"GUID-94CD1F4B-606F-483B-985B-58EE4E5C6A27.html",
							"GUID-94CD1F4B-606F-483B-985B-58EE4E5C6A27.html",
							"GUID-94CD1F4B-606F-483B-985B-58EE4E5C6A27.html",
							"GUID-94CD1F4B-606F-483B-985B-58EE4E5C6A27.html",
							"GUID-94CD1F4B-606F-483B-985B-58EE4E5C6A27.html",
							"GUID-94CD1F4B-606F-483B-985B-58EE4E5C6A27.html",
							"GUID-94CD1F4B-606F-483B-985B-58EE4E5C6A27.html",
							"GUID-94CD1F4B-606F-483B-985B-58EE4E5C6A27.html",
							"GUID-0DEAE4F8-7490-4EC9-9B9E-91B684AE3B07.html",
							"GUID-0DEAE4F8-7490-4EC9-9B9E-91B684AE3B07.html",
							"GUID-0DEAE4F8-7490-4EC9-9B9E-91B684AE3B07.html",
							"GUID-0DEAE4F8-7490-4EC9-9B9E-91B684AE3B07.html",
							"GUID-0DEAE4F8-7490-4EC9-9B9E-91B684AE3B07.html",
							"GUID-0DEAE4F8-7490-4EC9-9B9E-91B684AE3B07.html",
							"GUID-0DEAE4F8-7490-4EC9-9B9E-91B684AE3B07.html",
							"GUID-0DEAE4F8-7490-4EC9-9B9E-91B684AE3B07.html",
							"GUID-0DEAE4F8-7490-4EC9-9B9E-91B684AE3B07.html",
							"GUID-310793D7-0A33-4671-A43E-209D3061FADA.html",
							"GUID-310793D7-0A33-4671-A43E-209D3061FADA.html",
							"GUID-310793D7-0A33-4671-A43E-209D3061FADA.html",
							"GUID-310793D7-0A33-4671-A43E-209D3061FADA.html",
							"GUID-310793D7-0A33-4671-A43E-209D3061FADA.html",
							"GUID-413DE7BF-9304-4F7F-BBA8-CCC29E41A668.html",
							"GUID-413DE7BF-9304-4F7F-BBA8-CCC29E41A668.html",
							"GUID-413DE7BF-9304-4F7F-BBA8-CCC29E41A668.html",
							"GUID-413DE7BF-9304-4F7F-BBA8-CCC29E41A668.html",
							"GUID-413DE7BF-9304-4F7F-BBA8-CCC29E41A668.html",
							"GUID-436E9B1F-FE7C-4BBB-99D3-161DBFE1CF93.html",
							"GUID-436E9B1F-FE7C-4BBB-99D3-161DBFE1CF93.html",
							"GUID-436E9B1F-FE7C-4BBB-99D3-161DBFE1CF93.html",
							"GUID-436E9B1F-FE7C-4BBB-99D3-161DBFE1CF93.html",
							"GUID-436E9B1F-FE7C-4BBB-99D3-161DBFE1CF93.html",
							"GUID-436E9B1F-FE7C-4BBB-99D3-161DBFE1CF93.html",
							"GUID-436E9B1F-FE7C-4BBB-99D3-161DBFE1CF93.html",
							"GUID-436E9B1F-FE7C-4BBB-99D3-161DBFE1CF93.html",
							"GUID-3B80B7B5-A8B5-436E-9135-38CDEA3A638B.html",
							"GUID-474B546B-7629-40E2-AF5A-F6A6146CE8DE.html",
							"GUID-04AD35B0-FC85-416B-83D0-7C75D9D54CB8.html",
							"GUID-17A43A77-34A9-4F51-8985-256BB15EC8AC.html",
							"GUID-FD837655-18B3-4251-9DC4-93A822639B35.html",
							"GUID-6D9FA3F1-00EF-4C4D-AC06-CF95F5137ACB.html",
							"GUID-0F92AB40-ECB3-45CB-9BFD-D633997B307A.html",
							"GUID-0F92AB40-ECB3-45CB-9BFD-D633997B307A.html",
							"GUID-0F92AB40-ECB3-45CB-9BFD-D633997B307A.html",
							"GUID-0F92AB40-ECB3-45CB-9BFD-D633997B307A.html",
							"GUID-0F92AB40-ECB3-45CB-9BFD-D633997B307A.html",
							"GUID-0F92AB40-ECB3-45CB-9BFD-D633997B307A.html",
							"GUID-0F92AB40-ECB3-45CB-9BFD-D633997B307A.html",
							"GUID-0F92AB40-ECB3-45CB-9BFD-D633997B307A.html",
							"GUID-0F92AB40-ECB3-45CB-9BFD-D633997B307A.html",
							"GUID-BAAA2F94-E63D-4BFF-9C13-DFE7C8689DF6.html",
							"GUID-BAAA2F94-E63D-4BFF-9C13-DFE7C8689DF6.html",
							"GUID-BAAA2F94-E63D-4BFF-9C13-DFE7C8689DF6.html",
							"GUID-BAAA2F94-E63D-4BFF-9C13-DFE7C8689DF6.html",
							"GUID-BAAA2F94-E63D-4BFF-9C13-DFE7C8689DF6.html",
							"GUID-BAAA2F94-E63D-4BFF-9C13-DFE7C8689DF6.html",
							"GUID-BAAA2F94-E63D-4BFF-9C13-DFE7C8689DF6.html",
							"GUID-BAAA2F94-E63D-4BFF-9C13-DFE7C8689DF6.html",
							"GUID-BAAA2F94-E63D-4BFF-9C13-DFE7C8689DF6.html",
							"GUID-800334F1-1A78-4C3E-BB99-649A323AB083.html",
							"GUID-800334F1-1A78-4C3E-BB99-649A323AB083.html",
							"GUID-800334F1-1A78-4C3E-BB99-649A323AB083.html",
							"GUID-800334F1-1A78-4C3E-BB99-649A323AB083.html",
							"GUID-800334F1-1A78-4C3E-BB99-649A323AB083.html",
							"GUID-800334F1-1A78-4C3E-BB99-649A323AB083.html",
							"GUID-800334F1-1A78-4C3E-BB99-649A323AB083.html",
							"GUID-800334F1-1A78-4C3E-BB99-649A323AB083.html",
							"GUID-800334F1-1A78-4C3E-BB99-649A323AB083.html",
							"GUID-CDE5A5C3-D8BA-43BB-9287-A1087E688C15.html",
							"GUID-CDE5A5C3-D8BA-43BB-9287-A1087E688C15.html",
							"GUID-CDE5A5C3-D8BA-43BB-9287-A1087E688C15.html",
							"GUID-CDE5A5C3-D8BA-43BB-9287-A1087E688C15.html",
							"GUID-CDE5A5C3-D8BA-43BB-9287-A1087E688C15.html",
							"GUID-CDE5A5C3-D8BA-43BB-9287-A1087E688C15.html",
							"GUID-CDE5A5C3-D8BA-43BB-9287-A1087E688C15.html",
							"GUID-CDE5A5C3-D8BA-43BB-9287-A1087E688C15.html",
							"GUID-CDE5A5C3-D8BA-43BB-9287-A1087E688C15.html",
							"GUID-143402B1-D8C1-4503-B7C3-0D6DF2FAB253.html",
							"GUID-143402B1-D8C1-4503-B7C3-0D6DF2FAB253.html",
							"GUID-143402B1-D8C1-4503-B7C3-0D6DF2FAB253.html",
							"GUID-143402B1-D8C1-4503-B7C3-0D6DF2FAB253.html",
							"GUID-143402B1-D8C1-4503-B7C3-0D6DF2FAB253.html",
							"GUID-143402B1-D8C1-4503-B7C3-0D6DF2FAB253.html",
							"GUID-143402B1-D8C1-4503-B7C3-0D6DF2FAB253.html",
							"GUID-143402B1-D8C1-4503-B7C3-0D6DF2FAB253.html",
							"GUID-143402B1-D8C1-4503-B7C3-0D6DF2FAB253.html",
							"GUID-F19C5010-4548-446A-80C6-3642EA7ABA79.html",
							"GUID-F19C5010-4548-446A-80C6-3642EA7ABA79.html",
							"GUID-F19C5010-4548-446A-80C6-3642EA7ABA79.html",
							"GUID-F19C5010-4548-446A-80C6-3642EA7ABA79.html",
							"GUID-F19C5010-4548-446A-80C6-3642EA7ABA79.html",
							"GUID-F19C5010-4548-446A-80C6-3642EA7ABA79.html",
							"GUID-F19C5010-4548-446A-80C6-3642EA7ABA79.html",
							"GUID-F19C5010-4548-446A-80C6-3642EA7ABA79.html",
							"GUID-F19C5010-4548-446A-80C6-3642EA7ABA79.html",
							"GUID-B8B88178-A501-4BA9-A5BA-56BD4ECCC0AF.html",
							"GUID-B8B88178-A501-4BA9-A5BA-56BD4ECCC0AF.html",
							"GUID-B8B88178-A501-4BA9-A5BA-56BD4ECCC0AF.html",
							"GUID-B8B88178-A501-4BA9-A5BA-56BD4ECCC0AF.html",
							"GUID-B8B88178-A501-4BA9-A5BA-56BD4ECCC0AF.html",
							"GUID-B8B88178-A501-4BA9-A5BA-56BD4ECCC0AF.html",
							"GUID-B8B88178-A501-4BA9-A5BA-56BD4ECCC0AF.html",
							"GUID-B8B88178-A501-4BA9-A5BA-56BD4ECCC0AF.html",
							"GUID-B8B88178-A501-4BA9-A5BA-56BD4ECCC0AF.html",
							"GUID-2DA31F3A-13A0-4B9F-97BC-DEBDA757C12C.html",
							"GUID-2DA31F3A-13A0-4B9F-97BC-DEBDA757C12C.html",
							"GUID-2DA31F3A-13A0-4B9F-97BC-DEBDA757C12C.html",
							"GUID-2DA31F3A-13A0-4B9F-97BC-DEBDA757C12C.html",
							"GUID-2DA31F3A-13A0-4B9F-97BC-DEBDA757C12C.html",
							"GUID-2DA31F3A-13A0-4B9F-97BC-DEBDA757C12C.html",
							"GUID-2DA31F3A-13A0-4B9F-97BC-DEBDA757C12C.html",
							"GUID-2DA31F3A-13A0-4B9F-97BC-DEBDA757C12C.html",
							"GUID-2DA31F3A-13A0-4B9F-97BC-DEBDA757C12C.html",
							"GUID-81B8750A-FEF9-44BB-9CB0-27329B377E77.html",
							"GUID-81B8750A-FEF9-44BB-9CB0-27329B377E77.html",
							"GUID-81B8750A-FEF9-44BB-9CB0-27329B377E77.html",
							"GUID-81B8750A-FEF9-44BB-9CB0-27329B377E77.html",
							"GUID-81B8750A-FEF9-44BB-9CB0-27329B377E77.html",
							"GUID-81B8750A-FEF9-44BB-9CB0-27329B377E77.html",
							"GUID-81B8750A-FEF9-44BB-9CB0-27329B377E77.html",
							"GUID-81B8750A-FEF9-44BB-9CB0-27329B377E77.html",
							"GUID-81B8750A-FEF9-44BB-9CB0-27329B377E77.html",
							"GUID-7146CF6C-8560-4757-A481-2BFE6F65F08C.html",
							"GUID-7146CF6C-8560-4757-A481-2BFE6F65F08C.html",
							"GUID-7146CF6C-8560-4757-A481-2BFE6F65F08C.html",
							"GUID-7146CF6C-8560-4757-A481-2BFE6F65F08C.html",
							"GUID-7146CF6C-8560-4757-A481-2BFE6F65F08C.html",
							"GUID-7146CF6C-8560-4757-A481-2BFE6F65F08C.html",
							"GUID-7146CF6C-8560-4757-A481-2BFE6F65F08C.html",
							"GUID-7146CF6C-8560-4757-A481-2BFE6F65F08C.html",
							"GUID-7146CF6C-8560-4757-A481-2BFE6F65F08C.html",
							"GUID-084F0A8A-2149-4A06-8CCB-7AD00C30134B.html",
							"GUID-084F0A8A-2149-4A06-8CCB-7AD00C30134B.html",
							"GUID-084F0A8A-2149-4A06-8CCB-7AD00C30134B.html",
							"GUID-084F0A8A-2149-4A06-8CCB-7AD00C30134B.html",
							"GUID-084F0A8A-2149-4A06-8CCB-7AD00C30134B.html",
							"GUID-084F0A8A-2149-4A06-8CCB-7AD00C30134B.html",
							"GUID-084F0A8A-2149-4A06-8CCB-7AD00C30134B.html",
							"GUID-084F0A8A-2149-4A06-8CCB-7AD00C30134B.html",
							"GUID-084F0A8A-2149-4A06-8CCB-7AD00C30134B.html",
							"GUID-5A9D0D4F-5BBF-4CA3-89A9-1E47BDD90F01.html",
							"GUID-5A9D0D4F-5BBF-4CA3-89A9-1E47BDD90F01.html",
							"GUID-5A9D0D4F-5BBF-4CA3-89A9-1E47BDD90F01.html",
							"GUID-5A9D0D4F-5BBF-4CA3-89A9-1E47BDD90F01.html",
							"GUID-5A9D0D4F-5BBF-4CA3-89A9-1E47BDD90F01.html",
							"GUID-5A9D0D4F-5BBF-4CA3-89A9-1E47BDD90F01.html",
							"GUID-5A9D0D4F-5BBF-4CA3-89A9-1E47BDD90F01.html",
							"GUID-5A9D0D4F-5BBF-4CA3-89A9-1E47BDD90F01.html",
							"GUID-5A9D0D4F-5BBF-4CA3-89A9-1E47BDD90F01.html",
							"GUID-279921BE-6BA3-4C5A-83A3-C14760945710.html",
							"GUID-279921BE-6BA3-4C5A-83A3-C14760945710.html",
							"GUID-279921BE-6BA3-4C5A-83A3-C14760945710.html",
							"GUID-279921BE-6BA3-4C5A-83A3-C14760945710.html",
							"GUID-279921BE-6BA3-4C5A-83A3-C14760945710.html",
							"GUID-279921BE-6BA3-4C5A-83A3-C14760945710.html",
							"GUID-279921BE-6BA3-4C5A-83A3-C14760945710.html",
							"GUID-279921BE-6BA3-4C5A-83A3-C14760945710.html",
							"GUID-279921BE-6BA3-4C5A-83A3-C14760945710.html",
							"GUID-3FA52A35-7013-4C4F-B9A2-F42CEB0E6AED.html",
							"GUID-3FA52A35-7013-4C4F-B9A2-F42CEB0E6AED.html",
							"GUID-3FA52A35-7013-4C4F-B9A2-F42CEB0E6AED.html",
							"GUID-3FA52A35-7013-4C4F-B9A2-F42CEB0E6AED.html",
							"GUID-3FA52A35-7013-4C4F-B9A2-F42CEB0E6AED.html",
							"GUID-60293D0A-331A-49A7-ACDF-2982AD6CE6B0.html",
							"GUID-60293D0A-331A-49A7-ACDF-2982AD6CE6B0.html",
							"GUID-60293D0A-331A-49A7-ACDF-2982AD6CE6B0.html",
							"GUID-60293D0A-331A-49A7-ACDF-2982AD6CE6B0.html",
							"GUID-60293D0A-331A-49A7-ACDF-2982AD6CE6B0.html",
							"GUID-3DC42773-D3EB-409B-8F4B-F1E4025E9E90.html",
							"GUID-3DC42773-D3EB-409B-8F4B-F1E4025E9E90.html",
							"GUID-3DC42773-D3EB-409B-8F4B-F1E4025E9E90.html",
							"GUID-3DC42773-D3EB-409B-8F4B-F1E4025E9E90.html",
							"GUID-3DC42773-D3EB-409B-8F4B-F1E4025E9E90.html",
							"GUID-3DC42773-D3EB-409B-8F4B-F1E4025E9E90.html",
							"GUID-3DC42773-D3EB-409B-8F4B-F1E4025E9E90.html",
							"GUID-3DC42773-D3EB-409B-8F4B-F1E4025E9E90.html",
							"GUID-41B61931-E124-4512-A689-5B0643F249E8.html",
							"GUID-276B2413-47FF-4F2A-8221-2808537B02CE.html",
							"GUID-C27C1233-4756-42B3-A2BF-BDCCC1251846.html",
							"GUID-003B6A7B-CA79-4634-A1B5-681AE15747B2.html",
							"GUID-9FCF9580-48B3-4A80-B3E5-C104CF090A62.html",
							"GUID-410DBBCC-D224-45B2-B881-7BFB0DFF0EFC.html",
							"GUID-0381E2F0-27AD-4688-8C95-60FC00AD42FF.html",
							"GUID-0381E2F0-27AD-4688-8C95-60FC00AD42FF.html",
							"GUID-0381E2F0-27AD-4688-8C95-60FC00AD42FF.html",
							"GUID-0381E2F0-27AD-4688-8C95-60FC00AD42FF.html",
							"GUID-0381E2F0-27AD-4688-8C95-60FC00AD42FF.html",
							"GUID-0381E2F0-27AD-4688-8C95-60FC00AD42FF.html",
							"GUID-0381E2F0-27AD-4688-8C95-60FC00AD42FF.html",
							"GUID-0381E2F0-27AD-4688-8C95-60FC00AD42FF.html",
							"GUID-0381E2F0-27AD-4688-8C95-60FC00AD42FF.html",
							"GUID-EC748BA1-9BAC-4215-A451-951C7AD230DA.html",
							"GUID-EC748BA1-9BAC-4215-A451-951C7AD230DA.html",
							"GUID-EC748BA1-9BAC-4215-A451-951C7AD230DA.html",
							"GUID-EC748BA1-9BAC-4215-A451-951C7AD230DA.html",
							"GUID-EC748BA1-9BAC-4215-A451-951C7AD230DA.html",
							"GUID-EC748BA1-9BAC-4215-A451-951C7AD230DA.html",
							"GUID-EC748BA1-9BAC-4215-A451-951C7AD230DA.html",
							"GUID-EC748BA1-9BAC-4215-A451-951C7AD230DA.html",
							"GUID-EC748BA1-9BAC-4215-A451-951C7AD230DA.html",
							"GUID-42849F24-7399-4889-A3D2-18673DDDD78D.html",
							"GUID-42849F24-7399-4889-A3D2-18673DDDD78D.html",
							"GUID-42849F24-7399-4889-A3D2-18673DDDD78D.html",
							"GUID-42849F24-7399-4889-A3D2-18673DDDD78D.html",
							"GUID-42849F24-7399-4889-A3D2-18673DDDD78D.html",
							"GUID-42849F24-7399-4889-A3D2-18673DDDD78D.html",
							"GUID-42849F24-7399-4889-A3D2-18673DDDD78D.html",
							"GUID-42849F24-7399-4889-A3D2-18673DDDD78D.html",
							"GUID-42849F24-7399-4889-A3D2-18673DDDD78D.html",
							"GUID-6CDF8842-E92B-4F0E-8E5D-95DAFE16410D.html",
							"GUID-6CDF8842-E92B-4F0E-8E5D-95DAFE16410D.html",
							"GUID-6CDF8842-E92B-4F0E-8E5D-95DAFE16410D.html",
							"GUID-6CDF8842-E92B-4F0E-8E5D-95DAFE16410D.html",
							"GUID-6CDF8842-E92B-4F0E-8E5D-95DAFE16410D.html",
							"GUID-6CDF8842-E92B-4F0E-8E5D-95DAFE16410D.html",
							"GUID-6CDF8842-E92B-4F0E-8E5D-95DAFE16410D.html",
							"GUID-6CDF8842-E92B-4F0E-8E5D-95DAFE16410D.html",
							"GUID-6CDF8842-E92B-4F0E-8E5D-95DAFE16410D.html",
							"GUID-6667FC20-3017-4F29-82D8-D2873B38AC8E.html",
							"GUID-6667FC20-3017-4F29-82D8-D2873B38AC8E.html",
							"GUID-6667FC20-3017-4F29-82D8-D2873B38AC8E.html",
							"GUID-6667FC20-3017-4F29-82D8-D2873B38AC8E.html",
							"GUID-6667FC20-3017-4F29-82D8-D2873B38AC8E.html",
							"GUID-6667FC20-3017-4F29-82D8-D2873B38AC8E.html",
							"GUID-6667FC20-3017-4F29-82D8-D2873B38AC8E.html",
							"GUID-6667FC20-3017-4F29-82D8-D2873B38AC8E.html",
							"GUID-6667FC20-3017-4F29-82D8-D2873B38AC8E.html",
							"GUID-030A860C-69CB-4950-B0D8-91A9E1DA2839.html",
							"GUID-030A860C-69CB-4950-B0D8-91A9E1DA2839.html",
							"GUID-030A860C-69CB-4950-B0D8-91A9E1DA2839.html",
							"GUID-030A860C-69CB-4950-B0D8-91A9E1DA2839.html",
							"GUID-030A860C-69CB-4950-B0D8-91A9E1DA2839.html",
							"GUID-030A860C-69CB-4950-B0D8-91A9E1DA2839.html",
							"GUID-030A860C-69CB-4950-B0D8-91A9E1DA2839.html",
							"GUID-030A860C-69CB-4950-B0D8-91A9E1DA2839.html",
							"GUID-030A860C-69CB-4950-B0D8-91A9E1DA2839.html",
							"GUID-918010E3-6FC5-4A07-9626-4E16FC61ECCE.html",
							"GUID-918010E3-6FC5-4A07-9626-4E16FC61ECCE.html",
							"GUID-918010E3-6FC5-4A07-9626-4E16FC61ECCE.html",
							"GUID-918010E3-6FC5-4A07-9626-4E16FC61ECCE.html",
							"GUID-918010E3-6FC5-4A07-9626-4E16FC61ECCE.html",
							"GUID-918010E3-6FC5-4A07-9626-4E16FC61ECCE.html",
							"GUID-918010E3-6FC5-4A07-9626-4E16FC61ECCE.html",
							"GUID-918010E3-6FC5-4A07-9626-4E16FC61ECCE.html",
							"GUID-918010E3-6FC5-4A07-9626-4E16FC61ECCE.html",
							"GUID-75EA4FAD-10D6-4276-A80E-4F19FC9E6F9D.html",
							"GUID-75EA4FAD-10D6-4276-A80E-4F19FC9E6F9D.html",
							"GUID-75EA4FAD-10D6-4276-A80E-4F19FC9E6F9D.html",
							"GUID-75EA4FAD-10D6-4276-A80E-4F19FC9E6F9D.html",
							"GUID-75EA4FAD-10D6-4276-A80E-4F19FC9E6F9D.html",
							"GUID-75EA4FAD-10D6-4276-A80E-4F19FC9E6F9D.html",
							"GUID-75EA4FAD-10D6-4276-A80E-4F19FC9E6F9D.html",
							"GUID-75EA4FAD-10D6-4276-A80E-4F19FC9E6F9D.html",
							"GUID-75EA4FAD-10D6-4276-A80E-4F19FC9E6F9D.html",
							"GUID-77D7DF1E-E1CB-47CD-B5C1-6DFC3700CF3D.html",
							"GUID-77D7DF1E-E1CB-47CD-B5C1-6DFC3700CF3D.html",
							"GUID-77D7DF1E-E1CB-47CD-B5C1-6DFC3700CF3D.html",
							"GUID-77D7DF1E-E1CB-47CD-B5C1-6DFC3700CF3D.html",
							"GUID-77D7DF1E-E1CB-47CD-B5C1-6DFC3700CF3D.html",
							"GUID-77D7DF1E-E1CB-47CD-B5C1-6DFC3700CF3D.html",
							"GUID-77D7DF1E-E1CB-47CD-B5C1-6DFC3700CF3D.html",
							"GUID-77D7DF1E-E1CB-47CD-B5C1-6DFC3700CF3D.html",
							"GUID-77D7DF1E-E1CB-47CD-B5C1-6DFC3700CF3D.html",
							"GUID-B9E79528-189C-4FA7-9252-A96AF3636B2B.html",
							"GUID-B9E79528-189C-4FA7-9252-A96AF3636B2B.html",
							"GUID-B9E79528-189C-4FA7-9252-A96AF3636B2B.html",
							"GUID-B9E79528-189C-4FA7-9252-A96AF3636B2B.html",
							"GUID-B9E79528-189C-4FA7-9252-A96AF3636B2B.html",
							"GUID-B9E79528-189C-4FA7-9252-A96AF3636B2B.html",
							"GUID-B9E79528-189C-4FA7-9252-A96AF3636B2B.html",
							"GUID-B9E79528-189C-4FA7-9252-A96AF3636B2B.html",
							"GUID-B9E79528-189C-4FA7-9252-A96AF3636B2B.html",
							"GUID-304B5F79-B8A0-478C-9C98-3D405FD8C868.html",
							"GUID-304B5F79-B8A0-478C-9C98-3D405FD8C868.html",
							"GUID-304B5F79-B8A0-478C-9C98-3D405FD8C868.html",
							"GUID-304B5F79-B8A0-478C-9C98-3D405FD8C868.html",
							"GUID-304B5F79-B8A0-478C-9C98-3D405FD8C868.html",
							"GUID-304B5F79-B8A0-478C-9C98-3D405FD8C868.html",
							"GUID-304B5F79-B8A0-478C-9C98-3D405FD8C868.html",
							"GUID-304B5F79-B8A0-478C-9C98-3D405FD8C868.html",
							"GUID-304B5F79-B8A0-478C-9C98-3D405FD8C868.html",
							"GUID-7F7AA1C9-FF6A-4C0F-A381-68CD1DE5049E.html",
							"GUID-7F7AA1C9-FF6A-4C0F-A381-68CD1DE5049E.html",
							"GUID-7F7AA1C9-FF6A-4C0F-A381-68CD1DE5049E.html",
							"GUID-7F7AA1C9-FF6A-4C0F-A381-68CD1DE5049E.html",
							"GUID-7F7AA1C9-FF6A-4C0F-A381-68CD1DE5049E.html",
							"GUID-7F7AA1C9-FF6A-4C0F-A381-68CD1DE5049E.html",
							"GUID-7F7AA1C9-FF6A-4C0F-A381-68CD1DE5049E.html",
							"GUID-7F7AA1C9-FF6A-4C0F-A381-68CD1DE5049E.html",
							"GUID-7F7AA1C9-FF6A-4C0F-A381-68CD1DE5049E.html",
							"GUID-B923A6E5-4C36-4DCA-8F94-360FC1E49735.html",
							"GUID-B923A6E5-4C36-4DCA-8F94-360FC1E49735.html",
							"GUID-B923A6E5-4C36-4DCA-8F94-360FC1E49735.html",
							"GUID-B923A6E5-4C36-4DCA-8F94-360FC1E49735.html",
							"GUID-B923A6E5-4C36-4DCA-8F94-360FC1E49735.html",
							"GUID-B923A6E5-4C36-4DCA-8F94-360FC1E49735.html",
							"GUID-B923A6E5-4C36-4DCA-8F94-360FC1E49735.html",
							"GUID-B923A6E5-4C36-4DCA-8F94-360FC1E49735.html",
							"GUID-B923A6E5-4C36-4DCA-8F94-360FC1E49735.html",
							"GUID-1F957550-41AD-4F0F-A9D8-8E289DD36931.html",
							"GUID-1F957550-41AD-4F0F-A9D8-8E289DD36931.html",
							"GUID-1F957550-41AD-4F0F-A9D8-8E289DD36931.html",
							"GUID-1F957550-41AD-4F0F-A9D8-8E289DD36931.html",
							"GUID-1F957550-41AD-4F0F-A9D8-8E289DD36931.html",
							"GUID-03E37865-7F03-4BF3-B654-845323CBE7E4.html",
							"GUID-03E37865-7F03-4BF3-B654-845323CBE7E4.html",
							"GUID-03E37865-7F03-4BF3-B654-845323CBE7E4.html",
							"GUID-03E37865-7F03-4BF3-B654-845323CBE7E4.html",
							"GUID-03E37865-7F03-4BF3-B654-845323CBE7E4.html",
							"GUID-11624F96-C547-408B-81F9-B4FA1C9487D6.html",
							"GUID-F80CCFFC-C9C8-470C-AA7B-0EFA2BB1BEAA.html",
							"GUID-5055B627-5871-44D5-8828-540B31A4449B.html",
							"GUID-26A5CBB5-5CB3-4298-8E56-AF03087027CF.html",
							"GUID-9FCC5D93-AC38-4FA0-88B8-A6C5A9BAF6EF.html",
							"GUID-D64948C5-0865-4700-974A-6EFC4BA20290.html",
							"GUID-D64948C5-0865-4700-974A-6EFC4BA20290.html",
							"GUID-D64948C5-0865-4700-974A-6EFC4BA20290.html",
							"GUID-D64948C5-0865-4700-974A-6EFC4BA20290.html",
							"GUID-D64948C5-0865-4700-974A-6EFC4BA20290.html",
							"GUID-D64948C5-0865-4700-974A-6EFC4BA20290.html",
							"GUID-D64948C5-0865-4700-974A-6EFC4BA20290.html",
							"GUID-D64948C5-0865-4700-974A-6EFC4BA20290.html",
							"GUID-D64948C5-0865-4700-974A-6EFC4BA20290.html",
							"GUID-0A0D0DD6-3DF8-4DBF-A8DE-81EB0726D30A.html",
							"GUID-0A0D0DD6-3DF8-4DBF-A8DE-81EB0726D30A.html",
							"GUID-0A0D0DD6-3DF8-4DBF-A8DE-81EB0726D30A.html",
							"GUID-0A0D0DD6-3DF8-4DBF-A8DE-81EB0726D30A.html",
							"GUID-0A0D0DD6-3DF8-4DBF-A8DE-81EB0726D30A.html",
							"GUID-0A0D0DD6-3DF8-4DBF-A8DE-81EB0726D30A.html",
							"GUID-0A0D0DD6-3DF8-4DBF-A8DE-81EB0726D30A.html",
							"GUID-0A0D0DD6-3DF8-4DBF-A8DE-81EB0726D30A.html",
							"GUID-0A0D0DD6-3DF8-4DBF-A8DE-81EB0726D30A.html",
							"GUID-4F45A6E9-23AF-473C-9001-8C1E9EBF58DB.html",
							"GUID-4F45A6E9-23AF-473C-9001-8C1E9EBF58DB.html",
							"GUID-4F45A6E9-23AF-473C-9001-8C1E9EBF58DB.html",
							"GUID-4F45A6E9-23AF-473C-9001-8C1E9EBF58DB.html",
							"GUID-4F45A6E9-23AF-473C-9001-8C1E9EBF58DB.html",
							"GUID-4F45A6E9-23AF-473C-9001-8C1E9EBF58DB.html",
							"GUID-4F45A6E9-23AF-473C-9001-8C1E9EBF58DB.html",
							"GUID-4F45A6E9-23AF-473C-9001-8C1E9EBF58DB.html",
							"GUID-4F45A6E9-23AF-473C-9001-8C1E9EBF58DB.html",
							"GUID-78FE973E-69BA-4A7F-ACE0-669D8F7B9241.html",
							"GUID-78FE973E-69BA-4A7F-ACE0-669D8F7B9241.html",
							"GUID-78FE973E-69BA-4A7F-ACE0-669D8F7B9241.html",
							"GUID-78FE973E-69BA-4A7F-ACE0-669D8F7B9241.html",
							"GUID-78FE973E-69BA-4A7F-ACE0-669D8F7B9241.html",
							"GUID-78FE973E-69BA-4A7F-ACE0-669D8F7B9241.html",
							"GUID-78FE973E-69BA-4A7F-ACE0-669D8F7B9241.html",
							"GUID-78FE973E-69BA-4A7F-ACE0-669D8F7B9241.html",
							"GUID-78FE973E-69BA-4A7F-ACE0-669D8F7B9241.html",
							"GUID-5FE0390A-B22A-411C-8F18-4D3CE8BCBDF9.html",
							"GUID-5FE0390A-B22A-411C-8F18-4D3CE8BCBDF9.html",
							"GUID-5FE0390A-B22A-411C-8F18-4D3CE8BCBDF9.html",
							"GUID-5FE0390A-B22A-411C-8F18-4D3CE8BCBDF9.html",
							"GUID-5FE0390A-B22A-411C-8F18-4D3CE8BCBDF9.html",
							"GUID-5FE0390A-B22A-411C-8F18-4D3CE8BCBDF9.html",
							"GUID-5FE0390A-B22A-411C-8F18-4D3CE8BCBDF9.html",
							"GUID-5FE0390A-B22A-411C-8F18-4D3CE8BCBDF9.html",
							"GUID-5FE0390A-B22A-411C-8F18-4D3CE8BCBDF9.html",
							"GUID-8B644CA2-82B6-4CFE-8F73-6079A6CC5256.html",
							"GUID-8B644CA2-82B6-4CFE-8F73-6079A6CC5256.html",
							"GUID-8B644CA2-82B6-4CFE-8F73-6079A6CC5256.html",
							"GUID-8B644CA2-82B6-4CFE-8F73-6079A6CC5256.html",
							"GUID-8B644CA2-82B6-4CFE-8F73-6079A6CC5256.html",
							"GUID-8B644CA2-82B6-4CFE-8F73-6079A6CC5256.html",
							"GUID-8B644CA2-82B6-4CFE-8F73-6079A6CC5256.html",
							"GUID-8B644CA2-82B6-4CFE-8F73-6079A6CC5256.html",
							"GUID-8B644CA2-82B6-4CFE-8F73-6079A6CC5256.html",
							"GUID-30C3EC2E-74C5-4262-9786-362DBA86AFEA.html",
							"GUID-30C3EC2E-74C5-4262-9786-362DBA86AFEA.html",
							"GUID-30C3EC2E-74C5-4262-9786-362DBA86AFEA.html",
							"GUID-30C3EC2E-74C5-4262-9786-362DBA86AFEA.html",
							"GUID-30C3EC2E-74C5-4262-9786-362DBA86AFEA.html",
							"GUID-30C3EC2E-74C5-4262-9786-362DBA86AFEA.html",
							"GUID-30C3EC2E-74C5-4262-9786-362DBA86AFEA.html",
							"GUID-30C3EC2E-74C5-4262-9786-362DBA86AFEA.html",
							"GUID-30C3EC2E-74C5-4262-9786-362DBA86AFEA.html",
							"GUID-17D19DF8-7FD4-4C76-A204-5CEFB779D8A9.html",
							"GUID-17D19DF8-7FD4-4C76-A204-5CEFB779D8A9.html",
							"GUID-17D19DF8-7FD4-4C76-A204-5CEFB779D8A9.html",
							"GUID-17D19DF8-7FD4-4C76-A204-5CEFB779D8A9.html",
							"GUID-17D19DF8-7FD4-4C76-A204-5CEFB779D8A9.html",
							"GUID-17D19DF8-7FD4-4C76-A204-5CEFB779D8A9.html",
							"GUID-17D19DF8-7FD4-4C76-A204-5CEFB779D8A9.html",
							"GUID-17D19DF8-7FD4-4C76-A204-5CEFB779D8A9.html",
							"GUID-17D19DF8-7FD4-4C76-A204-5CEFB779D8A9.html",
							"GUID-DF41BC8C-CD07-476D-A7FC-B6FEE97C373E.html",
							"GUID-DF41BC8C-CD07-476D-A7FC-B6FEE97C373E.html",
							"GUID-DF41BC8C-CD07-476D-A7FC-B6FEE97C373E.html",
							"GUID-DF41BC8C-CD07-476D-A7FC-B6FEE97C373E.html",
							"GUID-DF41BC8C-CD07-476D-A7FC-B6FEE97C373E.html",
							"GUID-DF41BC8C-CD07-476D-A7FC-B6FEE97C373E.html",
							"GUID-DF41BC8C-CD07-476D-A7FC-B6FEE97C373E.html",
							"GUID-DF41BC8C-CD07-476D-A7FC-B6FEE97C373E.html",
							"GUID-DF41BC8C-CD07-476D-A7FC-B6FEE97C373E.html",
							"GUID-D4834F35-FAA3-48E7-BBFB-694C9BA6476E.html",
							"GUID-D4834F35-FAA3-48E7-BBFB-694C9BA6476E.html",
							"GUID-D4834F35-FAA3-48E7-BBFB-694C9BA6476E.html",
							"GUID-D4834F35-FAA3-48E7-BBFB-694C9BA6476E.html",
							"GUID-D4834F35-FAA3-48E7-BBFB-694C9BA6476E.html",
							"GUID-D4834F35-FAA3-48E7-BBFB-694C9BA6476E.html",
							"GUID-D4834F35-FAA3-48E7-BBFB-694C9BA6476E.html",
							"GUID-D4834F35-FAA3-48E7-BBFB-694C9BA6476E.html",
							"GUID-D4834F35-FAA3-48E7-BBFB-694C9BA6476E.html",
							"GUID-BC696779-C030-4709-B540-2779B58ABC08.html",
							"GUID-BC696779-C030-4709-B540-2779B58ABC08.html",
							"GUID-BC696779-C030-4709-B540-2779B58ABC08.html",
							"GUID-BC696779-C030-4709-B540-2779B58ABC08.html",
							"GUID-BC696779-C030-4709-B540-2779B58ABC08.html",
							"GUID-BC696779-C030-4709-B540-2779B58ABC08.html",
							"GUID-BC696779-C030-4709-B540-2779B58ABC08.html",
							"GUID-BC696779-C030-4709-B540-2779B58ABC08.html",
							"GUID-BC696779-C030-4709-B540-2779B58ABC08.html",
							"GUID-16F6C851-DB9F-4997-8669-1E9C6C128B45.html",
							"GUID-16F6C851-DB9F-4997-8669-1E9C6C128B45.html",
							"GUID-16F6C851-DB9F-4997-8669-1E9C6C128B45.html",
							"GUID-16F6C851-DB9F-4997-8669-1E9C6C128B45.html",
							"GUID-16F6C851-DB9F-4997-8669-1E9C6C128B45.html",
							"GUID-16F6C851-DB9F-4997-8669-1E9C6C128B45.html",
							"GUID-16F6C851-DB9F-4997-8669-1E9C6C128B45.html",
							"GUID-16F6C851-DB9F-4997-8669-1E9C6C128B45.html",
							"GUID-16F6C851-DB9F-4997-8669-1E9C6C128B45.html",
							"GUID-ACA74B78-E632-4CE1-BF4B-C0073C64D35F.html",
							"GUID-ACA74B78-E632-4CE1-BF4B-C0073C64D35F.html",
							"GUID-ACA74B78-E632-4CE1-BF4B-C0073C64D35F.html",
							"GUID-ACA74B78-E632-4CE1-BF4B-C0073C64D35F.html",
							"GUID-ACA74B78-E632-4CE1-BF4B-C0073C64D35F.html",
							"GUID-ACA74B78-E632-4CE1-BF4B-C0073C64D35F.html",
							"GUID-ACA74B78-E632-4CE1-BF4B-C0073C64D35F.html",
							"GUID-ACA74B78-E632-4CE1-BF4B-C0073C64D35F.html",
							"GUID-ACA74B78-E632-4CE1-BF4B-C0073C64D35F.html",
							"GUID-EF5DB136-2E82-44C7-83C5-278C3F5A5816.html",
							"GUID-EF5DB136-2E82-44C7-83C5-278C3F5A5816.html",
							"GUID-EF5DB136-2E82-44C7-83C5-278C3F5A5816.html",
							"GUID-EF5DB136-2E82-44C7-83C5-278C3F5A5816.html",
							"GUID-EF5DB136-2E82-44C7-83C5-278C3F5A5816.html",
							"GUID-EF5DB136-2E82-44C7-83C5-278C3F5A5816.html",
							"GUID-EF5DB136-2E82-44C7-83C5-278C3F5A5816.html",
							"GUID-EF5DB136-2E82-44C7-83C5-278C3F5A5816.html",
							"GUID-EF5DB136-2E82-44C7-83C5-278C3F5A5816.html",
							"GUID-1BD4F2ED-A921-4BA7-BD26-6A82515F4CB4.html",
							"GUID-1BD4F2ED-A921-4BA7-BD26-6A82515F4CB4.html",
							"GUID-1BD4F2ED-A921-4BA7-BD26-6A82515F4CB4.html",
							"GUID-1BD4F2ED-A921-4BA7-BD26-6A82515F4CB4.html",
							"GUID-1BD4F2ED-A921-4BA7-BD26-6A82515F4CB4.html",
							"GUID-F9E815F6-E87D-440E-991F-639B3C38F3D3.html",
							"GUID-F9E815F6-E87D-440E-991F-639B3C38F3D3.html",
							"GUID-F9E815F6-E87D-440E-991F-639B3C38F3D3.html",
							"GUID-F9E815F6-E87D-440E-991F-639B3C38F3D3.html",
							"GUID-F9E815F6-E87D-440E-991F-639B3C38F3D3.html",
							"GUID-AAF04ADC-3D87-41C9-B3F1-E24105F2CB81.html",
							"GUID-AAF04ADC-3D87-41C9-B3F1-E24105F2CB81.html",
							"GUID-AAF04ADC-3D87-41C9-B3F1-E24105F2CB81.html",
							"GUID-AAF04ADC-3D87-41C9-B3F1-E24105F2CB81.html",
							"GUID-AAF04ADC-3D87-41C9-B3F1-E24105F2CB81.html",
							"GUID-AAF04ADC-3D87-41C9-B3F1-E24105F2CB81.html",
							"GUID-AAF04ADC-3D87-41C9-B3F1-E24105F2CB81.html",
							"GUID-AAF04ADC-3D87-41C9-B3F1-E24105F2CB81.html",
							"GUID-EA5ADDDE-73D5-43CB-B474-0752CA9A1A50.html",
							"GUID-B6B51E48-2D3D-42F8-8493-3405F1639A9E.html",
							"GUID-81197D3F-1C5D-42BE-9E46-4D06F2B80213.html",
							"GUID-81197D3F-1C5D-42BE-9E46-4D06F2B80213.html",
							"GUID-81197D3F-1C5D-42BE-9E46-4D06F2B80213.html",
							"GUID-81197D3F-1C5D-42BE-9E46-4D06F2B80213.html",
							"GUID-81197D3F-1C5D-42BE-9E46-4D06F2B80213.html",
							"GUID-36B5D226-2635-43AA-8DC9-5A3E5C0454D3.html",
							"GUID-36B5D226-2635-43AA-8DC9-5A3E5C0454D3.html",
							"GUID-36B5D226-2635-43AA-8DC9-5A3E5C0454D3.html",
							"GUID-36B5D226-2635-43AA-8DC9-5A3E5C0454D3.html",
							"GUID-36B5D226-2635-43AA-8DC9-5A3E5C0454D3.html",
							"GUID-C1652CB7-C2F7-4921-818C-AFCEED6AADA3.html",
							"GUID-C1652CB7-C2F7-4921-818C-AFCEED6AADA3.html",
							"GUID-C1652CB7-C2F7-4921-818C-AFCEED6AADA3.html",
							"GUID-C1652CB7-C2F7-4921-818C-AFCEED6AADA3.html",
							"GUID-C1652CB7-C2F7-4921-818C-AFCEED6AADA3.html",
							"GUID-C1652CB7-C2F7-4921-818C-AFCEED6AADA3.html",
							"GUID-C1652CB7-C2F7-4921-818C-AFCEED6AADA3.html",
							"GUID-B8A7B902-CAD4-40FB-9A74-9E703A1D74E1.html",
							"GUID-B8A7B902-CAD4-40FB-9A74-9E703A1D74E1.html",
							"GUID-B8A7B902-CAD4-40FB-9A74-9E703A1D74E1.html",
							"GUID-B8A7B902-CAD4-40FB-9A74-9E703A1D74E1.html",
							"GUID-B8A7B902-CAD4-40FB-9A74-9E703A1D74E1.html",
							"GUID-2CD3427C-B642-4F8A-9D40-CE532F4128B9.html",
							"GUID-2CD3427C-B642-4F8A-9D40-CE532F4128B9.html",
							"GUID-2CD3427C-B642-4F8A-9D40-CE532F4128B9.html",
							"GUID-2CD3427C-B642-4F8A-9D40-CE532F4128B9.html",
							"GUID-2CD3427C-B642-4F8A-9D40-CE532F4128B9.html",
							"GUID-D51F6D7B-122E-499A-A41C-D2DCC14B13E5.html",
							"GUID-D51F6D7B-122E-499A-A41C-D2DCC14B13E5.html",
							"GUID-D51F6D7B-122E-499A-A41C-D2DCC14B13E5.html",
							"GUID-D51F6D7B-122E-499A-A41C-D2DCC14B13E5.html",
							"GUID-D51F6D7B-122E-499A-A41C-D2DCC14B13E5.html",
							"GUID-E63F4C79-2933-4B21-9821-4F97ECD39F25.html",
							"GUID-E63F4C79-2933-4B21-9821-4F97ECD39F25.html",
							"GUID-E63F4C79-2933-4B21-9821-4F97ECD39F25.html",
							"GUID-E63F4C79-2933-4B21-9821-4F97ECD39F25.html",
							"GUID-E63F4C79-2933-4B21-9821-4F97ECD39F25.html",
							"GUID-FF7CCB48-D53D-41C8-BEA6-C82E725F2B34.html",
							"GUID-FF7CCB48-D53D-41C8-BEA6-C82E725F2B34.html",
							"GUID-FF7CCB48-D53D-41C8-BEA6-C82E725F2B34.html",
							"GUID-FF7CCB48-D53D-41C8-BEA6-C82E725F2B34.html",
							"GUID-FF7CCB48-D53D-41C8-BEA6-C82E725F2B34.html",
							"GUID-51F8BB44-5FBD-4178-A815-F38AC412C76F.html",
							"GUID-51F8BB44-5FBD-4178-A815-F38AC412C76F.html",
							"GUID-51F8BB44-5FBD-4178-A815-F38AC412C76F.html",
							"GUID-51F8BB44-5FBD-4178-A815-F38AC412C76F.html",
							"GUID-51F8BB44-5FBD-4178-A815-F38AC412C76F.html",
							"GUID-3CA2C276-2D1F-4D9F-9809-8714A2432982.html",
							"GUID-3CA2C276-2D1F-4D9F-9809-8714A2432982.html",
							"GUID-3CA2C276-2D1F-4D9F-9809-8714A2432982.html",
							"GUID-3CA2C276-2D1F-4D9F-9809-8714A2432982.html",
							"GUID-3CA2C276-2D1F-4D9F-9809-8714A2432982.html",
							"GUID-B330DC10-1070-456F-A0E3-99774F49CC0E.html",
							"GUID-B330DC10-1070-456F-A0E3-99774F49CC0E.html",
							"GUID-B330DC10-1070-456F-A0E3-99774F49CC0E.html",
							"GUID-B330DC10-1070-456F-A0E3-99774F49CC0E.html",
							"GUID-B330DC10-1070-456F-A0E3-99774F49CC0E.html",
							"GUID-0227D171-4FC3-4FBD-AB61-ECF771414E78.html",
							"GUID-0227D171-4FC3-4FBD-AB61-ECF771414E78.html",
							"GUID-0227D171-4FC3-4FBD-AB61-ECF771414E78.html",
							"GUID-0227D171-4FC3-4FBD-AB61-ECF771414E78.html",
							"GUID-0227D171-4FC3-4FBD-AB61-ECF771414E78.html",
							"GUID-DE87A672-4D73-487A-A09E-81F7A3547EE1.html",
							"GUID-DE87A672-4D73-487A-A09E-81F7A3547EE1.html",
							"GUID-DE87A672-4D73-487A-A09E-81F7A3547EE1.html",
							"GUID-DE87A672-4D73-487A-A09E-81F7A3547EE1.html",
							"GUID-DE87A672-4D73-487A-A09E-81F7A3547EE1.html",
							"GUID-7D1994BE-DCEF-4D7F-8009-20EAEBC66D92.html",
							"GUID-7D1994BE-DCEF-4D7F-8009-20EAEBC66D92.html",
							"GUID-7D1994BE-DCEF-4D7F-8009-20EAEBC66D92.html",
							"GUID-7D1994BE-DCEF-4D7F-8009-20EAEBC66D92.html",
							"GUID-7D1994BE-DCEF-4D7F-8009-20EAEBC66D92.html",
							"GUID-BCEA1DD4-45DD-4DDD-97C6-B04C4E1C4821.html",
							"GUID-BCEA1DD4-45DD-4DDD-97C6-B04C4E1C4821.html",
							"GUID-BCEA1DD4-45DD-4DDD-97C6-B04C4E1C4821.html",
							"GUID-BCEA1DD4-45DD-4DDD-97C6-B04C4E1C4821.html",
							"GUID-BCEA1DD4-45DD-4DDD-97C6-B04C4E1C4821.html",
							"GUID-1DC1CF6A-C007-4369-9A97-ED9858CF73FF.html",
							"GUID-1DC1CF6A-C007-4369-9A97-ED9858CF73FF.html",
							"GUID-1DC1CF6A-C007-4369-9A97-ED9858CF73FF.html",
							"GUID-1DC1CF6A-C007-4369-9A97-ED9858CF73FF.html",
							"GUID-1DC1CF6A-C007-4369-9A97-ED9858CF73FF.html",
							"GUID-C4347A04-B554-485F-9162-7801140982A7.html",
							"GUID-C4347A04-B554-485F-9162-7801140982A7.html",
							"GUID-C4347A04-B554-485F-9162-7801140982A7.html",
							"GUID-C4347A04-B554-485F-9162-7801140982A7.html",
							"GUID-C4347A04-B554-485F-9162-7801140982A7.html",
							"GUID-C4347A04-B554-485F-9162-7801140982A7.html",
							"GUID-C4347A04-B554-485F-9162-7801140982A7.html",
							"GUID-C4347A04-B554-485F-9162-7801140982A7.html",
							"GUID-B708D73F-E511-494D-8F37-607CA9F5F522.html",
							"GUID-B708D73F-E511-494D-8F37-607CA9F5F522.html",
							"GUID-B708D73F-E511-494D-8F37-607CA9F5F522.html",
							"GUID-B708D73F-E511-494D-8F37-607CA9F5F522.html",
							"GUID-B708D73F-E511-494D-8F37-607CA9F5F522.html",
							"GUID-B708D73F-E511-494D-8F37-607CA9F5F522.html",
							"GUID-B708D73F-E511-494D-8F37-607CA9F5F522.html",
							"GUID-B708D73F-E511-494D-8F37-607CA9F5F522.html",
							"GUID-B708D73F-E511-494D-8F37-607CA9F5F522.html",
							"GUID-023598E8-102F-44AD-B249-A4274EEFEF19.html",
							"GUID-023598E8-102F-44AD-B249-A4274EEFEF19.html",
							"GUID-023598E8-102F-44AD-B249-A4274EEFEF19.html",
							"GUID-023598E8-102F-44AD-B249-A4274EEFEF19.html",
							"GUID-023598E8-102F-44AD-B249-A4274EEFEF19.html",
							"GUID-023598E8-102F-44AD-B249-A4274EEFEF19.html",
							"GUID-023598E8-102F-44AD-B249-A4274EEFEF19.html",
							"GUID-023598E8-102F-44AD-B249-A4274EEFEF19.html",
							"GUID-023598E8-102F-44AD-B249-A4274EEFEF19.html",
							"GUID-517AC4B5-5AC6-4197-81B3-837E7F98A6BB.html",
							"GUID-517AC4B5-5AC6-4197-81B3-837E7F98A6BB.html",
							"GUID-517AC4B5-5AC6-4197-81B3-837E7F98A6BB.html",
							"GUID-517AC4B5-5AC6-4197-81B3-837E7F98A6BB.html",
							"GUID-517AC4B5-5AC6-4197-81B3-837E7F98A6BB.html",
							"GUID-517AC4B5-5AC6-4197-81B3-837E7F98A6BB.html",
							"GUID-517AC4B5-5AC6-4197-81B3-837E7F98A6BB.html",
							"GUID-517AC4B5-5AC6-4197-81B3-837E7F98A6BB.html",
							"GUID-3C237595-59AC-42AF-8B3C-D0DA8D4B3B7C.html",
							"GUID-3C237595-59AC-42AF-8B3C-D0DA8D4B3B7C.html",
							"GUID-3C237595-59AC-42AF-8B3C-D0DA8D4B3B7C.html",
							"GUID-3C237595-59AC-42AF-8B3C-D0DA8D4B3B7C.html",
							"GUID-3C237595-59AC-42AF-8B3C-D0DA8D4B3B7C.html",
							"GUID-3C237595-59AC-42AF-8B3C-D0DA8D4B3B7C.html",
							"GUID-3C237595-59AC-42AF-8B3C-D0DA8D4B3B7C.html",
							"GUID-3C237595-59AC-42AF-8B3C-D0DA8D4B3B7C.html",
							"GUID-3C237595-59AC-42AF-8B3C-D0DA8D4B3B7C.html",
							"GUID-4522BF0A-636F-448D-B87F-2342F8CBEB00.html",
							"GUID-9E69B512-F170-41AC-B9DF-FAC16E96E328.html",
							"GUID-9E69B512-F170-41AC-B9DF-FAC16E96E328.html",
							"GUID-9E69B512-F170-41AC-B9DF-FAC16E96E328.html",
							"GUID-9E69B512-F170-41AC-B9DF-FAC16E96E328.html",
							"GUID-9E69B512-F170-41AC-B9DF-FAC16E96E328.html",
							"GUID-9E69B512-F170-41AC-B9DF-FAC16E96E328.html",
							"GUID-9E69B512-F170-41AC-B9DF-FAC16E96E328.html",
							"GUID-9E69B512-F170-41AC-B9DF-FAC16E96E328.html",
							"GUID-9E69B512-F170-41AC-B9DF-FAC16E96E328.html",
							"GUID-330C0837-76DB-4EB8-BEC6-D8AF93FD8585.html",
							"GUID-330C0837-76DB-4EB8-BEC6-D8AF93FD8585.html",
							"GUID-330C0837-76DB-4EB8-BEC6-D8AF93FD8585.html",
							"GUID-330C0837-76DB-4EB8-BEC6-D8AF93FD8585.html",
							"GUID-330C0837-76DB-4EB8-BEC6-D8AF93FD8585.html",
							"GUID-330C0837-76DB-4EB8-BEC6-D8AF93FD8585.html",
							"GUID-330C0837-76DB-4EB8-BEC6-D8AF93FD8585.html",
							"GUID-330C0837-76DB-4EB8-BEC6-D8AF93FD8585.html",
							"GUID-330C0837-76DB-4EB8-BEC6-D8AF93FD8585.html",
							"GUID-48077C08-77AF-471F-8D5A-2A8446076075.html",
							"GUID-48077C08-77AF-471F-8D5A-2A8446076075.html",
							"GUID-48077C08-77AF-471F-8D5A-2A8446076075.html",
							"GUID-48077C08-77AF-471F-8D5A-2A8446076075.html",
							"GUID-48077C08-77AF-471F-8D5A-2A8446076075.html",
							"GUID-48077C08-77AF-471F-8D5A-2A8446076075.html",
							"GUID-48077C08-77AF-471F-8D5A-2A8446076075.html",
							"GUID-48077C08-77AF-471F-8D5A-2A8446076075.html",
							"GUID-48077C08-77AF-471F-8D5A-2A8446076075.html",
							"GUID-EC85344A-BA42-4455-9AA7-1A082E81D022.html",
							"GUID-EC85344A-BA42-4455-9AA7-1A082E81D022.html",
							"GUID-EC85344A-BA42-4455-9AA7-1A082E81D022.html",
							"GUID-EC85344A-BA42-4455-9AA7-1A082E81D022.html",
							"GUID-EC85344A-BA42-4455-9AA7-1A082E81D022.html",
							"GUID-EC85344A-BA42-4455-9AA7-1A082E81D022.html",
							"GUID-EC85344A-BA42-4455-9AA7-1A082E81D022.html",
							"GUID-EC85344A-BA42-4455-9AA7-1A082E81D022.html",
							"GUID-EC85344A-BA42-4455-9AA7-1A082E81D022.html",
							"GUID-5F20B2E6-93C6-4994-BACC-0D05E6EE447C.html",
							"GUID-5F20B2E6-93C6-4994-BACC-0D05E6EE447C.html",
							"GUID-5F20B2E6-93C6-4994-BACC-0D05E6EE447C.html",
							"GUID-5F20B2E6-93C6-4994-BACC-0D05E6EE447C.html",
							"GUID-5F20B2E6-93C6-4994-BACC-0D05E6EE447C.html",
							"GUID-5F20B2E6-93C6-4994-BACC-0D05E6EE447C.html",
							"GUID-5F20B2E6-93C6-4994-BACC-0D05E6EE447C.html",
							"GUID-5F20B2E6-93C6-4994-BACC-0D05E6EE447C.html",
							"GUID-5F20B2E6-93C6-4994-BACC-0D05E6EE447C.html",
							"GUID-982C8155-5325-4FD0-8561-DC58CEC444AA.html",
							"GUID-982C8155-5325-4FD0-8561-DC58CEC444AA.html",
							"GUID-982C8155-5325-4FD0-8561-DC58CEC444AA.html",
							"GUID-982C8155-5325-4FD0-8561-DC58CEC444AA.html",
							"GUID-982C8155-5325-4FD0-8561-DC58CEC444AA.html",
							"GUID-982C8155-5325-4FD0-8561-DC58CEC444AA.html",
							"GUID-982C8155-5325-4FD0-8561-DC58CEC444AA.html",
							"GUID-982C8155-5325-4FD0-8561-DC58CEC444AA.html",
							"GUID-982C8155-5325-4FD0-8561-DC58CEC444AA.html",
							"GUID-C79A452D-863F-400E-9215-8328F434341F.html",
							"GUID-C79A452D-863F-400E-9215-8328F434341F.html",
							"GUID-C79A452D-863F-400E-9215-8328F434341F.html",
							"GUID-C79A452D-863F-400E-9215-8328F434341F.html",
							"GUID-C79A452D-863F-400E-9215-8328F434341F.html",
							"GUID-C79A452D-863F-400E-9215-8328F434341F.html",
							"GUID-C79A452D-863F-400E-9215-8328F434341F.html",
							"GUID-C79A452D-863F-400E-9215-8328F434341F.html",
							"GUID-C79A452D-863F-400E-9215-8328F434341F.html",
							"GUID-74B6D228-7F2F-494B-9E28-60CD4E961697.html",
							"GUID-74B6D228-7F2F-494B-9E28-60CD4E961697.html",
							"GUID-74B6D228-7F2F-494B-9E28-60CD4E961697.html",
							"GUID-74B6D228-7F2F-494B-9E28-60CD4E961697.html",
							"GUID-74B6D228-7F2F-494B-9E28-60CD4E961697.html",
							"GUID-74B6D228-7F2F-494B-9E28-60CD4E961697.html",
							"GUID-74B6D228-7F2F-494B-9E28-60CD4E961697.html",
							"GUID-74B6D228-7F2F-494B-9E28-60CD4E961697.html",
							"GUID-74B6D228-7F2F-494B-9E28-60CD4E961697.html",
							"GUID-ABF27578-8112-4353-A8F0-53C418DD1D29.html",
							"GUID-ABF27578-8112-4353-A8F0-53C418DD1D29.html",
							"GUID-ABF27578-8112-4353-A8F0-53C418DD1D29.html",
							"GUID-ABF27578-8112-4353-A8F0-53C418DD1D29.html",
							"GUID-ABF27578-8112-4353-A8F0-53C418DD1D29.html",
							"GUID-ABF27578-8112-4353-A8F0-53C418DD1D29.html",
							"GUID-ABF27578-8112-4353-A8F0-53C418DD1D29.html",
							"GUID-ABF27578-8112-4353-A8F0-53C418DD1D29.html",
							"GUID-ABF27578-8112-4353-A8F0-53C418DD1D29.html",
							"GUID-B89FEC68-34D5-4B7B-9EEB-ABB7C05A7564.html",
							"GUID-B89FEC68-34D5-4B7B-9EEB-ABB7C05A7564.html",
							"GUID-B89FEC68-34D5-4B7B-9EEB-ABB7C05A7564.html",
							"GUID-B89FEC68-34D5-4B7B-9EEB-ABB7C05A7564.html",
							"GUID-B89FEC68-34D5-4B7B-9EEB-ABB7C05A7564.html",
							"GUID-B89FEC68-34D5-4B7B-9EEB-ABB7C05A7564.html",
							"GUID-B89FEC68-34D5-4B7B-9EEB-ABB7C05A7564.html",
							"GUID-B89FEC68-34D5-4B7B-9EEB-ABB7C05A7564.html",
							"GUID-B89FEC68-34D5-4B7B-9EEB-ABB7C05A7564.html",
							"GUID-356655BC-8897-4D93-B120-F758874C9AE8.html",
							"GUID-356655BC-8897-4D93-B120-F758874C9AE8.html",
							"GUID-356655BC-8897-4D93-B120-F758874C9AE8.html",
							"GUID-356655BC-8897-4D93-B120-F758874C9AE8.html",
							"GUID-356655BC-8897-4D93-B120-F758874C9AE8.html",
							"GUID-356655BC-8897-4D93-B120-F758874C9AE8.html",
							"GUID-356655BC-8897-4D93-B120-F758874C9AE8.html",
							"GUID-356655BC-8897-4D93-B120-F758874C9AE8.html",
							"GUID-356655BC-8897-4D93-B120-F758874C9AE8.html",
							"GUID-2CF46A98-9137-4819-8C1C-83621B96CA1E.html",
							"GUID-2CF46A98-9137-4819-8C1C-83621B96CA1E.html",
							"GUID-2CF46A98-9137-4819-8C1C-83621B96CA1E.html",
							"GUID-2CF46A98-9137-4819-8C1C-83621B96CA1E.html",
							"GUID-2CF46A98-9137-4819-8C1C-83621B96CA1E.html",
							"GUID-2CF46A98-9137-4819-8C1C-83621B96CA1E.html",
							"GUID-2CF46A98-9137-4819-8C1C-83621B96CA1E.html",
							"GUID-2CF46A98-9137-4819-8C1C-83621B96CA1E.html",
							"GUID-2CF46A98-9137-4819-8C1C-83621B96CA1E.html",
							"GUID-E1F34AEE-713B-4368-BC6B-637E527BFF6B.html",
							"GUID-E1F34AEE-713B-4368-BC6B-637E527BFF6B.html",
							"GUID-E1F34AEE-713B-4368-BC6B-637E527BFF6B.html",
							"GUID-E1F34AEE-713B-4368-BC6B-637E527BFF6B.html",
							"GUID-E1F34AEE-713B-4368-BC6B-637E527BFF6B.html",
							"GUID-E1F34AEE-713B-4368-BC6B-637E527BFF6B.html",
							"GUID-E1F34AEE-713B-4368-BC6B-637E527BFF6B.html",
							"GUID-E1F34AEE-713B-4368-BC6B-637E527BFF6B.html",
							"GUID-E1F34AEE-713B-4368-BC6B-637E527BFF6B.html",
							"GUID-09F65940-7D05-4F78-81C9-6356B65DEF21.html",
							"GUID-AB133EBE-D69A-48C3-BF6E-111E569747E0.html",
							"GUID-8E82118C-F2B8-4394-A0C1-4E838387C179.html",
							"GUID-61A204D5-4020-4A31-BC5F-833D079A2436.html",
							"GUID-F1DBA6FA-9373-4832-9CD9-BDC0B227003B.html",
							"GUID-FEBFF6DB-5F57-4360-90BF-E9DA46037C99.html",
							"GUID-FEBFF6DB-5F57-4360-90BF-E9DA46037C99.html",
							"GUID-FEBFF6DB-5F57-4360-90BF-E9DA46037C99.html",
							"GUID-FEBFF6DB-5F57-4360-90BF-E9DA46037C99.html",
							"GUID-FEBFF6DB-5F57-4360-90BF-E9DA46037C99.html",
							"GUID-FEBFF6DB-5F57-4360-90BF-E9DA46037C99.html",
							"GUID-FEBFF6DB-5F57-4360-90BF-E9DA46037C99.html",
							"GUID-FEBFF6DB-5F57-4360-90BF-E9DA46037C99.html",
							"GUID-26B2DB3A-8817-401C-8EA1-BA288827F83C.html",
							"GUID-26B2DB3A-8817-401C-8EA1-BA288827F83C.html",
							"GUID-26B2DB3A-8817-401C-8EA1-BA288827F83C.html",
							"GUID-26B2DB3A-8817-401C-8EA1-BA288827F83C.html",
							"GUID-26B2DB3A-8817-401C-8EA1-BA288827F83C.html",
							"GUID-26B2DB3A-8817-401C-8EA1-BA288827F83C.html",
							"GUID-26B2DB3A-8817-401C-8EA1-BA288827F83C.html",
							"GUID-26B2DB3A-8817-401C-8EA1-BA288827F83C.html",
							"GUID-26B2DB3A-8817-401C-8EA1-BA288827F83C.html",
							"GUID-ED55865F-5F73-4D1C-A894-6A26F9893190.html",
							"GUID-ED55865F-5F73-4D1C-A894-6A26F9893190.html",
							"GUID-ED55865F-5F73-4D1C-A894-6A26F9893190.html",
							"GUID-ED55865F-5F73-4D1C-A894-6A26F9893190.html",
							"GUID-ED55865F-5F73-4D1C-A894-6A26F9893190.html",
							"GUID-ED55865F-5F73-4D1C-A894-6A26F9893190.html",
							"GUID-ED55865F-5F73-4D1C-A894-6A26F9893190.html",
							"GUID-ED55865F-5F73-4D1C-A894-6A26F9893190.html",
							"GUID-05239B51-F3DC-495F-A373-057A692D1CE2.html",
							"GUID-05239B51-F3DC-495F-A373-057A692D1CE2.html",
							"GUID-05239B51-F3DC-495F-A373-057A692D1CE2.html",
							"GUID-05239B51-F3DC-495F-A373-057A692D1CE2.html",
							"GUID-05239B51-F3DC-495F-A373-057A692D1CE2.html",
							"GUID-05239B51-F3DC-495F-A373-057A692D1CE2.html",
							"GUID-05239B51-F3DC-495F-A373-057A692D1CE2.html",
							"GUID-05239B51-F3DC-495F-A373-057A692D1CE2.html",
							"GUID-45D2280C-63E4-48FA-ABAD-450459998A8F.html",
							"GUID-45D2280C-63E4-48FA-ABAD-450459998A8F.html",
							"GUID-45D2280C-63E4-48FA-ABAD-450459998A8F.html",
							"GUID-45D2280C-63E4-48FA-ABAD-450459998A8F.html",
							"GUID-45D2280C-63E4-48FA-ABAD-450459998A8F.html",
							"GUID-45D2280C-63E4-48FA-ABAD-450459998A8F.html",
							"GUID-45D2280C-63E4-48FA-ABAD-450459998A8F.html",
							"GUID-45D2280C-63E4-48FA-ABAD-450459998A8F.html",
							"GUID-EDAB3999-3E03-4C0B-94B6-066DE78EE636.html",
							"GUID-EDAB3999-3E03-4C0B-94B6-066DE78EE636.html",
							"GUID-EDAB3999-3E03-4C0B-94B6-066DE78EE636.html",
							"GUID-EDAB3999-3E03-4C0B-94B6-066DE78EE636.html",
							"GUID-EDAB3999-3E03-4C0B-94B6-066DE78EE636.html",
							"GUID-EDAB3999-3E03-4C0B-94B6-066DE78EE636.html",
							"GUID-EDAB3999-3E03-4C0B-94B6-066DE78EE636.html",
							"GUID-EDAB3999-3E03-4C0B-94B6-066DE78EE636.html",
							"GUID-A4CE28DC-40B2-43C2-949E-69ABD5EFB2DC.html",
							"GUID-A4CE28DC-40B2-43C2-949E-69ABD5EFB2DC.html",
							"GUID-A4CE28DC-40B2-43C2-949E-69ABD5EFB2DC.html",
							"GUID-A4CE28DC-40B2-43C2-949E-69ABD5EFB2DC.html",
							"GUID-A4CE28DC-40B2-43C2-949E-69ABD5EFB2DC.html",
							"GUID-A4CE28DC-40B2-43C2-949E-69ABD5EFB2DC.html",
							"GUID-A4CE28DC-40B2-43C2-949E-69ABD5EFB2DC.html",
							"GUID-A4CE28DC-40B2-43C2-949E-69ABD5EFB2DC.html",
							"GUID-02B7E5B7-DE83-434E-B5A3-9428923F2D83.html",
							"GUID-02B7E5B7-DE83-434E-B5A3-9428923F2D83.html",
							"GUID-02B7E5B7-DE83-434E-B5A3-9428923F2D83.html",
							"GUID-02B7E5B7-DE83-434E-B5A3-9428923F2D83.html",
							"GUID-02B7E5B7-DE83-434E-B5A3-9428923F2D83.html",
							"GUID-02B7E5B7-DE83-434E-B5A3-9428923F2D83.html",
							"GUID-02B7E5B7-DE83-434E-B5A3-9428923F2D83.html",
							"GUID-02B7E5B7-DE83-434E-B5A3-9428923F2D83.html",
							"GUID-3E6B809F-7256-4348-9596-7F338CC62EC5.html",
							"GUID-3E6B809F-7256-4348-9596-7F338CC62EC5.html",
							"GUID-3E6B809F-7256-4348-9596-7F338CC62EC5.html",
							"GUID-3E6B809F-7256-4348-9596-7F338CC62EC5.html",
							"GUID-3E6B809F-7256-4348-9596-7F338CC62EC5.html",
							"GUID-3E6B809F-7256-4348-9596-7F338CC62EC5.html",
							"GUID-3E6B809F-7256-4348-9596-7F338CC62EC5.html",
							"GUID-3E6B809F-7256-4348-9596-7F338CC62EC5.html",
							"GUID-6979BCB1-F38B-455E-AFBB-FD2A09A823B4.html",
							"GUID-6979BCB1-F38B-455E-AFBB-FD2A09A823B4.html",
							"GUID-6979BCB1-F38B-455E-AFBB-FD2A09A823B4.html",
							"GUID-6979BCB1-F38B-455E-AFBB-FD2A09A823B4.html",
							"GUID-6979BCB1-F38B-455E-AFBB-FD2A09A823B4.html",
							"GUID-6979BCB1-F38B-455E-AFBB-FD2A09A823B4.html",
							"GUID-6979BCB1-F38B-455E-AFBB-FD2A09A823B4.html",
							"GUID-6979BCB1-F38B-455E-AFBB-FD2A09A823B4.html",
							"GUID-9A80603D-1A4B-4313-8D69-3C7F8E0CDDF0.html",
							"GUID-9A80603D-1A4B-4313-8D69-3C7F8E0CDDF0.html",
							"GUID-9A80603D-1A4B-4313-8D69-3C7F8E0CDDF0.html",
							"GUID-9A80603D-1A4B-4313-8D69-3C7F8E0CDDF0.html",
							"GUID-9A80603D-1A4B-4313-8D69-3C7F8E0CDDF0.html",
							"GUID-B6686A00-4544-4CFB-9F3C-9184AD2E0FDD.html",
							"GUID-B6686A00-4544-4CFB-9F3C-9184AD2E0FDD.html",
							"GUID-B6686A00-4544-4CFB-9F3C-9184AD2E0FDD.html",
							"GUID-B6686A00-4544-4CFB-9F3C-9184AD2E0FDD.html",
							"GUID-B6686A00-4544-4CFB-9F3C-9184AD2E0FDD.html",
							"GUID-918C3149-0EB2-4501-A80D-24BB98E67B5D.html",
							"GUID-918C3149-0EB2-4501-A80D-24BB98E67B5D.html",
							"GUID-918C3149-0EB2-4501-A80D-24BB98E67B5D.html",
							"GUID-918C3149-0EB2-4501-A80D-24BB98E67B5D.html",
							"GUID-918C3149-0EB2-4501-A80D-24BB98E67B5D.html",
							"GUID-BBAD84DF-1379-41FE-8BE1-9009BDC368AF.html",
							"GUID-BBAD84DF-1379-41FE-8BE1-9009BDC368AF.html",
							"GUID-BBAD84DF-1379-41FE-8BE1-9009BDC368AF.html",
							"GUID-BBAD84DF-1379-41FE-8BE1-9009BDC368AF.html",
							"GUID-BBAD84DF-1379-41FE-8BE1-9009BDC368AF.html",
							"GUID-740C7410-8069-4335-BB33-218D8F8B59F5.html",
							"GUID-740C7410-8069-4335-BB33-218D8F8B59F5.html",
							"GUID-740C7410-8069-4335-BB33-218D8F8B59F5.html",
							"GUID-740C7410-8069-4335-BB33-218D8F8B59F5.html",
							"GUID-740C7410-8069-4335-BB33-218D8F8B59F5.html",
							"GUID-FA0DA23C-BCD9-405F-8CC1-C7AE98205FC3.html",
							"GUID-FA0DA23C-BCD9-405F-8CC1-C7AE98205FC3.html",
							"GUID-FA0DA23C-BCD9-405F-8CC1-C7AE98205FC3.html",
							"GUID-FA0DA23C-BCD9-405F-8CC1-C7AE98205FC3.html",
							"GUID-FA0DA23C-BCD9-405F-8CC1-C7AE98205FC3.html",
							"GUID-1ACA0CDE-BB29-4A7F-AF3D-5461ECE86944.html",
							"GUID-1ACA0CDE-BB29-4A7F-AF3D-5461ECE86944.html",
							"GUID-1ACA0CDE-BB29-4A7F-AF3D-5461ECE86944.html",
							"GUID-1ACA0CDE-BB29-4A7F-AF3D-5461ECE86944.html",
							"GUID-1ACA0CDE-BB29-4A7F-AF3D-5461ECE86944.html",
							"GUID-B51DDD56-C465-4676-816B-85FFEE48544C.html",
							"GUID-B51DDD56-C465-4676-816B-85FFEE48544C.html",
							"GUID-B51DDD56-C465-4676-816B-85FFEE48544C.html",
							"GUID-B51DDD56-C465-4676-816B-85FFEE48544C.html",
							"GUID-B51DDD56-C465-4676-816B-85FFEE48544C.html",
							"GUID-51492B75-94E3-4BCE-960D-013CB51A2E19.html",
							"GUID-51492B75-94E3-4BCE-960D-013CB51A2E19.html",
							"GUID-51492B75-94E3-4BCE-960D-013CB51A2E19.html",
							"GUID-51492B75-94E3-4BCE-960D-013CB51A2E19.html",
							"GUID-51492B75-94E3-4BCE-960D-013CB51A2E19.html",
							"GUID-8BCDA47F-4CBC-4405-9F30-4A44B7DE67F3.html",
							"GUID-8BCDA47F-4CBC-4405-9F30-4A44B7DE67F3.html",
							"GUID-8BCDA47F-4CBC-4405-9F30-4A44B7DE67F3.html",
							"GUID-8BCDA47F-4CBC-4405-9F30-4A44B7DE67F3.html",
							"GUID-8BCDA47F-4CBC-4405-9F30-4A44B7DE67F3.html",
							"GUID-43DF0480-B8AC-4060-B932-0BF78B41CE23.html",
							"GUID-43DF0480-B8AC-4060-B932-0BF78B41CE23.html",
							"GUID-43DF0480-B8AC-4060-B932-0BF78B41CE23.html",
							"GUID-43DF0480-B8AC-4060-B932-0BF78B41CE23.html",
							"GUID-43DF0480-B8AC-4060-B932-0BF78B41CE23.html",
							"GUID-28219199-6917-43CE-A9D3-0C84F4017C28.html",
							"GUID-28219199-6917-43CE-A9D3-0C84F4017C28.html",
							"GUID-28219199-6917-43CE-A9D3-0C84F4017C28.html",
							"GUID-28219199-6917-43CE-A9D3-0C84F4017C28.html",
							"GUID-28219199-6917-43CE-A9D3-0C84F4017C28.html",
							"GUID-001CDE12-2461-42F4-8F72-783C6EB738D4.html",
							"GUID-001CDE12-2461-42F4-8F72-783C6EB738D4.html",
							"GUID-001CDE12-2461-42F4-8F72-783C6EB738D4.html",
							"GUID-001CDE12-2461-42F4-8F72-783C6EB738D4.html",
							"GUID-001CDE12-2461-42F4-8F72-783C6EB738D4.html",
							"GUID-3ABD051F-AA97-4C40-942D-EFC6A16486B8.html",
							"GUID-3ABD051F-AA97-4C40-942D-EFC6A16486B8.html",
							"GUID-3ABD051F-AA97-4C40-942D-EFC6A16486B8.html",
							"GUID-3ABD051F-AA97-4C40-942D-EFC6A16486B8.html",
							"GUID-3ABD051F-AA97-4C40-942D-EFC6A16486B8.html",
							"GUID-4F58DE9B-B3EE-4108-9290-15F90CC32FB0.html",
							"GUID-4F58DE9B-B3EE-4108-9290-15F90CC32FB0.html",
							"GUID-4F58DE9B-B3EE-4108-9290-15F90CC32FB0.html",
							"GUID-4F58DE9B-B3EE-4108-9290-15F90CC32FB0.html",
							"GUID-4F58DE9B-B3EE-4108-9290-15F90CC32FB0.html",
							"GUID-F6B65A05-37EC-4CCF-AFC3-0EC2EA264CDB.html",
							"GUID-F6B65A05-37EC-4CCF-AFC3-0EC2EA264CDB.html",
							"GUID-F6B65A05-37EC-4CCF-AFC3-0EC2EA264CDB.html",
							"GUID-F6B65A05-37EC-4CCF-AFC3-0EC2EA264CDB.html",
							"GUID-F6B65A05-37EC-4CCF-AFC3-0EC2EA264CDB.html",
							"GUID-85B8324A-FF53-4CBB-B687-C6BCE047FEDC.html",
							"GUID-85B8324A-FF53-4CBB-B687-C6BCE047FEDC.html",
							"GUID-85B8324A-FF53-4CBB-B687-C6BCE047FEDC.html",
							"GUID-85B8324A-FF53-4CBB-B687-C6BCE047FEDC.html",
							"GUID-85B8324A-FF53-4CBB-B687-C6BCE047FEDC.html",
							"GUID-827592EF-BDE9-4229-9A95-E2F6E8E55AF2.html",
							"GUID-827592EF-BDE9-4229-9A95-E2F6E8E55AF2.html",
							"GUID-827592EF-BDE9-4229-9A95-E2F6E8E55AF2.html",
							"GUID-827592EF-BDE9-4229-9A95-E2F6E8E55AF2.html",
							"GUID-827592EF-BDE9-4229-9A95-E2F6E8E55AF2.html",
							"GUID-C8EFF72A-1BBB-416E-BF89-EEA2B23EB27D.html",
							"GUID-177E8C6B-6F6F-4E94-9096-38134597D79A.html",
							"GUID-B286925F-9A1D-4048-BC76-8CAB686D63AB.html",
							"GUID-99A3B7AF-E05E-4946-BBAD-4A4056FC1B7B.html",
							"GUID-4923B60C-900F-4BB5-91B7-CE4CA6ED4059.html",
							"GUID-0FB267B9-32FD-4D45-A895-A284C189AB9F.html",
							"GUID-0FB267B9-32FD-4D45-A895-A284C189AB9F.html",
							"GUID-0FB267B9-32FD-4D45-A895-A284C189AB9F.html",
							"GUID-0FB267B9-32FD-4D45-A895-A284C189AB9F.html",
							"GUID-0FB267B9-32FD-4D45-A895-A284C189AB9F.html",
							"GUID-0FB267B9-32FD-4D45-A895-A284C189AB9F.html",
							"GUID-0FB267B9-32FD-4D45-A895-A284C189AB9F.html",
							"GUID-0FB267B9-32FD-4D45-A895-A284C189AB9F.html",
							"GUID-0FB267B9-32FD-4D45-A895-A284C189AB9F.html",
							"GUID-845C87B6-AE82-45D3-9BB1-5DF91145603C.html",
							"GUID-845C87B6-AE82-45D3-9BB1-5DF91145603C.html",
							"GUID-845C87B6-AE82-45D3-9BB1-5DF91145603C.html",
							"GUID-845C87B6-AE82-45D3-9BB1-5DF91145603C.html",
							"GUID-845C87B6-AE82-45D3-9BB1-5DF91145603C.html",
							"GUID-845C87B6-AE82-45D3-9BB1-5DF91145603C.html",
							"GUID-845C87B6-AE82-45D3-9BB1-5DF91145603C.html",
							"GUID-845C87B6-AE82-45D3-9BB1-5DF91145603C.html",
							"GUID-845C87B6-AE82-45D3-9BB1-5DF91145603C.html",
							"GUID-93CC4026-5646-46CB-B6E3-46FB102A7564.html",
							"GUID-93CC4026-5646-46CB-B6E3-46FB102A7564.html",
							"GUID-93CC4026-5646-46CB-B6E3-46FB102A7564.html",
							"GUID-93CC4026-5646-46CB-B6E3-46FB102A7564.html",
							"GUID-93CC4026-5646-46CB-B6E3-46FB102A7564.html",
							"GUID-93CC4026-5646-46CB-B6E3-46FB102A7564.html",
							"GUID-93CC4026-5646-46CB-B6E3-46FB102A7564.html",
							"GUID-93CC4026-5646-46CB-B6E3-46FB102A7564.html",
							"GUID-93CC4026-5646-46CB-B6E3-46FB102A7564.html",
							"GUID-C458B680-BC60-4AC1-9DDA-9387192366CB.html",
							"GUID-C458B680-BC60-4AC1-9DDA-9387192366CB.html",
							"GUID-C458B680-BC60-4AC1-9DDA-9387192366CB.html",
							"GUID-C458B680-BC60-4AC1-9DDA-9387192366CB.html",
							"GUID-C458B680-BC60-4AC1-9DDA-9387192366CB.html",
							"GUID-C458B680-BC60-4AC1-9DDA-9387192366CB.html",
							"GUID-C458B680-BC60-4AC1-9DDA-9387192366CB.html",
							"GUID-C458B680-BC60-4AC1-9DDA-9387192366CB.html",
							"GUID-C458B680-BC60-4AC1-9DDA-9387192366CB.html",
							"GUID-FB04B0D6-2FE7-4B11-A4F1-74315F7903E1.html",
							"GUID-FB04B0D6-2FE7-4B11-A4F1-74315F7903E1.html",
							"GUID-FB04B0D6-2FE7-4B11-A4F1-74315F7903E1.html",
							"GUID-FB04B0D6-2FE7-4B11-A4F1-74315F7903E1.html",
							"GUID-FB04B0D6-2FE7-4B11-A4F1-74315F7903E1.html",
							"GUID-FB04B0D6-2FE7-4B11-A4F1-74315F7903E1.html",
							"GUID-FB04B0D6-2FE7-4B11-A4F1-74315F7903E1.html",
							"GUID-FB04B0D6-2FE7-4B11-A4F1-74315F7903E1.html",
							"GUID-FB04B0D6-2FE7-4B11-A4F1-74315F7903E1.html",
							"GUID-4EA548CC-CB9A-4A43-84C2-8B6959E1D2C2.html",
							"GUID-4EA548CC-CB9A-4A43-84C2-8B6959E1D2C2.html",
							"GUID-4EA548CC-CB9A-4A43-84C2-8B6959E1D2C2.html",
							"GUID-4EA548CC-CB9A-4A43-84C2-8B6959E1D2C2.html",
							"GUID-4EA548CC-CB9A-4A43-84C2-8B6959E1D2C2.html",
							"GUID-4EA548CC-CB9A-4A43-84C2-8B6959E1D2C2.html",
							"GUID-4EA548CC-CB9A-4A43-84C2-8B6959E1D2C2.html",
							"GUID-4EA548CC-CB9A-4A43-84C2-8B6959E1D2C2.html",
							"GUID-4EA548CC-CB9A-4A43-84C2-8B6959E1D2C2.html",
							"GUID-5EFE7E35-46E2-4C26-9C50-DE5060B4EAE9.html",
							"GUID-5EFE7E35-46E2-4C26-9C50-DE5060B4EAE9.html",
							"GUID-5EFE7E35-46E2-4C26-9C50-DE5060B4EAE9.html",
							"GUID-5EFE7E35-46E2-4C26-9C50-DE5060B4EAE9.html",
							"GUID-5EFE7E35-46E2-4C26-9C50-DE5060B4EAE9.html",
							"GUID-5EFE7E35-46E2-4C26-9C50-DE5060B4EAE9.html",
							"GUID-5EFE7E35-46E2-4C26-9C50-DE5060B4EAE9.html",
							"GUID-5EFE7E35-46E2-4C26-9C50-DE5060B4EAE9.html",
							"GUID-5EFE7E35-46E2-4C26-9C50-DE5060B4EAE9.html",
							"GUID-1C2EEC70-0494-4010-805F-29CE86ED81F6.html",
							"GUID-1C2EEC70-0494-4010-805F-29CE86ED81F6.html",
							"GUID-1C2EEC70-0494-4010-805F-29CE86ED81F6.html",
							"GUID-1C2EEC70-0494-4010-805F-29CE86ED81F6.html",
							"GUID-1C2EEC70-0494-4010-805F-29CE86ED81F6.html",
							"GUID-1C2EEC70-0494-4010-805F-29CE86ED81F6.html",
							"GUID-1C2EEC70-0494-4010-805F-29CE86ED81F6.html",
							"GUID-1C2EEC70-0494-4010-805F-29CE86ED81F6.html",
							"GUID-1C2EEC70-0494-4010-805F-29CE86ED81F6.html",
							"GUID-5CAC0494-62DF-4529-9231-843B4D6065F9.html",
							"GUID-5CAC0494-62DF-4529-9231-843B4D6065F9.html",
							"GUID-5CAC0494-62DF-4529-9231-843B4D6065F9.html",
							"GUID-5CAC0494-62DF-4529-9231-843B4D6065F9.html",
							"GUID-5CAC0494-62DF-4529-9231-843B4D6065F9.html",
							"GUID-5CAC0494-62DF-4529-9231-843B4D6065F9.html",
							"GUID-5CAC0494-62DF-4529-9231-843B4D6065F9.html",
							"GUID-5CAC0494-62DF-4529-9231-843B4D6065F9.html",
							"GUID-5CAC0494-62DF-4529-9231-843B4D6065F9.html",
							"GUID-B0268879-D0F1-41E8-A644-2254FF79F38B.html",
							"GUID-B0268879-D0F1-41E8-A644-2254FF79F38B.html",
							"GUID-B0268879-D0F1-41E8-A644-2254FF79F38B.html",
							"GUID-B0268879-D0F1-41E8-A644-2254FF79F38B.html",
							"GUID-B0268879-D0F1-41E8-A644-2254FF79F38B.html",
							"GUID-B0268879-D0F1-41E8-A644-2254FF79F38B.html",
							"GUID-B0268879-D0F1-41E8-A644-2254FF79F38B.html",
							"GUID-B0268879-D0F1-41E8-A644-2254FF79F38B.html",
							"GUID-B0268879-D0F1-41E8-A644-2254FF79F38B.html",
							"GUID-23DDD2ED-C0F6-44CB-9826-9592AF32085C.html",
							"GUID-23DDD2ED-C0F6-44CB-9826-9592AF32085C.html",
							"GUID-23DDD2ED-C0F6-44CB-9826-9592AF32085C.html",
							"GUID-23DDD2ED-C0F6-44CB-9826-9592AF32085C.html",
							"GUID-23DDD2ED-C0F6-44CB-9826-9592AF32085C.html",
							"GUID-23DDD2ED-C0F6-44CB-9826-9592AF32085C.html",
							"GUID-23DDD2ED-C0F6-44CB-9826-9592AF32085C.html",
							"GUID-23DDD2ED-C0F6-44CB-9826-9592AF32085C.html",
							"GUID-23DDD2ED-C0F6-44CB-9826-9592AF32085C.html",
							"GUID-AA145CB2-4D8E-4544-AFF0-BFE413A0541B.html",
							"GUID-AA145CB2-4D8E-4544-AFF0-BFE413A0541B.html",
							"GUID-AA145CB2-4D8E-4544-AFF0-BFE413A0541B.html",
							"GUID-AA145CB2-4D8E-4544-AFF0-BFE413A0541B.html",
							"GUID-AA145CB2-4D8E-4544-AFF0-BFE413A0541B.html",
							"GUID-AA145CB2-4D8E-4544-AFF0-BFE413A0541B.html",
							"GUID-AA145CB2-4D8E-4544-AFF0-BFE413A0541B.html",
							"GUID-AA145CB2-4D8E-4544-AFF0-BFE413A0541B.html",
							"GUID-AA145CB2-4D8E-4544-AFF0-BFE413A0541B.html",
							"GUID-9BE0BEAA-AEED-4E5D-801F-2337B8788572.html",
							"GUID-9BE0BEAA-AEED-4E5D-801F-2337B8788572.html",
							"GUID-9BE0BEAA-AEED-4E5D-801F-2337B8788572.html",
							"GUID-9BE0BEAA-AEED-4E5D-801F-2337B8788572.html",
							"GUID-9BE0BEAA-AEED-4E5D-801F-2337B8788572.html",
							"GUID-9BE0BEAA-AEED-4E5D-801F-2337B8788572.html",
							"GUID-9BE0BEAA-AEED-4E5D-801F-2337B8788572.html",
							"GUID-9BE0BEAA-AEED-4E5D-801F-2337B8788572.html",
							"GUID-9BE0BEAA-AEED-4E5D-801F-2337B8788572.html",
							"GUID-C1E2C64B-0256-4FCA-AF76-172C90385781.html",
							"GUID-C1E2C64B-0256-4FCA-AF76-172C90385781.html",
							"GUID-C1E2C64B-0256-4FCA-AF76-172C90385781.html",
							"GUID-C1E2C64B-0256-4FCA-AF76-172C90385781.html",
							"GUID-C1E2C64B-0256-4FCA-AF76-172C90385781.html",
							"GUID-C1E2C64B-0256-4FCA-AF76-172C90385781.html",
							"GUID-C1E2C64B-0256-4FCA-AF76-172C90385781.html",
							"GUID-C1E2C64B-0256-4FCA-AF76-172C90385781.html",
							"GUID-C1E2C64B-0256-4FCA-AF76-172C90385781.html",
							"GUID-A91D370A-60F4-439F-BDBA-FF4FF0851094.html",
							"GUID-A91D370A-60F4-439F-BDBA-FF4FF0851094.html",
							"GUID-A91D370A-60F4-439F-BDBA-FF4FF0851094.html",
							"GUID-A91D370A-60F4-439F-BDBA-FF4FF0851094.html",
							"GUID-A91D370A-60F4-439F-BDBA-FF4FF0851094.html",
							"GUID-BDBC1881-1C1B-4940-B6E3-F1809C7155BB.html",
							"GUID-BDBC1881-1C1B-4940-B6E3-F1809C7155BB.html",
							"GUID-BDBC1881-1C1B-4940-B6E3-F1809C7155BB.html",
							"GUID-BDBC1881-1C1B-4940-B6E3-F1809C7155BB.html",
							"GUID-BDBC1881-1C1B-4940-B6E3-F1809C7155BB.html",
							"GUID-6C64A9ED-7259-4105-A1EC-2B2402B5642B.html",
							"GUID-6C64A9ED-7259-4105-A1EC-2B2402B5642B.html",
							"GUID-6C64A9ED-7259-4105-A1EC-2B2402B5642B.html",
							"GUID-6C64A9ED-7259-4105-A1EC-2B2402B5642B.html",
							"GUID-6C64A9ED-7259-4105-A1EC-2B2402B5642B.html",
							"GUID-9BDB404E-10C0-46C6-A3B0-9629D7D40676.html",
							"GUID-9BDB404E-10C0-46C6-A3B0-9629D7D40676.html",
							"GUID-9BDB404E-10C0-46C6-A3B0-9629D7D40676.html",
							"GUID-9BDB404E-10C0-46C6-A3B0-9629D7D40676.html",
							"GUID-9BDB404E-10C0-46C6-A3B0-9629D7D40676.html",
							"GUID-1766284D-BC74-461B-9977-A46B45EB363A.html",
							"GUID-1766284D-BC74-461B-9977-A46B45EB363A.html",
							"GUID-1766284D-BC74-461B-9977-A46B45EB363A.html",
							"GUID-1766284D-BC74-461B-9977-A46B45EB363A.html",
							"GUID-1766284D-BC74-461B-9977-A46B45EB363A.html",
							"GUID-CC66618A-5A79-4589-AACF-DE3D62A5927A.html",
							"GUID-CC66618A-5A79-4589-AACF-DE3D62A5927A.html",
							"GUID-CC66618A-5A79-4589-AACF-DE3D62A5927A.html",
							"GUID-CC66618A-5A79-4589-AACF-DE3D62A5927A.html",
							"GUID-CC66618A-5A79-4589-AACF-DE3D62A5927A.html",
							"GUID-716CB5D5-1AD3-4AFA-8985-E48322D8E932.html",
							"GUID-716CB5D5-1AD3-4AFA-8985-E48322D8E932.html",
							"GUID-716CB5D5-1AD3-4AFA-8985-E48322D8E932.html",
							"GUID-716CB5D5-1AD3-4AFA-8985-E48322D8E932.html",
							"GUID-716CB5D5-1AD3-4AFA-8985-E48322D8E932.html",
							"GUID-3FD036E5-3791-45BA-8881-2123D9BF8A6B.html",
							"GUID-3FD036E5-3791-45BA-8881-2123D9BF8A6B.html",
							"GUID-3FD036E5-3791-45BA-8881-2123D9BF8A6B.html",
							"GUID-3FD036E5-3791-45BA-8881-2123D9BF8A6B.html",
							"GUID-3FD036E5-3791-45BA-8881-2123D9BF8A6B.html",
							"GUID-4F625306-2206-49B1-8846-60C97E40A440.html",
							"GUID-9ED5FA0F-F914-42D0-BF74-13E0D582A9F8.html",
							"GUID-E9788681-9000-4E53-A353-6D8881F7A7D5.html",
							"GUID-964912DE-8855-4B0E-A42E-EE2F8CFC3FE1.html",
							"GUID-3CBAD06F-CC26-46CB-AF78-AE7790F210D6.html",
							"GUID-76AC2CF8-EF78-49D0-8123-4FBCCD8EFE2E.html",
							"GUID-76AC2CF8-EF78-49D0-8123-4FBCCD8EFE2E.html",
							"GUID-76AC2CF8-EF78-49D0-8123-4FBCCD8EFE2E.html",
							"GUID-76AC2CF8-EF78-49D0-8123-4FBCCD8EFE2E.html",
							"GUID-76AC2CF8-EF78-49D0-8123-4FBCCD8EFE2E.html",
							"GUID-76AC2CF8-EF78-49D0-8123-4FBCCD8EFE2E.html",
							"GUID-76AC2CF8-EF78-49D0-8123-4FBCCD8EFE2E.html",
							"GUID-76AC2CF8-EF78-49D0-8123-4FBCCD8EFE2E.html",
							"GUID-76AC2CF8-EF78-49D0-8123-4FBCCD8EFE2E.html",
							"GUID-0AAFE706-5859-4761-97D4-223C2EF91279.html",
							"GUID-0AAFE706-5859-4761-97D4-223C2EF91279.html",
							"GUID-0AAFE706-5859-4761-97D4-223C2EF91279.html",
							"GUID-0AAFE706-5859-4761-97D4-223C2EF91279.html",
							"GUID-0AAFE706-5859-4761-97D4-223C2EF91279.html",
							"GUID-0AAFE706-5859-4761-97D4-223C2EF91279.html",
							"GUID-0AAFE706-5859-4761-97D4-223C2EF91279.html",
							"GUID-0AAFE706-5859-4761-97D4-223C2EF91279.html",
							"GUID-0AAFE706-5859-4761-97D4-223C2EF91279.html",
							"GUID-090F979E-B329-47FA-B6CA-D7BE390EAB02.html",
							"GUID-090F979E-B329-47FA-B6CA-D7BE390EAB02.html",
							"GUID-090F979E-B329-47FA-B6CA-D7BE390EAB02.html",
							"GUID-090F979E-B329-47FA-B6CA-D7BE390EAB02.html",
							"GUID-090F979E-B329-47FA-B6CA-D7BE390EAB02.html",
							"GUID-090F979E-B329-47FA-B6CA-D7BE390EAB02.html",
							"GUID-090F979E-B329-47FA-B6CA-D7BE390EAB02.html",
							"GUID-090F979E-B329-47FA-B6CA-D7BE390EAB02.html",
							"GUID-090F979E-B329-47FA-B6CA-D7BE390EAB02.html",
							"GUID-01431AF2-8257-4F6A-8069-1B2CB1BD7B5D.html",
							"GUID-01431AF2-8257-4F6A-8069-1B2CB1BD7B5D.html",
							"GUID-01431AF2-8257-4F6A-8069-1B2CB1BD7B5D.html",
							"GUID-01431AF2-8257-4F6A-8069-1B2CB1BD7B5D.html",
							"GUID-01431AF2-8257-4F6A-8069-1B2CB1BD7B5D.html",
							"GUID-01431AF2-8257-4F6A-8069-1B2CB1BD7B5D.html",
							"GUID-01431AF2-8257-4F6A-8069-1B2CB1BD7B5D.html",
							"GUID-01431AF2-8257-4F6A-8069-1B2CB1BD7B5D.html",
							"GUID-01431AF2-8257-4F6A-8069-1B2CB1BD7B5D.html",
							"GUID-DD1D5912-45D3-4227-8720-01869BD15139.html",
							"GUID-DD1D5912-45D3-4227-8720-01869BD15139.html",
							"GUID-DD1D5912-45D3-4227-8720-01869BD15139.html",
							"GUID-DD1D5912-45D3-4227-8720-01869BD15139.html",
							"GUID-DD1D5912-45D3-4227-8720-01869BD15139.html",
							"GUID-DD1D5912-45D3-4227-8720-01869BD15139.html",
							"GUID-DD1D5912-45D3-4227-8720-01869BD15139.html",
							"GUID-DD1D5912-45D3-4227-8720-01869BD15139.html",
							"GUID-DD1D5912-45D3-4227-8720-01869BD15139.html",
							"GUID-E21F3B3B-3CAA-4C6B-8B66-56BF29565731.html",
							"GUID-E21F3B3B-3CAA-4C6B-8B66-56BF29565731.html",
							"GUID-E21F3B3B-3CAA-4C6B-8B66-56BF29565731.html",
							"GUID-E21F3B3B-3CAA-4C6B-8B66-56BF29565731.html",
							"GUID-E21F3B3B-3CAA-4C6B-8B66-56BF29565731.html",
							"GUID-E21F3B3B-3CAA-4C6B-8B66-56BF29565731.html",
							"GUID-E21F3B3B-3CAA-4C6B-8B66-56BF29565731.html",
							"GUID-E21F3B3B-3CAA-4C6B-8B66-56BF29565731.html",
							"GUID-E21F3B3B-3CAA-4C6B-8B66-56BF29565731.html",
							"GUID-BA771AE9-3E03-4F87-BE24-51D33B871898.html",
							"GUID-BA771AE9-3E03-4F87-BE24-51D33B871898.html",
							"GUID-BA771AE9-3E03-4F87-BE24-51D33B871898.html",
							"GUID-BA771AE9-3E03-4F87-BE24-51D33B871898.html",
							"GUID-BA771AE9-3E03-4F87-BE24-51D33B871898.html",
							"GUID-8E283F11-3204-43A3-86D5-10CF8066E03F.html",
							"GUID-8E283F11-3204-43A3-86D5-10CF8066E03F.html",
							"GUID-8E283F11-3204-43A3-86D5-10CF8066E03F.html",
							"GUID-8E283F11-3204-43A3-86D5-10CF8066E03F.html",
							"GUID-8E283F11-3204-43A3-86D5-10CF8066E03F.html",
							"GUID-09E87B48-98E8-49F7-BBBD-6C049105F75C.html",
							"GUID-09E87B48-98E8-49F7-BBBD-6C049105F75C.html",
							"GUID-09E87B48-98E8-49F7-BBBD-6C049105F75C.html",
							"GUID-09E87B48-98E8-49F7-BBBD-6C049105F75C.html",
							"GUID-09E87B48-98E8-49F7-BBBD-6C049105F75C.html",
							"GUID-09E87B48-98E8-49F7-BBBD-6C049105F75C.html",
							"GUID-09E87B48-98E8-49F7-BBBD-6C049105F75C.html",
							"GUID-09E87B48-98E8-49F7-BBBD-6C049105F75C.html",
							"GUID-09E87B48-98E8-49F7-BBBD-6C049105F75C.html",
							"GUID-223F4EC1-EFAC-46A1-BF77-0DB6B8CB27BB.html",
							"GUID-223F4EC1-EFAC-46A1-BF77-0DB6B8CB27BB.html",
							"GUID-223F4EC1-EFAC-46A1-BF77-0DB6B8CB27BB.html",
							"GUID-223F4EC1-EFAC-46A1-BF77-0DB6B8CB27BB.html",
							"GUID-223F4EC1-EFAC-46A1-BF77-0DB6B8CB27BB.html",
							"GUID-223F4EC1-EFAC-46A1-BF77-0DB6B8CB27BB.html",
							"GUID-223F4EC1-EFAC-46A1-BF77-0DB6B8CB27BB.html",
							"GUID-223F4EC1-EFAC-46A1-BF77-0DB6B8CB27BB.html",
							"GUID-223F4EC1-EFAC-46A1-BF77-0DB6B8CB27BB.html",
							"GUID-F4092B61-8FC4-4D6E-A043-E20E2965D24D.html",
							"GUID-F4092B61-8FC4-4D6E-A043-E20E2965D24D.html",
							"GUID-F4092B61-8FC4-4D6E-A043-E20E2965D24D.html",
							"GUID-F4092B61-8FC4-4D6E-A043-E20E2965D24D.html",
							"GUID-F4092B61-8FC4-4D6E-A043-E20E2965D24D.html",
							"GUID-F4092B61-8FC4-4D6E-A043-E20E2965D24D.html",
							"GUID-F4092B61-8FC4-4D6E-A043-E20E2965D24D.html",
							"GUID-F4092B61-8FC4-4D6E-A043-E20E2965D24D.html",
							"GUID-F4092B61-8FC4-4D6E-A043-E20E2965D24D.html",
							"GUID-DB773A68-76AC-4900-8C7C-3AC9C38BE0BD.html",
							"GUID-81E6C307-8460-46B5-A1C4-3CAB36053798.html",
							"GUID-81E6C307-8460-46B5-A1C4-3CAB36053798.html",
							"GUID-81E6C307-8460-46B5-A1C4-3CAB36053798.html",
							"GUID-81E6C307-8460-46B5-A1C4-3CAB36053798.html",
							"GUID-81E6C307-8460-46B5-A1C4-3CAB36053798.html",
							"GUID-81E6C307-8460-46B5-A1C4-3CAB36053798.html",
							"GUID-81E6C307-8460-46B5-A1C4-3CAB36053798.html",
							"GUID-81E6C307-8460-46B5-A1C4-3CAB36053798.html",
							"GUID-81E6C307-8460-46B5-A1C4-3CAB36053798.html",
							"GUID-A19F88F6-C9FA-4AAC-B38D-F144457573A8.html",
							"GUID-A19F88F6-C9FA-4AAC-B38D-F144457573A8.html",
							"GUID-A19F88F6-C9FA-4AAC-B38D-F144457573A8.html",
							"GUID-A19F88F6-C9FA-4AAC-B38D-F144457573A8.html",
							"GUID-A19F88F6-C9FA-4AAC-B38D-F144457573A8.html",
							"GUID-A19F88F6-C9FA-4AAC-B38D-F144457573A8.html",
							"GUID-A19F88F6-C9FA-4AAC-B38D-F144457573A8.html",
							"GUID-A19F88F6-C9FA-4AAC-B38D-F144457573A8.html",
							"GUID-A19F88F6-C9FA-4AAC-B38D-F144457573A8.html",
							"GUID-D63F3805-23E9-466F-9E1C-EE6F521BF722.html",
							"GUID-D63F3805-23E9-466F-9E1C-EE6F521BF722.html",
							"GUID-D63F3805-23E9-466F-9E1C-EE6F521BF722.html",
							"GUID-D63F3805-23E9-466F-9E1C-EE6F521BF722.html",
							"GUID-D63F3805-23E9-466F-9E1C-EE6F521BF722.html",
							"GUID-D63F3805-23E9-466F-9E1C-EE6F521BF722.html",
							"GUID-D63F3805-23E9-466F-9E1C-EE6F521BF722.html",
							"GUID-D63F3805-23E9-466F-9E1C-EE6F521BF722.html",
							"GUID-D63F3805-23E9-466F-9E1C-EE6F521BF722.html",
							"GUID-4D048D67-43E2-4313-A87A-0C887B2C569A.html",
							"GUID-4D048D67-43E2-4313-A87A-0C887B2C569A.html",
							"GUID-4D048D67-43E2-4313-A87A-0C887B2C569A.html",
							"GUID-4D048D67-43E2-4313-A87A-0C887B2C569A.html",
							"GUID-4D048D67-43E2-4313-A87A-0C887B2C569A.html",
							"GUID-4D048D67-43E2-4313-A87A-0C887B2C569A.html",
							"GUID-4D048D67-43E2-4313-A87A-0C887B2C569A.html",
							"GUID-4D048D67-43E2-4313-A87A-0C887B2C569A.html",
							"GUID-4D048D67-43E2-4313-A87A-0C887B2C569A.html",
							"GUID-FC39BE07-F826-41F2-886F-EA6C98025B49.html",
							"GUID-FC39BE07-F826-41F2-886F-EA6C98025B49.html",
							"GUID-FC39BE07-F826-41F2-886F-EA6C98025B49.html",
							"GUID-FC39BE07-F826-41F2-886F-EA6C98025B49.html",
							"GUID-FC39BE07-F826-41F2-886F-EA6C98025B49.html",
							"GUID-FC39BE07-F826-41F2-886F-EA6C98025B49.html",
							"GUID-FC39BE07-F826-41F2-886F-EA6C98025B49.html",
							"GUID-FC39BE07-F826-41F2-886F-EA6C98025B49.html",
							"GUID-FC39BE07-F826-41F2-886F-EA6C98025B49.html",
							"GUID-BA947717-82BA-4AAE-B017-1BFA24B4C89A.html",
							"GUID-BA947717-82BA-4AAE-B017-1BFA24B4C89A.html",
							"GUID-BA947717-82BA-4AAE-B017-1BFA24B4C89A.html",
							"GUID-BA947717-82BA-4AAE-B017-1BFA24B4C89A.html",
							"GUID-BA947717-82BA-4AAE-B017-1BFA24B4C89A.html",
							"GUID-BA947717-82BA-4AAE-B017-1BFA24B4C89A.html",
							"GUID-BA947717-82BA-4AAE-B017-1BFA24B4C89A.html",
							"GUID-BA947717-82BA-4AAE-B017-1BFA24B4C89A.html",
							"GUID-BA947717-82BA-4AAE-B017-1BFA24B4C89A.html",
							"GUID-EABDAE77-7DE7-4019-9DF0-A406B4232341.html",
							"GUID-EABDAE77-7DE7-4019-9DF0-A406B4232341.html",
							"GUID-EABDAE77-7DE7-4019-9DF0-A406B4232341.html",
							"GUID-EABDAE77-7DE7-4019-9DF0-A406B4232341.html",
							"GUID-EABDAE77-7DE7-4019-9DF0-A406B4232341.html",
							"GUID-F629157B-1931-4637-91C5-F9BF005ADFB9.html",
							"GUID-F629157B-1931-4637-91C5-F9BF005ADFB9.html",
							"GUID-F629157B-1931-4637-91C5-F9BF005ADFB9.html",
							"GUID-F629157B-1931-4637-91C5-F9BF005ADFB9.html",
							"GUID-F629157B-1931-4637-91C5-F9BF005ADFB9.html",
							"GUID-0D62C2C2-2AEB-4AE6-BFEC-E7A32ABAD3BF.html",
							"GUID-0D62C2C2-2AEB-4AE6-BFEC-E7A32ABAD3BF.html",
							"GUID-0D62C2C2-2AEB-4AE6-BFEC-E7A32ABAD3BF.html",
							"GUID-0D62C2C2-2AEB-4AE6-BFEC-E7A32ABAD3BF.html",
							"GUID-0D62C2C2-2AEB-4AE6-BFEC-E7A32ABAD3BF.html",
							"GUID-520F6190-7A36-4541-B826-AD1097DD8628.html",
							"GUID-520F6190-7A36-4541-B826-AD1097DD8628.html",
							"GUID-520F6190-7A36-4541-B826-AD1097DD8628.html",
							"GUID-520F6190-7A36-4541-B826-AD1097DD8628.html",
							"GUID-520F6190-7A36-4541-B826-AD1097DD8628.html",
							"GUID-58E3FBF2-C74A-4F4E-8541-139C6F019AB1.html",
							"GUID-58E3FBF2-C74A-4F4E-8541-139C6F019AB1.html",
							"GUID-58E3FBF2-C74A-4F4E-8541-139C6F019AB1.html",
							"GUID-58E3FBF2-C74A-4F4E-8541-139C6F019AB1.html",
							"GUID-58E3FBF2-C74A-4F4E-8541-139C6F019AB1.html",
							"GUID-1A116E58-BD6D-4114-9B86-CDD6241EAF87.html",
							"GUID-1A116E58-BD6D-4114-9B86-CDD6241EAF87.html",
							"GUID-1A116E58-BD6D-4114-9B86-CDD6241EAF87.html",
							"GUID-1A116E58-BD6D-4114-9B86-CDD6241EAF87.html",
							"GUID-1A116E58-BD6D-4114-9B86-CDD6241EAF87.html",
							"GUID-066D09D2-5550-49D9-ADA2-60A702DB243E.html",
							"GUID-DA048541-5D9C-4523-AAA7-A4BCF54C0B2D.html",
							"GUID-51740620-007C-449D-A985-84207C03F2DF.html",
							"GUID-FEDD8FB6-058D-48C6-AD72-85A1DFE7DB31.html",
							"GUID-42556FDF-A632-49FE-8A5E-9303A926578C.html",
							"GUID-EBC86D7E-991E-4F99-B615-1764B5687E0F.html",
							"GUID-EBC86D7E-991E-4F99-B615-1764B5687E0F.html",
							"GUID-EBC86D7E-991E-4F99-B615-1764B5687E0F.html",
							"GUID-EBC86D7E-991E-4F99-B615-1764B5687E0F.html",
							"GUID-EBC86D7E-991E-4F99-B615-1764B5687E0F.html",
							"GUID-EBC86D7E-991E-4F99-B615-1764B5687E0F.html",
							"GUID-EBC86D7E-991E-4F99-B615-1764B5687E0F.html",
							"GUID-EBC86D7E-991E-4F99-B615-1764B5687E0F.html",
							"GUID-3365F9D0-51D1-4CD6-8ABE-36B90E11752E.html",
							"GUID-3365F9D0-51D1-4CD6-8ABE-36B90E11752E.html",
							"GUID-3365F9D0-51D1-4CD6-8ABE-36B90E11752E.html",
							"GUID-3365F9D0-51D1-4CD6-8ABE-36B90E11752E.html",
							"GUID-3365F9D0-51D1-4CD6-8ABE-36B90E11752E.html",
							"GUID-3365F9D0-51D1-4CD6-8ABE-36B90E11752E.html",
							"GUID-3365F9D0-51D1-4CD6-8ABE-36B90E11752E.html",
							"GUID-3365F9D0-51D1-4CD6-8ABE-36B90E11752E.html",
							"GUID-3365F9D0-51D1-4CD6-8ABE-36B90E11752E.html",
							"GUID-C3E440D0-2F73-4BA9-874A-A08D52EA87E3.html",
							"GUID-C3E440D0-2F73-4BA9-874A-A08D52EA87E3.html",
							"GUID-C3E440D0-2F73-4BA9-874A-A08D52EA87E3.html",
							"GUID-C3E440D0-2F73-4BA9-874A-A08D52EA87E3.html",
							"GUID-C3E440D0-2F73-4BA9-874A-A08D52EA87E3.html",
							"GUID-C3E440D0-2F73-4BA9-874A-A08D52EA87E3.html",
							"GUID-C3E440D0-2F73-4BA9-874A-A08D52EA87E3.html",
							"GUID-C3E440D0-2F73-4BA9-874A-A08D52EA87E3.html",
							"GUID-C3E440D0-2F73-4BA9-874A-A08D52EA87E3.html",
							"GUID-4CD57E60-CFCA-4413-A344-0BB9E1A05660.html",
							"GUID-4CD57E60-CFCA-4413-A344-0BB9E1A05660.html",
							"GUID-4CD57E60-CFCA-4413-A344-0BB9E1A05660.html",
							"GUID-4CD57E60-CFCA-4413-A344-0BB9E1A05660.html",
							"GUID-4CD57E60-CFCA-4413-A344-0BB9E1A05660.html",
							"GUID-4CD57E60-CFCA-4413-A344-0BB9E1A05660.html",
							"GUID-4CD57E60-CFCA-4413-A344-0BB9E1A05660.html",
							"GUID-4CD57E60-CFCA-4413-A344-0BB9E1A05660.html",
							"GUID-760611CB-BB7F-4083-A98D-102D8A28E346.html",
							"GUID-760611CB-BB7F-4083-A98D-102D8A28E346.html",
							"GUID-760611CB-BB7F-4083-A98D-102D8A28E346.html",
							"GUID-760611CB-BB7F-4083-A98D-102D8A28E346.html",
							"GUID-760611CB-BB7F-4083-A98D-102D8A28E346.html",
							"GUID-760611CB-BB7F-4083-A98D-102D8A28E346.html",
							"GUID-760611CB-BB7F-4083-A98D-102D8A28E346.html",
							"GUID-760611CB-BB7F-4083-A98D-102D8A28E346.html",
							"GUID-760611CB-BB7F-4083-A98D-102D8A28E346.html",
							"GUID-B11944D6-E746-4D44-B1D6-9C1E12944351.html",
							"GUID-B11944D6-E746-4D44-B1D6-9C1E12944351.html",
							"GUID-B11944D6-E746-4D44-B1D6-9C1E12944351.html",
							"GUID-B11944D6-E746-4D44-B1D6-9C1E12944351.html",
							"GUID-B11944D6-E746-4D44-B1D6-9C1E12944351.html",
							"GUID-B11944D6-E746-4D44-B1D6-9C1E12944351.html",
							"GUID-B11944D6-E746-4D44-B1D6-9C1E12944351.html",
							"GUID-B11944D6-E746-4D44-B1D6-9C1E12944351.html",
							"GUID-B11944D6-E746-4D44-B1D6-9C1E12944351.html",
							"GUID-E8F31262-EEB7-495E-8292-1CE7D6BED8F6.html",
							"GUID-E8F31262-EEB7-495E-8292-1CE7D6BED8F6.html",
							"GUID-E8F31262-EEB7-495E-8292-1CE7D6BED8F6.html",
							"GUID-E8F31262-EEB7-495E-8292-1CE7D6BED8F6.html",
							"GUID-E8F31262-EEB7-495E-8292-1CE7D6BED8F6.html",
							"GUID-E8F31262-EEB7-495E-8292-1CE7D6BED8F6.html",
							"GUID-E8F31262-EEB7-495E-8292-1CE7D6BED8F6.html",
							"GUID-E8F31262-EEB7-495E-8292-1CE7D6BED8F6.html",
							"GUID-E8F31262-EEB7-495E-8292-1CE7D6BED8F6.html",
							"GUID-BEEC6E4A-AB22-424B-81C4-161E06B286B3.html",
							"GUID-BEEC6E4A-AB22-424B-81C4-161E06B286B3.html",
							"GUID-BEEC6E4A-AB22-424B-81C4-161E06B286B3.html",
							"GUID-BEEC6E4A-AB22-424B-81C4-161E06B286B3.html",
							"GUID-BEEC6E4A-AB22-424B-81C4-161E06B286B3.html",
							"GUID-BEEC6E4A-AB22-424B-81C4-161E06B286B3.html",
							"GUID-BEEC6E4A-AB22-424B-81C4-161E06B286B3.html",
							"GUID-BEEC6E4A-AB22-424B-81C4-161E06B286B3.html",
							"GUID-BEEC6E4A-AB22-424B-81C4-161E06B286B3.html",
							"GUID-8A597E0D-6D93-4722-84B7-6DBC83406F78.html",
							"GUID-8A597E0D-6D93-4722-84B7-6DBC83406F78.html",
							"GUID-8A597E0D-6D93-4722-84B7-6DBC83406F78.html",
							"GUID-8A597E0D-6D93-4722-84B7-6DBC83406F78.html",
							"GUID-8A597E0D-6D93-4722-84B7-6DBC83406F78.html",
							"GUID-8A597E0D-6D93-4722-84B7-6DBC83406F78.html",
							"GUID-8A597E0D-6D93-4722-84B7-6DBC83406F78.html",
							"GUID-8A597E0D-6D93-4722-84B7-6DBC83406F78.html",
							"GUID-8A597E0D-6D93-4722-84B7-6DBC83406F78.html",
							"GUID-B6E0D5A9-0560-44D9-A979-BA1CECDD2885.html",
							"GUID-B6E0D5A9-0560-44D9-A979-BA1CECDD2885.html",
							"GUID-B6E0D5A9-0560-44D9-A979-BA1CECDD2885.html",
							"GUID-B6E0D5A9-0560-44D9-A979-BA1CECDD2885.html",
							"GUID-B6E0D5A9-0560-44D9-A979-BA1CECDD2885.html",
							"GUID-B6E0D5A9-0560-44D9-A979-BA1CECDD2885.html",
							"GUID-B6E0D5A9-0560-44D9-A979-BA1CECDD2885.html",
							"GUID-B6E0D5A9-0560-44D9-A979-BA1CECDD2885.html",
							"GUID-B6E0D5A9-0560-44D9-A979-BA1CECDD2885.html",
							"GUID-92EA2E5D-4704-4D93-96DB-29FA4359A2AB.html",
							"GUID-92EA2E5D-4704-4D93-96DB-29FA4359A2AB.html",
							"GUID-92EA2E5D-4704-4D93-96DB-29FA4359A2AB.html",
							"GUID-92EA2E5D-4704-4D93-96DB-29FA4359A2AB.html",
							"GUID-92EA2E5D-4704-4D93-96DB-29FA4359A2AB.html",
							"GUID-92EA2E5D-4704-4D93-96DB-29FA4359A2AB.html",
							"GUID-92EA2E5D-4704-4D93-96DB-29FA4359A2AB.html",
							"GUID-92EA2E5D-4704-4D93-96DB-29FA4359A2AB.html",
							"GUID-92EA2E5D-4704-4D93-96DB-29FA4359A2AB.html",
							"GUID-C5423212-D6E4-4C4A-A935-BAE0D8E971D9.html",
							"GUID-C5423212-D6E4-4C4A-A935-BAE0D8E971D9.html",
							"GUID-C5423212-D6E4-4C4A-A935-BAE0D8E971D9.html",
							"GUID-C5423212-D6E4-4C4A-A935-BAE0D8E971D9.html",
							"GUID-C5423212-D6E4-4C4A-A935-BAE0D8E971D9.html",
							"GUID-C5423212-D6E4-4C4A-A935-BAE0D8E971D9.html",
							"GUID-C5423212-D6E4-4C4A-A935-BAE0D8E971D9.html",
							"GUID-C5423212-D6E4-4C4A-A935-BAE0D8E971D9.html",
							"GUID-C5423212-D6E4-4C4A-A935-BAE0D8E971D9.html",
							"GUID-79C0F4A4-9F81-4865-B6A6-2642F39E919F.html",
							"GUID-79C0F4A4-9F81-4865-B6A6-2642F39E919F.html",
							"GUID-79C0F4A4-9F81-4865-B6A6-2642F39E919F.html",
							"GUID-79C0F4A4-9F81-4865-B6A6-2642F39E919F.html",
							"GUID-79C0F4A4-9F81-4865-B6A6-2642F39E919F.html",
							"GUID-79C0F4A4-9F81-4865-B6A6-2642F39E919F.html",
							"GUID-79C0F4A4-9F81-4865-B6A6-2642F39E919F.html",
							"GUID-79C0F4A4-9F81-4865-B6A6-2642F39E919F.html",
							"GUID-79C0F4A4-9F81-4865-B6A6-2642F39E919F.html",
							"GUID-D7E32A8F-DC21-4E8D-ABE6-6AEE3FA0C89C.html",
							"GUID-D7E32A8F-DC21-4E8D-ABE6-6AEE3FA0C89C.html",
							"GUID-D7E32A8F-DC21-4E8D-ABE6-6AEE3FA0C89C.html",
							"GUID-D7E32A8F-DC21-4E8D-ABE6-6AEE3FA0C89C.html",
							"GUID-D7E32A8F-DC21-4E8D-ABE6-6AEE3FA0C89C.html",
							"GUID-D7E32A8F-DC21-4E8D-ABE6-6AEE3FA0C89C.html",
							"GUID-D7E32A8F-DC21-4E8D-ABE6-6AEE3FA0C89C.html",
							"GUID-D7E32A8F-DC21-4E8D-ABE6-6AEE3FA0C89C.html",
							"GUID-D7E32A8F-DC21-4E8D-ABE6-6AEE3FA0C89C.html",
							"GUID-9556A393-F301-40C0-8CCB-B49E9A0FC031.html",
							"GUID-9556A393-F301-40C0-8CCB-B49E9A0FC031.html",
							"GUID-9556A393-F301-40C0-8CCB-B49E9A0FC031.html",
							"GUID-9556A393-F301-40C0-8CCB-B49E9A0FC031.html",
							"GUID-9556A393-F301-40C0-8CCB-B49E9A0FC031.html",
							"GUID-9556A393-F301-40C0-8CCB-B49E9A0FC031.html",
							"GUID-9556A393-F301-40C0-8CCB-B49E9A0FC031.html",
							"GUID-9556A393-F301-40C0-8CCB-B49E9A0FC031.html",
							"GUID-9556A393-F301-40C0-8CCB-B49E9A0FC031.html",
							"GUID-F6E3750F-7E4C-4A6C-9993-3028AF3D5457.html",
							"GUID-F6E3750F-7E4C-4A6C-9993-3028AF3D5457.html",
							"GUID-F6E3750F-7E4C-4A6C-9993-3028AF3D5457.html",
							"GUID-F6E3750F-7E4C-4A6C-9993-3028AF3D5457.html",
							"GUID-F6E3750F-7E4C-4A6C-9993-3028AF3D5457.html",
							"GUID-F6E3750F-7E4C-4A6C-9993-3028AF3D5457.html",
							"GUID-F6E3750F-7E4C-4A6C-9993-3028AF3D5457.html",
							"GUID-F6E3750F-7E4C-4A6C-9993-3028AF3D5457.html",
							"GUID-F6E3750F-7E4C-4A6C-9993-3028AF3D5457.html",
							"GUID-E19AB663-B620-431F-988F-64E339B3010C.html",
							"GUID-E19AB663-B620-431F-988F-64E339B3010C.html",
							"GUID-E19AB663-B620-431F-988F-64E339B3010C.html",
							"GUID-E19AB663-B620-431F-988F-64E339B3010C.html",
							"GUID-E19AB663-B620-431F-988F-64E339B3010C.html",
							"GUID-E19AB663-B620-431F-988F-64E339B3010C.html",
							"GUID-E19AB663-B620-431F-988F-64E339B3010C.html",
							"GUID-E19AB663-B620-431F-988F-64E339B3010C.html",
							"GUID-E19AB663-B620-431F-988F-64E339B3010C.html",
							"GUID-68AF6796-DF3C-4742-81B5-555C359975D1.html",
							"GUID-68AF6796-DF3C-4742-81B5-555C359975D1.html",
							"GUID-68AF6796-DF3C-4742-81B5-555C359975D1.html",
							"GUID-68AF6796-DF3C-4742-81B5-555C359975D1.html",
							"GUID-68AF6796-DF3C-4742-81B5-555C359975D1.html",
							"GUID-68AF6796-DF3C-4742-81B5-555C359975D1.html",
							"GUID-68AF6796-DF3C-4742-81B5-555C359975D1.html",
							"GUID-68AF6796-DF3C-4742-81B5-555C359975D1.html",
							"GUID-68AF6796-DF3C-4742-81B5-555C359975D1.html",
							"GUID-40903D55-759F-49AF-BDF7-CD4E0693C394.html",
							"GUID-40903D55-759F-49AF-BDF7-CD4E0693C394.html",
							"GUID-40903D55-759F-49AF-BDF7-CD4E0693C394.html",
							"GUID-40903D55-759F-49AF-BDF7-CD4E0693C394.html",
							"GUID-40903D55-759F-49AF-BDF7-CD4E0693C394.html",
							"GUID-40903D55-759F-49AF-BDF7-CD4E0693C394.html",
							"GUID-40903D55-759F-49AF-BDF7-CD4E0693C394.html",
							"GUID-40903D55-759F-49AF-BDF7-CD4E0693C394.html",
							"GUID-40903D55-759F-49AF-BDF7-CD4E0693C394.html",
							"GUID-17500CE8-820C-482D-B721-87577B1FA289.html",
							"GUID-17500CE8-820C-482D-B721-87577B1FA289.html",
							"GUID-17500CE8-820C-482D-B721-87577B1FA289.html",
							"GUID-17500CE8-820C-482D-B721-87577B1FA289.html",
							"GUID-17500CE8-820C-482D-B721-87577B1FA289.html",
							"GUID-17500CE8-820C-482D-B721-87577B1FA289.html",
							"GUID-17500CE8-820C-482D-B721-87577B1FA289.html",
							"GUID-17500CE8-820C-482D-B721-87577B1FA289.html",
							"GUID-17500CE8-820C-482D-B721-87577B1FA289.html",
							"GUID-D34C151E-F128-4431-B0B3-6992EDD44D8F.html",
							"GUID-D34C151E-F128-4431-B0B3-6992EDD44D8F.html",
							"GUID-D34C151E-F128-4431-B0B3-6992EDD44D8F.html",
							"GUID-D34C151E-F128-4431-B0B3-6992EDD44D8F.html",
							"GUID-D34C151E-F128-4431-B0B3-6992EDD44D8F.html",
							"GUID-D34C151E-F128-4431-B0B3-6992EDD44D8F.html",
							"GUID-D34C151E-F128-4431-B0B3-6992EDD44D8F.html",
							"GUID-D34C151E-F128-4431-B0B3-6992EDD44D8F.html",
							"GUID-D34C151E-F128-4431-B0B3-6992EDD44D8F.html",
							"GUID-B84F5FC9-27E9-43D0-BF80-DDF4F8EBA4F1.html",
							"GUID-B84F5FC9-27E9-43D0-BF80-DDF4F8EBA4F1.html",
							"GUID-B84F5FC9-27E9-43D0-BF80-DDF4F8EBA4F1.html",
							"GUID-B84F5FC9-27E9-43D0-BF80-DDF4F8EBA4F1.html",
							"GUID-B84F5FC9-27E9-43D0-BF80-DDF4F8EBA4F1.html",
							"GUID-B84F5FC9-27E9-43D0-BF80-DDF4F8EBA4F1.html",
							"GUID-B84F5FC9-27E9-43D0-BF80-DDF4F8EBA4F1.html",
							"GUID-B84F5FC9-27E9-43D0-BF80-DDF4F8EBA4F1.html",
							"GUID-B84F5FC9-27E9-43D0-BF80-DDF4F8EBA4F1.html",
							"GUID-42C01AE8-60C8-4A86-91A7-56D9222CBFC7.html",
							"GUID-42C01AE8-60C8-4A86-91A7-56D9222CBFC7.html",
							"GUID-42C01AE8-60C8-4A86-91A7-56D9222CBFC7.html",
							"GUID-42C01AE8-60C8-4A86-91A7-56D9222CBFC7.html",
							"GUID-42C01AE8-60C8-4A86-91A7-56D9222CBFC7.html",
							"GUID-42C01AE8-60C8-4A86-91A7-56D9222CBFC7.html",
							"GUID-42C01AE8-60C8-4A86-91A7-56D9222CBFC7.html",
							"GUID-42C01AE8-60C8-4A86-91A7-56D9222CBFC7.html",
							"GUID-42C01AE8-60C8-4A86-91A7-56D9222CBFC7.html",
							"GUID-DE7E790A-ADA1-45B1-83C7-C072A270C6B1.html",
							"GUID-DE7E790A-ADA1-45B1-83C7-C072A270C6B1.html",
							"GUID-DE7E790A-ADA1-45B1-83C7-C072A270C6B1.html",
							"GUID-DE7E790A-ADA1-45B1-83C7-C072A270C6B1.html",
							"GUID-DE7E790A-ADA1-45B1-83C7-C072A270C6B1.html",
							"GUID-DE7E790A-ADA1-45B1-83C7-C072A270C6B1.html",
							"GUID-DE7E790A-ADA1-45B1-83C7-C072A270C6B1.html",
							"GUID-DE7E790A-ADA1-45B1-83C7-C072A270C6B1.html",
							"GUID-DE7E790A-ADA1-45B1-83C7-C072A270C6B1.html",
							"GUID-C0A3888C-CE30-403B-9AE7-042022369538.html",
							"GUID-C0A3888C-CE30-403B-9AE7-042022369538.html",
							"GUID-C0A3888C-CE30-403B-9AE7-042022369538.html",
							"GUID-C0A3888C-CE30-403B-9AE7-042022369538.html",
							"GUID-C0A3888C-CE30-403B-9AE7-042022369538.html",
							"GUID-C0A3888C-CE30-403B-9AE7-042022369538.html",
							"GUID-C0A3888C-CE30-403B-9AE7-042022369538.html",
							"GUID-C0A3888C-CE30-403B-9AE7-042022369538.html",
							"GUID-C0A3888C-CE30-403B-9AE7-042022369538.html",
							"GUID-09414A23-7390-4DBF-950D-F0BB8575A7B6.html",
							"GUID-09414A23-7390-4DBF-950D-F0BB8575A7B6.html",
							"GUID-09414A23-7390-4DBF-950D-F0BB8575A7B6.html",
							"GUID-09414A23-7390-4DBF-950D-F0BB8575A7B6.html",
							"GUID-09414A23-7390-4DBF-950D-F0BB8575A7B6.html",
							"GUID-09414A23-7390-4DBF-950D-F0BB8575A7B6.html",
							"GUID-09414A23-7390-4DBF-950D-F0BB8575A7B6.html",
							"GUID-09414A23-7390-4DBF-950D-F0BB8575A7B6.html",
							"GUID-09414A23-7390-4DBF-950D-F0BB8575A7B6.html",
							"GUID-C43ABFE3-58B7-4A30-840E-B2BBCCCDF33D.html",
							"GUID-C43ABFE3-58B7-4A30-840E-B2BBCCCDF33D.html",
							"GUID-C43ABFE3-58B7-4A30-840E-B2BBCCCDF33D.html",
							"GUID-C43ABFE3-58B7-4A30-840E-B2BBCCCDF33D.html",
							"GUID-C43ABFE3-58B7-4A30-840E-B2BBCCCDF33D.html",
							"GUID-C43ABFE3-58B7-4A30-840E-B2BBCCCDF33D.html",
							"GUID-C43ABFE3-58B7-4A30-840E-B2BBCCCDF33D.html",
							"GUID-C43ABFE3-58B7-4A30-840E-B2BBCCCDF33D.html",
							"GUID-C43ABFE3-58B7-4A30-840E-B2BBCCCDF33D.html",
							"GUID-85FC64CE-DADA-4F11-BBAC-9EF299544C00.html",
							"GUID-85FC64CE-DADA-4F11-BBAC-9EF299544C00.html",
							"GUID-85FC64CE-DADA-4F11-BBAC-9EF299544C00.html",
							"GUID-85FC64CE-DADA-4F11-BBAC-9EF299544C00.html",
							"GUID-85FC64CE-DADA-4F11-BBAC-9EF299544C00.html",
							"GUID-85FC64CE-DADA-4F11-BBAC-9EF299544C00.html",
							"GUID-85FC64CE-DADA-4F11-BBAC-9EF299544C00.html",
							"GUID-85FC64CE-DADA-4F11-BBAC-9EF299544C00.html",
							"GUID-85FC64CE-DADA-4F11-BBAC-9EF299544C00.html",
							"GUID-BB75D339-99C6-4EFA-8443-51B883E071F5.html",
							"GUID-BB75D339-99C6-4EFA-8443-51B883E071F5.html",
							"GUID-BB75D339-99C6-4EFA-8443-51B883E071F5.html",
							"GUID-BB75D339-99C6-4EFA-8443-51B883E071F5.html",
							"GUID-BB75D339-99C6-4EFA-8443-51B883E071F5.html",
							"GUID-BB75D339-99C6-4EFA-8443-51B883E071F5.html",
							"GUID-BB75D339-99C6-4EFA-8443-51B883E071F5.html",
							"GUID-BB75D339-99C6-4EFA-8443-51B883E071F5.html",
							"GUID-BB75D339-99C6-4EFA-8443-51B883E071F5.html",
							"GUID-D91142BC-8060-4E5E-A75A-F92BD776160A.html",
							"GUID-D91142BC-8060-4E5E-A75A-F92BD776160A.html",
							"GUID-D91142BC-8060-4E5E-A75A-F92BD776160A.html",
							"GUID-D91142BC-8060-4E5E-A75A-F92BD776160A.html",
							"GUID-D91142BC-8060-4E5E-A75A-F92BD776160A.html",
							"GUID-D91142BC-8060-4E5E-A75A-F92BD776160A.html",
							"GUID-D91142BC-8060-4E5E-A75A-F92BD776160A.html",
							"GUID-D91142BC-8060-4E5E-A75A-F92BD776160A.html",
							"GUID-D91142BC-8060-4E5E-A75A-F92BD776160A.html",
							"GUID-63D12AA9-FCFA-4183-9E63-F01D58DDF1B9.html",
							"GUID-63D12AA9-FCFA-4183-9E63-F01D58DDF1B9.html",
							"GUID-63D12AA9-FCFA-4183-9E63-F01D58DDF1B9.html",
							"GUID-63D12AA9-FCFA-4183-9E63-F01D58DDF1B9.html",
							"GUID-63D12AA9-FCFA-4183-9E63-F01D58DDF1B9.html",
							"GUID-63D12AA9-FCFA-4183-9E63-F01D58DDF1B9.html",
							"GUID-63D12AA9-FCFA-4183-9E63-F01D58DDF1B9.html",
							"GUID-63D12AA9-FCFA-4183-9E63-F01D58DDF1B9.html",
							"GUID-63D12AA9-FCFA-4183-9E63-F01D58DDF1B9.html",
							"GUID-8D636C6F-ECAD-4501-9CD1-E145B18D7256.html",
							"GUID-8D636C6F-ECAD-4501-9CD1-E145B18D7256.html",
							"GUID-8D636C6F-ECAD-4501-9CD1-E145B18D7256.html",
							"GUID-8D636C6F-ECAD-4501-9CD1-E145B18D7256.html",
							"GUID-8D636C6F-ECAD-4501-9CD1-E145B18D7256.html",
							"GUID-8D636C6F-ECAD-4501-9CD1-E145B18D7256.html",
							"GUID-8D636C6F-ECAD-4501-9CD1-E145B18D7256.html",
							"GUID-8D636C6F-ECAD-4501-9CD1-E145B18D7256.html",
							"GUID-8D636C6F-ECAD-4501-9CD1-E145B18D7256.html",
							"GUID-27A799DA-3CEE-457F-AFEE-819817CA5978.html",
							"GUID-27A799DA-3CEE-457F-AFEE-819817CA5978.html",
							"GUID-27A799DA-3CEE-457F-AFEE-819817CA5978.html",
							"GUID-27A799DA-3CEE-457F-AFEE-819817CA5978.html",
							"GUID-27A799DA-3CEE-457F-AFEE-819817CA5978.html",
							"GUID-27A799DA-3CEE-457F-AFEE-819817CA5978.html",
							"GUID-27A799DA-3CEE-457F-AFEE-819817CA5978.html",
							"GUID-27A799DA-3CEE-457F-AFEE-819817CA5978.html",
							"GUID-27A799DA-3CEE-457F-AFEE-819817CA5978.html",
							"GUID-0DECF377-6DF4-46B4-A309-5C08078198F0.html",
							"GUID-0DECF377-6DF4-46B4-A309-5C08078198F0.html",
							"GUID-0DECF377-6DF4-46B4-A309-5C08078198F0.html",
							"GUID-0DECF377-6DF4-46B4-A309-5C08078198F0.html",
							"GUID-0DECF377-6DF4-46B4-A309-5C08078198F0.html",
							"GUID-0DECF377-6DF4-46B4-A309-5C08078198F0.html",
							"GUID-0DECF377-6DF4-46B4-A309-5C08078198F0.html",
							"GUID-0DECF377-6DF4-46B4-A309-5C08078198F0.html",
							"GUID-0DECF377-6DF4-46B4-A309-5C08078198F0.html",
							"GUID-9001DC8C-6506-490D-B889-B8925C1192C3.html",
							"GUID-9001DC8C-6506-490D-B889-B8925C1192C3.html",
							"GUID-9001DC8C-6506-490D-B889-B8925C1192C3.html",
							"GUID-9001DC8C-6506-490D-B889-B8925C1192C3.html",
							"GUID-9001DC8C-6506-490D-B889-B8925C1192C3.html",
							"GUID-9001DC8C-6506-490D-B889-B8925C1192C3.html",
							"GUID-9001DC8C-6506-490D-B889-B8925C1192C3.html",
							"GUID-9001DC8C-6506-490D-B889-B8925C1192C3.html",
							"GUID-9001DC8C-6506-490D-B889-B8925C1192C3.html",
							"GUID-EE2B1E74-FD6E-4E67-B829-146AA4C02001.html",
							"GUID-EE2B1E74-FD6E-4E67-B829-146AA4C02001.html",
							"GUID-EE2B1E74-FD6E-4E67-B829-146AA4C02001.html",
							"GUID-EE2B1E74-FD6E-4E67-B829-146AA4C02001.html",
							"GUID-EE2B1E74-FD6E-4E67-B829-146AA4C02001.html",
							"GUID-EE2B1E74-FD6E-4E67-B829-146AA4C02001.html",
							"GUID-EE2B1E74-FD6E-4E67-B829-146AA4C02001.html",
							"GUID-EE2B1E74-FD6E-4E67-B829-146AA4C02001.html",
							"GUID-EE2B1E74-FD6E-4E67-B829-146AA4C02001.html",
							"GUID-49A215E2-6C03-4638-8DDF-D5E08D353B8C.html",
							"GUID-49A215E2-6C03-4638-8DDF-D5E08D353B8C.html",
							"GUID-49A215E2-6C03-4638-8DDF-D5E08D353B8C.html",
							"GUID-49A215E2-6C03-4638-8DDF-D5E08D353B8C.html",
							"GUID-49A215E2-6C03-4638-8DDF-D5E08D353B8C.html",
							"GUID-49A215E2-6C03-4638-8DDF-D5E08D353B8C.html",
							"GUID-49A215E2-6C03-4638-8DDF-D5E08D353B8C.html",
							"GUID-49A215E2-6C03-4638-8DDF-D5E08D353B8C.html",
							"GUID-49A215E2-6C03-4638-8DDF-D5E08D353B8C.html",
							"GUID-9A395A5B-24E8-474F-9FD0-FDA0DD7DF22A.html",
							"GUID-9A395A5B-24E8-474F-9FD0-FDA0DD7DF22A.html",
							"GUID-9A395A5B-24E8-474F-9FD0-FDA0DD7DF22A.html",
							"GUID-9A395A5B-24E8-474F-9FD0-FDA0DD7DF22A.html",
							"GUID-9A395A5B-24E8-474F-9FD0-FDA0DD7DF22A.html",
							"GUID-9A395A5B-24E8-474F-9FD0-FDA0DD7DF22A.html",
							"GUID-9A395A5B-24E8-474F-9FD0-FDA0DD7DF22A.html",
							"GUID-9A395A5B-24E8-474F-9FD0-FDA0DD7DF22A.html",
							"GUID-9A395A5B-24E8-474F-9FD0-FDA0DD7DF22A.html",
							"GUID-783A145F-F4AF-4AA7-B066-80BD9E439E00.html",
							"GUID-783A145F-F4AF-4AA7-B066-80BD9E439E00.html",
							"GUID-783A145F-F4AF-4AA7-B066-80BD9E439E00.html",
							"GUID-783A145F-F4AF-4AA7-B066-80BD9E439E00.html",
							"GUID-783A145F-F4AF-4AA7-B066-80BD9E439E00.html",
							"GUID-783A145F-F4AF-4AA7-B066-80BD9E439E00.html",
							"GUID-783A145F-F4AF-4AA7-B066-80BD9E439E00.html",
							"GUID-783A145F-F4AF-4AA7-B066-80BD9E439E00.html",
							"GUID-783A145F-F4AF-4AA7-B066-80BD9E439E00.html",
							"GUID-6D392610-20DC-4F38-9798-E5FF2BAA3E0A.html",
							"GUID-6D392610-20DC-4F38-9798-E5FF2BAA3E0A.html",
							"GUID-6D392610-20DC-4F38-9798-E5FF2BAA3E0A.html",
							"GUID-6D392610-20DC-4F38-9798-E5FF2BAA3E0A.html",
							"GUID-6D392610-20DC-4F38-9798-E5FF2BAA3E0A.html",
							"GUID-6D392610-20DC-4F38-9798-E5FF2BAA3E0A.html",
							"GUID-6D392610-20DC-4F38-9798-E5FF2BAA3E0A.html",
							"GUID-6D392610-20DC-4F38-9798-E5FF2BAA3E0A.html",
							"GUID-6D392610-20DC-4F38-9798-E5FF2BAA3E0A.html",
							"GUID-F724EC87-6DF5-4689-821F-2757C4994DA9.html",
							"GUID-F724EC87-6DF5-4689-821F-2757C4994DA9.html",
							"GUID-F724EC87-6DF5-4689-821F-2757C4994DA9.html",
							"GUID-F724EC87-6DF5-4689-821F-2757C4994DA9.html",
							"GUID-F724EC87-6DF5-4689-821F-2757C4994DA9.html",
							"GUID-F724EC87-6DF5-4689-821F-2757C4994DA9.html",
							"GUID-F724EC87-6DF5-4689-821F-2757C4994DA9.html",
							"GUID-F724EC87-6DF5-4689-821F-2757C4994DA9.html",
							"GUID-F724EC87-6DF5-4689-821F-2757C4994DA9.html",
							"GUID-95A8C5DF-C0ED-42F7-9C69-062984DBBEAB.html",
							"GUID-95A8C5DF-C0ED-42F7-9C69-062984DBBEAB.html",
							"GUID-95A8C5DF-C0ED-42F7-9C69-062984DBBEAB.html",
							"GUID-95A8C5DF-C0ED-42F7-9C69-062984DBBEAB.html",
							"GUID-95A8C5DF-C0ED-42F7-9C69-062984DBBEAB.html",
							"GUID-95A8C5DF-C0ED-42F7-9C69-062984DBBEAB.html",
							"GUID-95A8C5DF-C0ED-42F7-9C69-062984DBBEAB.html",
							"GUID-95A8C5DF-C0ED-42F7-9C69-062984DBBEAB.html",
							"GUID-95A8C5DF-C0ED-42F7-9C69-062984DBBEAB.html",
							"GUID-CC9DEE82-C59D-409F-81BD-347420DBAB94.html",
							"GUID-CC9DEE82-C59D-409F-81BD-347420DBAB94.html",
							"GUID-CC9DEE82-C59D-409F-81BD-347420DBAB94.html",
							"GUID-CC9DEE82-C59D-409F-81BD-347420DBAB94.html",
							"GUID-CC9DEE82-C59D-409F-81BD-347420DBAB94.html",
							"GUID-CC9DEE82-C59D-409F-81BD-347420DBAB94.html",
							"GUID-CC9DEE82-C59D-409F-81BD-347420DBAB94.html",
							"GUID-CC9DEE82-C59D-409F-81BD-347420DBAB94.html",
							"GUID-CC9DEE82-C59D-409F-81BD-347420DBAB94.html",
							"GUID-29718976-3953-4ACB-80D9-E4F98D7267EB.html",
							"GUID-29718976-3953-4ACB-80D9-E4F98D7267EB.html",
							"GUID-29718976-3953-4ACB-80D9-E4F98D7267EB.html",
							"GUID-29718976-3953-4ACB-80D9-E4F98D7267EB.html",
							"GUID-29718976-3953-4ACB-80D9-E4F98D7267EB.html",
							"GUID-788A2F8C-2432-42F2-9E49-35E431487E63.html",
							"GUID-788A2F8C-2432-42F2-9E49-35E431487E63.html",
							"GUID-788A2F8C-2432-42F2-9E49-35E431487E63.html",
							"GUID-788A2F8C-2432-42F2-9E49-35E431487E63.html",
							"GUID-788A2F8C-2432-42F2-9E49-35E431487E63.html",
							"GUID-6942E929-C41E-47A6-BDC6-72B98D966379.html",
							"GUID-6942E929-C41E-47A6-BDC6-72B98D966379.html",
							"GUID-6942E929-C41E-47A6-BDC6-72B98D966379.html",
							"GUID-6942E929-C41E-47A6-BDC6-72B98D966379.html",
							"GUID-6942E929-C41E-47A6-BDC6-72B98D966379.html",
							"GUID-8179778A-592C-4660-87E7-4AFDC27FA7B7.html",
							"GUID-8179778A-592C-4660-87E7-4AFDC27FA7B7.html",
							"GUID-8179778A-592C-4660-87E7-4AFDC27FA7B7.html",
							"GUID-8179778A-592C-4660-87E7-4AFDC27FA7B7.html",
							"GUID-8179778A-592C-4660-87E7-4AFDC27FA7B7.html",
							"GUID-053B53A0-6358-4572-87A9-D344535EECF0.html",
							"GUID-053B53A0-6358-4572-87A9-D344535EECF0.html",
							"GUID-053B53A0-6358-4572-87A9-D344535EECF0.html",
							"GUID-053B53A0-6358-4572-87A9-D344535EECF0.html",
							"GUID-053B53A0-6358-4572-87A9-D344535EECF0.html",
							"GUID-B19AE59E-6323-4584-8369-DF3831E9F1F4.html",
							"GUID-B19AE59E-6323-4584-8369-DF3831E9F1F4.html",
							"GUID-B19AE59E-6323-4584-8369-DF3831E9F1F4.html",
							"GUID-B19AE59E-6323-4584-8369-DF3831E9F1F4.html",
							"GUID-B19AE59E-6323-4584-8369-DF3831E9F1F4.html",
							"GUID-A7294804-5A6B-42F0-A7EC-9B78EEBC0C19.html",
							"GUID-A7294804-5A6B-42F0-A7EC-9B78EEBC0C19.html",
							"GUID-A7294804-5A6B-42F0-A7EC-9B78EEBC0C19.html",
							"GUID-A7294804-5A6B-42F0-A7EC-9B78EEBC0C19.html",
							"GUID-E971A136-E792-4F48-9664-C4B0612DD46D.html",
							"GUID-E971A136-E792-4F48-9664-C4B0612DD46D.html",
							"GUID-E971A136-E792-4F48-9664-C4B0612DD46D.html",
							"GUID-E971A136-E792-4F48-9664-C4B0612DD46D.html",
							"GUID-E971A136-E792-4F48-9664-C4B0612DD46D.html",
							"GUID-A5F00E8D-8192-4978-8E5D-D7843B7046C0.html",
							"GUID-A5F00E8D-8192-4978-8E5D-D7843B7046C0.html",
							"GUID-A5F00E8D-8192-4978-8E5D-D7843B7046C0.html",
							"GUID-A5F00E8D-8192-4978-8E5D-D7843B7046C0.html",
							"GUID-A5F00E8D-8192-4978-8E5D-D7843B7046C0.html",
							"GUID-D84144C8-6208-429C-99C3-0F280E644638.html",
							"GUID-D84144C8-6208-429C-99C3-0F280E644638.html",
							"GUID-D84144C8-6208-429C-99C3-0F280E644638.html",
							"GUID-D84144C8-6208-429C-99C3-0F280E644638.html",
							"GUID-D84144C8-6208-429C-99C3-0F280E644638.html",
							"GUID-0F9DEE27-DE19-477C-9AD4-3F4E5C84CF8B.html",
							"GUID-0F9DEE27-DE19-477C-9AD4-3F4E5C84CF8B.html",
							"GUID-0F9DEE27-DE19-477C-9AD4-3F4E5C84CF8B.html",
							"GUID-0F9DEE27-DE19-477C-9AD4-3F4E5C84CF8B.html",
							"GUID-0F9DEE27-DE19-477C-9AD4-3F4E5C84CF8B.html",
							"GUID-BF3D7806-7DBE-4A2A-BA54-72EAF3659DBD.html",
							"GUID-BF3D7806-7DBE-4A2A-BA54-72EAF3659DBD.html",
							"GUID-BF3D7806-7DBE-4A2A-BA54-72EAF3659DBD.html",
							"GUID-BF3D7806-7DBE-4A2A-BA54-72EAF3659DBD.html",
							"GUID-BF3D7806-7DBE-4A2A-BA54-72EAF3659DBD.html",
							"GUID-7E8361E8-8372-4766-89EA-12D19F9DE0CD.html",
							"GUID-7E8361E8-8372-4766-89EA-12D19F9DE0CD.html",
							"GUID-7E8361E8-8372-4766-89EA-12D19F9DE0CD.html",
							"GUID-7E8361E8-8372-4766-89EA-12D19F9DE0CD.html",
							"GUID-7E8361E8-8372-4766-89EA-12D19F9DE0CD.html",
							"GUID-E77EF3AE-382C-4616-B57C-D573748C63A2.html",
							"GUID-E77EF3AE-382C-4616-B57C-D573748C63A2.html",
							"GUID-E77EF3AE-382C-4616-B57C-D573748C63A2.html",
							"GUID-E77EF3AE-382C-4616-B57C-D573748C63A2.html",
							"GUID-E77EF3AE-382C-4616-B57C-D573748C63A2.html",
							"GUID-CFDB12EA-C18C-4C53-A42B-5E0419E69632.html",
							"GUID-CFDB12EA-C18C-4C53-A42B-5E0419E69632.html",
							"GUID-CFDB12EA-C18C-4C53-A42B-5E0419E69632.html",
							"GUID-CFDB12EA-C18C-4C53-A42B-5E0419E69632.html",
							"GUID-CFDB12EA-C18C-4C53-A42B-5E0419E69632.html",
							"GUID-52A7B0F6-92F2-44FB-B4CF-363FB76CFCA7.html",
							"GUID-52A7B0F6-92F2-44FB-B4CF-363FB76CFCA7.html",
							"GUID-52A7B0F6-92F2-44FB-B4CF-363FB76CFCA7.html",
							"GUID-52A7B0F6-92F2-44FB-B4CF-363FB76CFCA7.html",
							"GUID-52A7B0F6-92F2-44FB-B4CF-363FB76CFCA7.html",
							"GUID-52A7B0F6-92F2-44FB-B4CF-363FB76CFCA7.html",
							"GUID-52A7B0F6-92F2-44FB-B4CF-363FB76CFCA7.html",
							"GUID-A6505482-D078-4796-9E2E-A224BB412F0A.html",
							"GUID-A6505482-D078-4796-9E2E-A224BB412F0A.html",
							"GUID-A6505482-D078-4796-9E2E-A224BB412F0A.html",
							"GUID-A6505482-D078-4796-9E2E-A224BB412F0A.html",
							"GUID-A6505482-D078-4796-9E2E-A224BB412F0A.html",
							"GUID-A6505482-D078-4796-9E2E-A224BB412F0A.html",
							"GUID-A6505482-D078-4796-9E2E-A224BB412F0A.html",
							"GUID-13815F0C-6C56-4478-979F-D2D1623BDF20.html",
							"GUID-13815F0C-6C56-4478-979F-D2D1623BDF20.html",
							"GUID-13815F0C-6C56-4478-979F-D2D1623BDF20.html",
							"GUID-13815F0C-6C56-4478-979F-D2D1623BDF20.html",
							"GUID-13815F0C-6C56-4478-979F-D2D1623BDF20.html",
							"GUID-13815F0C-6C56-4478-979F-D2D1623BDF20.html",
							"GUID-13815F0C-6C56-4478-979F-D2D1623BDF20.html",
							"GUID-FC8C727E-1368-48E2-88E3-C84B369ABE41.html",
							"GUID-FC8C727E-1368-48E2-88E3-C84B369ABE41.html",
							"GUID-FC8C727E-1368-48E2-88E3-C84B369ABE41.html",
							"GUID-FC8C727E-1368-48E2-88E3-C84B369ABE41.html",
							"GUID-FC8C727E-1368-48E2-88E3-C84B369ABE41.html",
							"GUID-FC8C727E-1368-48E2-88E3-C84B369ABE41.html",
							"GUID-FC8C727E-1368-48E2-88E3-C84B369ABE41.html",
							"GUID-FC8C727E-1368-48E2-88E3-C84B369ABE41.html",
							"GUID-BD3DA087-FB55-44E5-B3D7-47966581E0E5.html",
							"GUID-BD3DA087-FB55-44E5-B3D7-47966581E0E5.html",
							"GUID-BD3DA087-FB55-44E5-B3D7-47966581E0E5.html",
							"GUID-BD3DA087-FB55-44E5-B3D7-47966581E0E5.html",
							"GUID-BD3DA087-FB55-44E5-B3D7-47966581E0E5.html",
							"GUID-BD3DA087-FB55-44E5-B3D7-47966581E0E5.html",
							"GUID-BD3DA087-FB55-44E5-B3D7-47966581E0E5.html",
							"GUID-509CACEA-CB11-45C5-89F1-A1744632EECA.html",
							"GUID-509CACEA-CB11-45C5-89F1-A1744632EECA.html",
							"GUID-509CACEA-CB11-45C5-89F1-A1744632EECA.html",
							"GUID-509CACEA-CB11-45C5-89F1-A1744632EECA.html",
							"GUID-509CACEA-CB11-45C5-89F1-A1744632EECA.html",
							"GUID-509CACEA-CB11-45C5-89F1-A1744632EECA.html",
							"GUID-509CACEA-CB11-45C5-89F1-A1744632EECA.html",
							"GUID-2057DC7F-AF3F-4DA1-BBA9-E086A5B949E1.html",
							"GUID-2057DC7F-AF3F-4DA1-BBA9-E086A5B949E1.html",
							"GUID-2057DC7F-AF3F-4DA1-BBA9-E086A5B949E1.html",
							"GUID-2057DC7F-AF3F-4DA1-BBA9-E086A5B949E1.html",
							"GUID-2057DC7F-AF3F-4DA1-BBA9-E086A5B949E1.html",
							"GUID-2057DC7F-AF3F-4DA1-BBA9-E086A5B949E1.html",
							"GUID-2057DC7F-AF3F-4DA1-BBA9-E086A5B949E1.html",
							"GUID-8F64B44C-AAE7-48E6-A1DF-EA5D649F655D.html",
							"GUID-8F64B44C-AAE7-48E6-A1DF-EA5D649F655D.html",
							"GUID-8F64B44C-AAE7-48E6-A1DF-EA5D649F655D.html",
							"GUID-8F64B44C-AAE7-48E6-A1DF-EA5D649F655D.html",
							"GUID-8F64B44C-AAE7-48E6-A1DF-EA5D649F655D.html",
							"GUID-8F64B44C-AAE7-48E6-A1DF-EA5D649F655D.html",
							"GUID-8F64B44C-AAE7-48E6-A1DF-EA5D649F655D.html",
							"GUID-DAC3E906-7325-456B-A67A-B5F9FD901AC3.html",
							"GUID-DAC3E906-7325-456B-A67A-B5F9FD901AC3.html",
							"GUID-DAC3E906-7325-456B-A67A-B5F9FD901AC3.html",
							"GUID-DAC3E906-7325-456B-A67A-B5F9FD901AC3.html",
							"GUID-DAC3E906-7325-456B-A67A-B5F9FD901AC3.html",
							"GUID-DAC3E906-7325-456B-A67A-B5F9FD901AC3.html",
							"GUID-DAC3E906-7325-456B-A67A-B5F9FD901AC3.html",
							"GUID-6D8C930C-02AE-4657-B161-09CD0578C2E5.html",
							"GUID-6D8C930C-02AE-4657-B161-09CD0578C2E5.html",
							"GUID-6D8C930C-02AE-4657-B161-09CD0578C2E5.html",
							"GUID-6D8C930C-02AE-4657-B161-09CD0578C2E5.html",
							"GUID-6D8C930C-02AE-4657-B161-09CD0578C2E5.html",
							"GUID-6D8C930C-02AE-4657-B161-09CD0578C2E5.html",
							"GUID-6D8C930C-02AE-4657-B161-09CD0578C2E5.html",
							"GUID-1A26E4B2-B446-450A-BADF-0B0C5549FBA2.html",
							"GUID-1A26E4B2-B446-450A-BADF-0B0C5549FBA2.html",
							"GUID-1A26E4B2-B446-450A-BADF-0B0C5549FBA2.html",
							"GUID-1A26E4B2-B446-450A-BADF-0B0C5549FBA2.html",
							"GUID-1A26E4B2-B446-450A-BADF-0B0C5549FBA2.html",
							"GUID-1A26E4B2-B446-450A-BADF-0B0C5549FBA2.html",
							"GUID-1A26E4B2-B446-450A-BADF-0B0C5549FBA2.html",
							"GUID-BE94C6F4-3546-4F08-ACFC-B47A03E1E8E0.html",
							"GUID-BE94C6F4-3546-4F08-ACFC-B47A03E1E8E0.html",
							"GUID-BE94C6F4-3546-4F08-ACFC-B47A03E1E8E0.html",
							"GUID-BE94C6F4-3546-4F08-ACFC-B47A03E1E8E0.html",
							"GUID-BE94C6F4-3546-4F08-ACFC-B47A03E1E8E0.html",
							"GUID-BE94C6F4-3546-4F08-ACFC-B47A03E1E8E0.html",
							"GUID-BE94C6F4-3546-4F08-ACFC-B47A03E1E8E0.html",
							"GUID-7E038757-E53C-4A63-82DC-DF79418D9FDB.html",
							"GUID-7E038757-E53C-4A63-82DC-DF79418D9FDB.html",
							"GUID-7E038757-E53C-4A63-82DC-DF79418D9FDB.html",
							"GUID-7E038757-E53C-4A63-82DC-DF79418D9FDB.html",
							"GUID-7E038757-E53C-4A63-82DC-DF79418D9FDB.html",
							"GUID-7E038757-E53C-4A63-82DC-DF79418D9FDB.html",
							"GUID-7E038757-E53C-4A63-82DC-DF79418D9FDB.html",
							"GUID-A670ED1C-14B6-4AC7-9C14-8A16D69DF1A3.html",
							"GUID-A670ED1C-14B6-4AC7-9C14-8A16D69DF1A3.html",
							"GUID-A670ED1C-14B6-4AC7-9C14-8A16D69DF1A3.html",
							"GUID-A670ED1C-14B6-4AC7-9C14-8A16D69DF1A3.html",
							"GUID-A670ED1C-14B6-4AC7-9C14-8A16D69DF1A3.html",
							"GUID-A670ED1C-14B6-4AC7-9C14-8A16D69DF1A3.html",
							"GUID-A670ED1C-14B6-4AC7-9C14-8A16D69DF1A3.html",
							"GUID-3355F72A-0C28-43AD-877C-3B76EA782BCE.html",
							"GUID-3355F72A-0C28-43AD-877C-3B76EA782BCE.html",
							"GUID-3355F72A-0C28-43AD-877C-3B76EA782BCE.html",
							"GUID-3355F72A-0C28-43AD-877C-3B76EA782BCE.html",
							"GUID-3355F72A-0C28-43AD-877C-3B76EA782BCE.html",
							"GUID-3355F72A-0C28-43AD-877C-3B76EA782BCE.html",
							"GUID-3355F72A-0C28-43AD-877C-3B76EA782BCE.html",
							"GUID-BAC812A4-D8EE-4075-9E96-7B08D530A892.html",
							"GUID-BAC812A4-D8EE-4075-9E96-7B08D530A892.html",
							"GUID-BAC812A4-D8EE-4075-9E96-7B08D530A892.html",
							"GUID-BAC812A4-D8EE-4075-9E96-7B08D530A892.html",
							"GUID-BAC812A4-D8EE-4075-9E96-7B08D530A892.html",
							"GUID-9A7A8F80-564A-4CEC-AAB4-460526A7CBDC.html",
							"GUID-9A7A8F80-564A-4CEC-AAB4-460526A7CBDC.html",
							"GUID-9A7A8F80-564A-4CEC-AAB4-460526A7CBDC.html",
							"GUID-9A7A8F80-564A-4CEC-AAB4-460526A7CBDC.html",
							"GUID-9A7A8F80-564A-4CEC-AAB4-460526A7CBDC.html",
							"GUID-D904086C-E292-4B0F-ADB3-0633EAD4AB9B.html",
							"GUID-D904086C-E292-4B0F-ADB3-0633EAD4AB9B.html",
							"GUID-D904086C-E292-4B0F-ADB3-0633EAD4AB9B.html",
							"GUID-D904086C-E292-4B0F-ADB3-0633EAD4AB9B.html",
							"GUID-D904086C-E292-4B0F-ADB3-0633EAD4AB9B.html",
							"GUID-DE47A3D3-C32A-4ED6-A2B7-A5D16DBAEAD0.html",
							"GUID-DE47A3D3-C32A-4ED6-A2B7-A5D16DBAEAD0.html",
							"GUID-DE47A3D3-C32A-4ED6-A2B7-A5D16DBAEAD0.html",
							"GUID-DE47A3D3-C32A-4ED6-A2B7-A5D16DBAEAD0.html",
							"GUID-DE47A3D3-C32A-4ED6-A2B7-A5D16DBAEAD0.html",
							"GUID-ECC769B5-CCD6-4467-A9A4-1472CB4B2E29.html",
							"GUID-ECC769B5-CCD6-4467-A9A4-1472CB4B2E29.html",
							"GUID-ECC769B5-CCD6-4467-A9A4-1472CB4B2E29.html",
							"GUID-ECC769B5-CCD6-4467-A9A4-1472CB4B2E29.html",
							"GUID-ECC769B5-CCD6-4467-A9A4-1472CB4B2E29.html",
							"GUID-49B9B4AE-75C1-466E-A2AA-592725DCA8A8.html",
							"GUID-49B9B4AE-75C1-466E-A2AA-592725DCA8A8.html",
							"GUID-49B9B4AE-75C1-466E-A2AA-592725DCA8A8.html",
							"GUID-49B9B4AE-75C1-466E-A2AA-592725DCA8A8.html",
							"GUID-49B9B4AE-75C1-466E-A2AA-592725DCA8A8.html",
							"GUID-72155962-6FFE-4598-AE78-3C138ECA6E6C.html",
							"GUID-72155962-6FFE-4598-AE78-3C138ECA6E6C.html",
							"GUID-72155962-6FFE-4598-AE78-3C138ECA6E6C.html",
							"GUID-72155962-6FFE-4598-AE78-3C138ECA6E6C.html",
							"GUID-72155962-6FFE-4598-AE78-3C138ECA6E6C.html",
							"GUID-BA2537D5-FF83-42EA-AD5B-2D427CC91976.html",
							"GUID-BA2537D5-FF83-42EA-AD5B-2D427CC91976.html",
							"GUID-BA2537D5-FF83-42EA-AD5B-2D427CC91976.html",
							"GUID-BA2537D5-FF83-42EA-AD5B-2D427CC91976.html",
							"GUID-BA2537D5-FF83-42EA-AD5B-2D427CC91976.html",
							"GUID-1D9C329D-7D74-4D33-A711-A6F33A9714C5.html",
							"GUID-1D9C329D-7D74-4D33-A711-A6F33A9714C5.html",
							"GUID-1D9C329D-7D74-4D33-A711-A6F33A9714C5.html",
							"GUID-1D9C329D-7D74-4D33-A711-A6F33A9714C5.html",
							"GUID-1D9C329D-7D74-4D33-A711-A6F33A9714C5.html",
							"GUID-E830242B-F60A-4E37-99CA-BB6261C77502.html",
							"GUID-E830242B-F60A-4E37-99CA-BB6261C77502.html",
							"GUID-E830242B-F60A-4E37-99CA-BB6261C77502.html",
							"GUID-E830242B-F60A-4E37-99CA-BB6261C77502.html",
							"GUID-E830242B-F60A-4E37-99CA-BB6261C77502.html",
							"GUID-70F2B75F-672C-4723-84A5-9C5065059760.html",
							"GUID-70F2B75F-672C-4723-84A5-9C5065059760.html",
							"GUID-70F2B75F-672C-4723-84A5-9C5065059760.html",
							"GUID-70F2B75F-672C-4723-84A5-9C5065059760.html",
							"GUID-70F2B75F-672C-4723-84A5-9C5065059760.html",
							"GUID-560E0AF3-D3EA-43B8-92D8-A7E3CBB2FDDA.html",
							"GUID-560E0AF3-D3EA-43B8-92D8-A7E3CBB2FDDA.html",
							"GUID-560E0AF3-D3EA-43B8-92D8-A7E3CBB2FDDA.html",
							"GUID-560E0AF3-D3EA-43B8-92D8-A7E3CBB2FDDA.html",
							"GUID-560E0AF3-D3EA-43B8-92D8-A7E3CBB2FDDA.html",
							"GUID-ECF2920E-DC50-497B-8D2F-318D08D4C97F.html",
							"GUID-ECF2920E-DC50-497B-8D2F-318D08D4C97F.html",
							"GUID-ECF2920E-DC50-497B-8D2F-318D08D4C97F.html",
							"GUID-ECF2920E-DC50-497B-8D2F-318D08D4C97F.html",
							"GUID-ECF2920E-DC50-497B-8D2F-318D08D4C97F.html",
							"GUID-8AC15DAA-ECDD-4386-9F24-C84E3D544C53.html",
							"GUID-8AC15DAA-ECDD-4386-9F24-C84E3D544C53.html",
							"GUID-8AC15DAA-ECDD-4386-9F24-C84E3D544C53.html",
							"GUID-8AC15DAA-ECDD-4386-9F24-C84E3D544C53.html",
							"GUID-8AC15DAA-ECDD-4386-9F24-C84E3D544C53.html",
							"GUID-880E2678-2F2C-49D7-A20E-9D0F43DA8F94.html",
							"GUID-880E2678-2F2C-49D7-A20E-9D0F43DA8F94.html",
							"GUID-880E2678-2F2C-49D7-A20E-9D0F43DA8F94.html",
							"GUID-880E2678-2F2C-49D7-A20E-9D0F43DA8F94.html",
							"GUID-880E2678-2F2C-49D7-A20E-9D0F43DA8F94.html",
							"GUID-D5DA8FED-9161-4241-AC90-02C7928C8DEB.html",
							"GUID-D5DA8FED-9161-4241-AC90-02C7928C8DEB.html",
							"GUID-D5DA8FED-9161-4241-AC90-02C7928C8DEB.html",
							"GUID-D5DA8FED-9161-4241-AC90-02C7928C8DEB.html",
							"GUID-D5DA8FED-9161-4241-AC90-02C7928C8DEB.html",
							"GUID-D5DA8FED-9161-4241-AC90-02C7928C8DEB.html",
							"GUID-D5DA8FED-9161-4241-AC90-02C7928C8DEB.html",
							"GUID-AB36B81D-DB1C-43F0-950E-1E302FC77832.html",
							"GUID-ABD91B38-9ECB-4213-A666-941516E038EE.html",
							"GUID-ABD91B38-9ECB-4213-A666-941516E038EE.html",
							"GUID-ABD91B38-9ECB-4213-A666-941516E038EE.html",
							"GUID-ABD91B38-9ECB-4213-A666-941516E038EE.html",
							"GUID-ABD91B38-9ECB-4213-A666-941516E038EE.html",
							"GUID-ABD91B38-9ECB-4213-A666-941516E038EE.html",
							"GUID-ABD91B38-9ECB-4213-A666-941516E038EE.html",
							"GUID-ABD91B38-9ECB-4213-A666-941516E038EE.html",
							"GUID-ABD91B38-9ECB-4213-A666-941516E038EE.html",
							"GUID-FAFE78A4-7186-4E04-A894-E61BF91073CB.html",
							"GUID-FAFE78A4-7186-4E04-A894-E61BF91073CB.html",
							"GUID-FAFE78A4-7186-4E04-A894-E61BF91073CB.html",
							"GUID-FAFE78A4-7186-4E04-A894-E61BF91073CB.html",
							"GUID-FAFE78A4-7186-4E04-A894-E61BF91073CB.html",
							"GUID-FAFE78A4-7186-4E04-A894-E61BF91073CB.html",
							"GUID-FAFE78A4-7186-4E04-A894-E61BF91073CB.html",
							"GUID-FAFE78A4-7186-4E04-A894-E61BF91073CB.html",
							"GUID-FAFE78A4-7186-4E04-A894-E61BF91073CB.html",
							"GUID-E7E39F47-6676-4268-B721-B350E605401A.html",
							"GUID-E7E39F47-6676-4268-B721-B350E605401A.html",
							"GUID-E7E39F47-6676-4268-B721-B350E605401A.html",
							"GUID-E7E39F47-6676-4268-B721-B350E605401A.html",
							"GUID-E7E39F47-6676-4268-B721-B350E605401A.html",
							"GUID-E7E39F47-6676-4268-B721-B350E605401A.html",
							"GUID-E7E39F47-6676-4268-B721-B350E605401A.html",
							"GUID-E7E39F47-6676-4268-B721-B350E605401A.html",
							"GUID-E7E39F47-6676-4268-B721-B350E605401A.html",
							"GUID-DF3F607C-94A8-4128-BD33-67F4EA20CDAE.html",
							"GUID-DF3F607C-94A8-4128-BD33-67F4EA20CDAE.html",
							"GUID-DF3F607C-94A8-4128-BD33-67F4EA20CDAE.html",
							"GUID-DF3F607C-94A8-4128-BD33-67F4EA20CDAE.html",
							"GUID-DF3F607C-94A8-4128-BD33-67F4EA20CDAE.html",
							"GUID-DF3F607C-94A8-4128-BD33-67F4EA20CDAE.html",
							"GUID-DF3F607C-94A8-4128-BD33-67F4EA20CDAE.html",
							"GUID-DF3F607C-94A8-4128-BD33-67F4EA20CDAE.html",
							"GUID-DF3F607C-94A8-4128-BD33-67F4EA20CDAE.html",
							"GUID-70BE98A1-DDB1-4404-A652-92F1D18E08FB.html",
							"GUID-70BE98A1-DDB1-4404-A652-92F1D18E08FB.html",
							"GUID-70BE98A1-DDB1-4404-A652-92F1D18E08FB.html",
							"GUID-70BE98A1-DDB1-4404-A652-92F1D18E08FB.html",
							"GUID-70BE98A1-DDB1-4404-A652-92F1D18E08FB.html",
							"GUID-70BE98A1-DDB1-4404-A652-92F1D18E08FB.html",
							"GUID-70BE98A1-DDB1-4404-A652-92F1D18E08FB.html",
							"GUID-70BE98A1-DDB1-4404-A652-92F1D18E08FB.html",
							"GUID-70BE98A1-DDB1-4404-A652-92F1D18E08FB.html",
							"GUID-3E372BF3-7317-4702-8110-7947FF78FE3D.html",
							"GUID-3E372BF3-7317-4702-8110-7947FF78FE3D.html",
							"GUID-3E372BF3-7317-4702-8110-7947FF78FE3D.html",
							"GUID-3E372BF3-7317-4702-8110-7947FF78FE3D.html",
							"GUID-3E372BF3-7317-4702-8110-7947FF78FE3D.html",
							"GUID-3E372BF3-7317-4702-8110-7947FF78FE3D.html",
							"GUID-3E372BF3-7317-4702-8110-7947FF78FE3D.html",
							"GUID-3E372BF3-7317-4702-8110-7947FF78FE3D.html",
							"GUID-3E372BF3-7317-4702-8110-7947FF78FE3D.html",
							"GUID-D88B05BC-0C28-4155-9CA2-21B6CC68705D.html",
							"GUID-D88B05BC-0C28-4155-9CA2-21B6CC68705D.html",
							"GUID-D88B05BC-0C28-4155-9CA2-21B6CC68705D.html",
							"GUID-D88B05BC-0C28-4155-9CA2-21B6CC68705D.html",
							"GUID-D88B05BC-0C28-4155-9CA2-21B6CC68705D.html",
							"GUID-D88B05BC-0C28-4155-9CA2-21B6CC68705D.html",
							"GUID-D88B05BC-0C28-4155-9CA2-21B6CC68705D.html",
							"GUID-D88B05BC-0C28-4155-9CA2-21B6CC68705D.html",
							"GUID-D88B05BC-0C28-4155-9CA2-21B6CC68705D.html",
							"GUID-FC8CE371-74D2-415E-9E76-F07C14864558.html",
							"GUID-FC8CE371-74D2-415E-9E76-F07C14864558.html",
							"GUID-FC8CE371-74D2-415E-9E76-F07C14864558.html",
							"GUID-FC8CE371-74D2-415E-9E76-F07C14864558.html",
							"GUID-FC8CE371-74D2-415E-9E76-F07C14864558.html",
							"GUID-FC8CE371-74D2-415E-9E76-F07C14864558.html",
							"GUID-FC8CE371-74D2-415E-9E76-F07C14864558.html",
							"GUID-FC8CE371-74D2-415E-9E76-F07C14864558.html",
							"GUID-FC8CE371-74D2-415E-9E76-F07C14864558.html",
							"GUID-733684FD-532D-46C1-A6DD-C7BA03ACA9F1.html",
							"GUID-733684FD-532D-46C1-A6DD-C7BA03ACA9F1.html",
							"GUID-733684FD-532D-46C1-A6DD-C7BA03ACA9F1.html",
							"GUID-733684FD-532D-46C1-A6DD-C7BA03ACA9F1.html",
							"GUID-733684FD-532D-46C1-A6DD-C7BA03ACA9F1.html",
							"GUID-733684FD-532D-46C1-A6DD-C7BA03ACA9F1.html",
							"GUID-733684FD-532D-46C1-A6DD-C7BA03ACA9F1.html",
							"GUID-733684FD-532D-46C1-A6DD-C7BA03ACA9F1.html",
							"GUID-733684FD-532D-46C1-A6DD-C7BA03ACA9F1.html",
							"GUID-67EEB8E1-663A-40CA-8654-AEA0B7F228F3.html",
							"GUID-67EEB8E1-663A-40CA-8654-AEA0B7F228F3.html",
							"GUID-67EEB8E1-663A-40CA-8654-AEA0B7F228F3.html",
							"GUID-67EEB8E1-663A-40CA-8654-AEA0B7F228F3.html",
							"GUID-67EEB8E1-663A-40CA-8654-AEA0B7F228F3.html",
							"GUID-67EEB8E1-663A-40CA-8654-AEA0B7F228F3.html",
							"GUID-67EEB8E1-663A-40CA-8654-AEA0B7F228F3.html",
							"GUID-67EEB8E1-663A-40CA-8654-AEA0B7F228F3.html",
							"GUID-67EEB8E1-663A-40CA-8654-AEA0B7F228F3.html",
							"GUID-7171ACD5-F746-4998-B5AA-7796CFD19E14.html",
							"GUID-7171ACD5-F746-4998-B5AA-7796CFD19E14.html",
							"GUID-7171ACD5-F746-4998-B5AA-7796CFD19E14.html",
							"GUID-7171ACD5-F746-4998-B5AA-7796CFD19E14.html",
							"GUID-7171ACD5-F746-4998-B5AA-7796CFD19E14.html",
							"GUID-7171ACD5-F746-4998-B5AA-7796CFD19E14.html",
							"GUID-7171ACD5-F746-4998-B5AA-7796CFD19E14.html",
							"GUID-7171ACD5-F746-4998-B5AA-7796CFD19E14.html",
							"GUID-7171ACD5-F746-4998-B5AA-7796CFD19E14.html",
							"GUID-511CB2EB-3A00-4A56-8D63-49E5181E6890.html",
							"GUID-511CB2EB-3A00-4A56-8D63-49E5181E6890.html",
							"GUID-511CB2EB-3A00-4A56-8D63-49E5181E6890.html",
							"GUID-511CB2EB-3A00-4A56-8D63-49E5181E6890.html",
							"GUID-511CB2EB-3A00-4A56-8D63-49E5181E6890.html",
							"GUID-89291D9B-92F4-4472-BAE0-9F007571CD35.html",
							"GUID-35403BF1-6564-4D1F-BEFB-D176CB53F364.html",
							"GUID-35403BF1-6564-4D1F-BEFB-D176CB53F364.html",
							"GUID-35403BF1-6564-4D1F-BEFB-D176CB53F364.html",
							"GUID-35403BF1-6564-4D1F-BEFB-D176CB53F364.html",
							"GUID-35403BF1-6564-4D1F-BEFB-D176CB53F364.html",
							"GUID-35403BF1-6564-4D1F-BEFB-D176CB53F364.html",
							"GUID-35403BF1-6564-4D1F-BEFB-D176CB53F364.html",
							"GUID-35403BF1-6564-4D1F-BEFB-D176CB53F364.html",
							"GUID-35403BF1-6564-4D1F-BEFB-D176CB53F364.html",
							"GUID-B563DED5-2F0D-400A-8930-AA532960748D.html",
							"GUID-B563DED5-2F0D-400A-8930-AA532960748D.html",
							"GUID-B563DED5-2F0D-400A-8930-AA532960748D.html",
							"GUID-B563DED5-2F0D-400A-8930-AA532960748D.html",
							"GUID-B563DED5-2F0D-400A-8930-AA532960748D.html",
							"GUID-B563DED5-2F0D-400A-8930-AA532960748D.html",
							"GUID-B563DED5-2F0D-400A-8930-AA532960748D.html",
							"GUID-B563DED5-2F0D-400A-8930-AA532960748D.html",
							"GUID-B563DED5-2F0D-400A-8930-AA532960748D.html",
							"GUID-DDB3860A-E629-4991-9663-6A0C5EA37EC5.html",
							"GUID-DDB3860A-E629-4991-9663-6A0C5EA37EC5.html",
							"GUID-DDB3860A-E629-4991-9663-6A0C5EA37EC5.html",
							"GUID-DDB3860A-E629-4991-9663-6A0C5EA37EC5.html",
							"GUID-DDB3860A-E629-4991-9663-6A0C5EA37EC5.html",
							"GUID-DDB3860A-E629-4991-9663-6A0C5EA37EC5.html",
							"GUID-DDB3860A-E629-4991-9663-6A0C5EA37EC5.html",
							"GUID-DDB3860A-E629-4991-9663-6A0C5EA37EC5.html",
							"GUID-DDB3860A-E629-4991-9663-6A0C5EA37EC5.html",
							"GUID-36B53A8B-33C3-482A-8746-A5027BEA411C.html",
							"GUID-36B53A8B-33C3-482A-8746-A5027BEA411C.html",
							"GUID-36B53A8B-33C3-482A-8746-A5027BEA411C.html",
							"GUID-36B53A8B-33C3-482A-8746-A5027BEA411C.html",
							"GUID-36B53A8B-33C3-482A-8746-A5027BEA411C.html",
							"GUID-36B53A8B-33C3-482A-8746-A5027BEA411C.html",
							"GUID-36B53A8B-33C3-482A-8746-A5027BEA411C.html",
							"GUID-36B53A8B-33C3-482A-8746-A5027BEA411C.html",
							"GUID-36B53A8B-33C3-482A-8746-A5027BEA411C.html",
							"GUID-03A5D157-22DC-462D-B525-18C01DBB424C.html",
							"GUID-03A5D157-22DC-462D-B525-18C01DBB424C.html",
							"GUID-03A5D157-22DC-462D-B525-18C01DBB424C.html",
							"GUID-03A5D157-22DC-462D-B525-18C01DBB424C.html",
							"GUID-03A5D157-22DC-462D-B525-18C01DBB424C.html",
							"GUID-03A5D157-22DC-462D-B525-18C01DBB424C.html",
							"GUID-03A5D157-22DC-462D-B525-18C01DBB424C.html",
							"GUID-03A5D157-22DC-462D-B525-18C01DBB424C.html",
							"GUID-03A5D157-22DC-462D-B525-18C01DBB424C.html",
							"GUID-381FBF75-747C-4701-9D8E-CD3E21EE06B5.html",
							"GUID-381FBF75-747C-4701-9D8E-CD3E21EE06B5.html",
							"GUID-381FBF75-747C-4701-9D8E-CD3E21EE06B5.html",
							"GUID-381FBF75-747C-4701-9D8E-CD3E21EE06B5.html",
							"GUID-381FBF75-747C-4701-9D8E-CD3E21EE06B5.html",
							"GUID-381FBF75-747C-4701-9D8E-CD3E21EE06B5.html",
							"GUID-381FBF75-747C-4701-9D8E-CD3E21EE06B5.html",
							"GUID-381FBF75-747C-4701-9D8E-CD3E21EE06B5.html",
							"GUID-381FBF75-747C-4701-9D8E-CD3E21EE06B5.html",
							"GUID-2F9179BF-AB7D-4BE3-9794-949D010FA17F.html",
							"GUID-2F9179BF-AB7D-4BE3-9794-949D010FA17F.html",
							"GUID-2F9179BF-AB7D-4BE3-9794-949D010FA17F.html",
							"GUID-2F9179BF-AB7D-4BE3-9794-949D010FA17F.html",
							"GUID-2F9179BF-AB7D-4BE3-9794-949D010FA17F.html",
							"GUID-2F9179BF-AB7D-4BE3-9794-949D010FA17F.html",
							"GUID-2F9179BF-AB7D-4BE3-9794-949D010FA17F.html",
							"GUID-2F9179BF-AB7D-4BE3-9794-949D010FA17F.html",
							"GUID-2F9179BF-AB7D-4BE3-9794-949D010FA17F.html",
							"GUID-FA52B94D-545D-4858-A406-2F8259350271.html",
							"GUID-FA52B94D-545D-4858-A406-2F8259350271.html",
							"GUID-FA52B94D-545D-4858-A406-2F8259350271.html",
							"GUID-FA52B94D-545D-4858-A406-2F8259350271.html",
							"GUID-FA52B94D-545D-4858-A406-2F8259350271.html",
							"GUID-FA52B94D-545D-4858-A406-2F8259350271.html",
							"GUID-FA52B94D-545D-4858-A406-2F8259350271.html",
							"GUID-FA52B94D-545D-4858-A406-2F8259350271.html",
							"GUID-FA52B94D-545D-4858-A406-2F8259350271.html",
							"GUID-1F826206-4C2A-4708-B811-DF8392691075.html",
							"GUID-1F826206-4C2A-4708-B811-DF8392691075.html",
							"GUID-1F826206-4C2A-4708-B811-DF8392691075.html",
							"GUID-1F826206-4C2A-4708-B811-DF8392691075.html",
							"GUID-1F826206-4C2A-4708-B811-DF8392691075.html",
							"GUID-0A239E79-52DB-485D-915B-C927B3D714F6.html",
							"GUID-0A239E79-52DB-485D-915B-C927B3D714F6.html",
							"GUID-0A239E79-52DB-485D-915B-C927B3D714F6.html",
							"GUID-0A239E79-52DB-485D-915B-C927B3D714F6.html",
							"GUID-0A239E79-52DB-485D-915B-C927B3D714F6.html",
							"GUID-9B151BD6-CAB6-497E-867F-9D9543CB51A6.html",
							"GUID-B464623F-D8AA-489B-80DB-52B72F040893.html",
							"GUID-B464623F-D8AA-489B-80DB-52B72F040893.html",
							"GUID-B464623F-D8AA-489B-80DB-52B72F040893.html",
							"GUID-B464623F-D8AA-489B-80DB-52B72F040893.html",
							"GUID-B464623F-D8AA-489B-80DB-52B72F040893.html",
							"GUID-B464623F-D8AA-489B-80DB-52B72F040893.html",
							"GUID-B464623F-D8AA-489B-80DB-52B72F040893.html",
							"GUID-B464623F-D8AA-489B-80DB-52B72F040893.html",
							"GUID-B464623F-D8AA-489B-80DB-52B72F040893.html",
							"GUID-05D0B89A-EE4D-46D4-B58F-7402C56061AE.html",
							"GUID-9D474B7C-D749-4DD6-A012-FE94C039324E.html",
							"GUID-EE734734-7914-41BF-8AF2-8275506BBED4.html",
							"GUID-BA5815F6-F9D7-43BD-8F05-65CC6E199C25.html",
							"GUID-3D84F884-122D-4A4A-95DA-DFD8C2E84650.html",
							"GUID-4483443F-5DCE-47F2-A7A8-EEA1BA48B089.html",
							"GUID-4483443F-5DCE-47F2-A7A8-EEA1BA48B089.html",
							"GUID-4483443F-5DCE-47F2-A7A8-EEA1BA48B089.html",
							"GUID-4483443F-5DCE-47F2-A7A8-EEA1BA48B089.html",
							"GUID-4483443F-5DCE-47F2-A7A8-EEA1BA48B089.html",
							"GUID-4483443F-5DCE-47F2-A7A8-EEA1BA48B089.html",
							"GUID-4483443F-5DCE-47F2-A7A8-EEA1BA48B089.html",
							"GUID-4483443F-5DCE-47F2-A7A8-EEA1BA48B089.html",
							"GUID-F27448AA-BF71-4DBC-ACDD-B2CAA20AB723.html",
							"GUID-F27448AA-BF71-4DBC-ACDD-B2CAA20AB723.html",
							"GUID-F27448AA-BF71-4DBC-ACDD-B2CAA20AB723.html",
							"GUID-F27448AA-BF71-4DBC-ACDD-B2CAA20AB723.html",
							"GUID-F27448AA-BF71-4DBC-ACDD-B2CAA20AB723.html",
							"GUID-F27448AA-BF71-4DBC-ACDD-B2CAA20AB723.html",
							"GUID-F27448AA-BF71-4DBC-ACDD-B2CAA20AB723.html",
							"GUID-F27448AA-BF71-4DBC-ACDD-B2CAA20AB723.html",
							"GUID-F27448AA-BF71-4DBC-ACDD-B2CAA20AB723.html",
							"GUID-15105BA3-7A7E-45B3-B3ED-61370B648774.html",
							"GUID-15105BA3-7A7E-45B3-B3ED-61370B648774.html",
							"GUID-15105BA3-7A7E-45B3-B3ED-61370B648774.html",
							"GUID-15105BA3-7A7E-45B3-B3ED-61370B648774.html",
							"GUID-15105BA3-7A7E-45B3-B3ED-61370B648774.html",
							"GUID-15105BA3-7A7E-45B3-B3ED-61370B648774.html",
							"GUID-15105BA3-7A7E-45B3-B3ED-61370B648774.html",
							"GUID-15105BA3-7A7E-45B3-B3ED-61370B648774.html",
							"GUID-15105BA3-7A7E-45B3-B3ED-61370B648774.html",
							"GUID-5AB08537-241F-4458-9E50-2B43C8B16BB9.html",
							"GUID-5AB08537-241F-4458-9E50-2B43C8B16BB9.html",
							"GUID-5AB08537-241F-4458-9E50-2B43C8B16BB9.html",
							"GUID-5AB08537-241F-4458-9E50-2B43C8B16BB9.html",
							"GUID-5AB08537-241F-4458-9E50-2B43C8B16BB9.html",
							"GUID-5AB08537-241F-4458-9E50-2B43C8B16BB9.html",
							"GUID-5AB08537-241F-4458-9E50-2B43C8B16BB9.html",
							"GUID-5AB08537-241F-4458-9E50-2B43C8B16BB9.html",
							"GUID-5AB08537-241F-4458-9E50-2B43C8B16BB9.html",
							"GUID-854CFE11-D8CD-4630-ABB5-6EF7342AE6F0.html",
							"GUID-854CFE11-D8CD-4630-ABB5-6EF7342AE6F0.html",
							"GUID-854CFE11-D8CD-4630-ABB5-6EF7342AE6F0.html",
							"GUID-854CFE11-D8CD-4630-ABB5-6EF7342AE6F0.html",
							"GUID-854CFE11-D8CD-4630-ABB5-6EF7342AE6F0.html",
							"GUID-854CFE11-D8CD-4630-ABB5-6EF7342AE6F0.html",
							"GUID-854CFE11-D8CD-4630-ABB5-6EF7342AE6F0.html",
							"GUID-854CFE11-D8CD-4630-ABB5-6EF7342AE6F0.html",
							"GUID-854CFE11-D8CD-4630-ABB5-6EF7342AE6F0.html",
							"GUID-ED13CFBE-FE20-4D83-8330-A69BE679FE4D.html",
							"GUID-ED13CFBE-FE20-4D83-8330-A69BE679FE4D.html",
							"GUID-ED13CFBE-FE20-4D83-8330-A69BE679FE4D.html",
							"GUID-ED13CFBE-FE20-4D83-8330-A69BE679FE4D.html",
							"GUID-ED13CFBE-FE20-4D83-8330-A69BE679FE4D.html",
							"GUID-ED13CFBE-FE20-4D83-8330-A69BE679FE4D.html",
							"GUID-ED13CFBE-FE20-4D83-8330-A69BE679FE4D.html",
							"GUID-ED13CFBE-FE20-4D83-8330-A69BE679FE4D.html",
							"GUID-ED13CFBE-FE20-4D83-8330-A69BE679FE4D.html",
							"GUID-1A398EB1-C3DC-4A9A-9112-8D4400166704.html",
							"GUID-1A398EB1-C3DC-4A9A-9112-8D4400166704.html",
							"GUID-1A398EB1-C3DC-4A9A-9112-8D4400166704.html",
							"GUID-1A398EB1-C3DC-4A9A-9112-8D4400166704.html",
							"GUID-1A398EB1-C3DC-4A9A-9112-8D4400166704.html",
							"GUID-1A398EB1-C3DC-4A9A-9112-8D4400166704.html",
							"GUID-1A398EB1-C3DC-4A9A-9112-8D4400166704.html",
							"GUID-1A398EB1-C3DC-4A9A-9112-8D4400166704.html",
							"GUID-1A398EB1-C3DC-4A9A-9112-8D4400166704.html",
							"GUID-F1F40189-8893-4610-82E4-AA9A9F29CAEE.html",
							"GUID-F1F40189-8893-4610-82E4-AA9A9F29CAEE.html",
							"GUID-F1F40189-8893-4610-82E4-AA9A9F29CAEE.html",
							"GUID-F1F40189-8893-4610-82E4-AA9A9F29CAEE.html",
							"GUID-F1F40189-8893-4610-82E4-AA9A9F29CAEE.html",
							"GUID-F1F40189-8893-4610-82E4-AA9A9F29CAEE.html",
							"GUID-F1F40189-8893-4610-82E4-AA9A9F29CAEE.html",
							"GUID-F1F40189-8893-4610-82E4-AA9A9F29CAEE.html",
							"GUID-F1F40189-8893-4610-82E4-AA9A9F29CAEE.html",
							"GUID-0216C2E2-D32B-431B-8469-CEEE41248296.html",
							"GUID-0216C2E2-D32B-431B-8469-CEEE41248296.html",
							"GUID-0216C2E2-D32B-431B-8469-CEEE41248296.html",
							"GUID-0216C2E2-D32B-431B-8469-CEEE41248296.html",
							"GUID-0216C2E2-D32B-431B-8469-CEEE41248296.html",
							"GUID-0216C2E2-D32B-431B-8469-CEEE41248296.html",
							"GUID-0216C2E2-D32B-431B-8469-CEEE41248296.html",
							"GUID-0216C2E2-D32B-431B-8469-CEEE41248296.html",
							"GUID-0216C2E2-D32B-431B-8469-CEEE41248296.html",
							"GUID-5DC16D9D-8D76-476D-8F4E-D5C261E8CEE0.html",
							"GUID-5DC16D9D-8D76-476D-8F4E-D5C261E8CEE0.html",
							"GUID-5DC16D9D-8D76-476D-8F4E-D5C261E8CEE0.html",
							"GUID-5DC16D9D-8D76-476D-8F4E-D5C261E8CEE0.html",
							"GUID-5DC16D9D-8D76-476D-8F4E-D5C261E8CEE0.html",
							"GUID-5DC16D9D-8D76-476D-8F4E-D5C261E8CEE0.html",
							"GUID-5DC16D9D-8D76-476D-8F4E-D5C261E8CEE0.html",
							"GUID-5DC16D9D-8D76-476D-8F4E-D5C261E8CEE0.html",
							"GUID-5DC16D9D-8D76-476D-8F4E-D5C261E8CEE0.html",
							"GUID-55F16D8C-B670-4D4F-A2C3-41AEC77231E6.html",
							"GUID-55F16D8C-B670-4D4F-A2C3-41AEC77231E6.html",
							"GUID-55F16D8C-B670-4D4F-A2C3-41AEC77231E6.html",
							"GUID-55F16D8C-B670-4D4F-A2C3-41AEC77231E6.html",
							"GUID-55F16D8C-B670-4D4F-A2C3-41AEC77231E6.html",
							"GUID-55F16D8C-B670-4D4F-A2C3-41AEC77231E6.html",
							"GUID-55F16D8C-B670-4D4F-A2C3-41AEC77231E6.html",
							"GUID-55F16D8C-B670-4D4F-A2C3-41AEC77231E6.html",
							"GUID-55F16D8C-B670-4D4F-A2C3-41AEC77231E6.html",
							"GUID-EB747548-B871-407B-B244-0FF587C704C2.html",
							"GUID-EB747548-B871-407B-B244-0FF587C704C2.html",
							"GUID-EB747548-B871-407B-B244-0FF587C704C2.html",
							"GUID-EB747548-B871-407B-B244-0FF587C704C2.html",
							"GUID-EB747548-B871-407B-B244-0FF587C704C2.html",
							"GUID-EB747548-B871-407B-B244-0FF587C704C2.html",
							"GUID-EB747548-B871-407B-B244-0FF587C704C2.html",
							"GUID-EB747548-B871-407B-B244-0FF587C704C2.html",
							"GUID-EB747548-B871-407B-B244-0FF587C704C2.html",
							"GUID-728877D4-5B54-4990-9C94-A4A80BBBEBD6.html",
							"GUID-728877D4-5B54-4990-9C94-A4A80BBBEBD6.html",
							"GUID-728877D4-5B54-4990-9C94-A4A80BBBEBD6.html",
							"GUID-728877D4-5B54-4990-9C94-A4A80BBBEBD6.html",
							"GUID-728877D4-5B54-4990-9C94-A4A80BBBEBD6.html",
							"GUID-728877D4-5B54-4990-9C94-A4A80BBBEBD6.html",
							"GUID-728877D4-5B54-4990-9C94-A4A80BBBEBD6.html",
							"GUID-728877D4-5B54-4990-9C94-A4A80BBBEBD6.html",
							"GUID-728877D4-5B54-4990-9C94-A4A80BBBEBD6.html",
							"GUID-C1322D50-D28A-4AF1-82D7-15BA0ED96765.html",
							"GUID-C1322D50-D28A-4AF1-82D7-15BA0ED96765.html",
							"GUID-C1322D50-D28A-4AF1-82D7-15BA0ED96765.html",
							"GUID-C1322D50-D28A-4AF1-82D7-15BA0ED96765.html",
							"GUID-C1322D50-D28A-4AF1-82D7-15BA0ED96765.html",
							"GUID-C1322D50-D28A-4AF1-82D7-15BA0ED96765.html",
							"GUID-C1322D50-D28A-4AF1-82D7-15BA0ED96765.html",
							"GUID-C1322D50-D28A-4AF1-82D7-15BA0ED96765.html",
							"GUID-C1322D50-D28A-4AF1-82D7-15BA0ED96765.html",
							"GUID-CE8A08B3-44E0-4442-8BC5-B78123047EB6.html",
							"GUID-CE8A08B3-44E0-4442-8BC5-B78123047EB6.html",
							"GUID-CE8A08B3-44E0-4442-8BC5-B78123047EB6.html",
							"GUID-CE8A08B3-44E0-4442-8BC5-B78123047EB6.html",
							"GUID-CE8A08B3-44E0-4442-8BC5-B78123047EB6.html",
							"GUID-CE8A08B3-44E0-4442-8BC5-B78123047EB6.html",
							"GUID-CE8A08B3-44E0-4442-8BC5-B78123047EB6.html",
							"GUID-CE8A08B3-44E0-4442-8BC5-B78123047EB6.html",
							"GUID-CE8A08B3-44E0-4442-8BC5-B78123047EB6.html",
							"GUID-51FAD95A-A178-457E-829A-4F5E0EF5B8D7.html",
							"GUID-51FAD95A-A178-457E-829A-4F5E0EF5B8D7.html",
							"GUID-51FAD95A-A178-457E-829A-4F5E0EF5B8D7.html",
							"GUID-51FAD95A-A178-457E-829A-4F5E0EF5B8D7.html",
							"GUID-51FAD95A-A178-457E-829A-4F5E0EF5B8D7.html",
							"GUID-51FAD95A-A178-457E-829A-4F5E0EF5B8D7.html",
							"GUID-51FAD95A-A178-457E-829A-4F5E0EF5B8D7.html",
							"GUID-51FAD95A-A178-457E-829A-4F5E0EF5B8D7.html",
							"GUID-51FAD95A-A178-457E-829A-4F5E0EF5B8D7.html",
							"GUID-C620CB5A-6247-420E-A260-5350F62D70F7.html",
							"GUID-C620CB5A-6247-420E-A260-5350F62D70F7.html",
							"GUID-C620CB5A-6247-420E-A260-5350F62D70F7.html",
							"GUID-C620CB5A-6247-420E-A260-5350F62D70F7.html",
							"GUID-C620CB5A-6247-420E-A260-5350F62D70F7.html",
							"GUID-C620CB5A-6247-420E-A260-5350F62D70F7.html",
							"GUID-C620CB5A-6247-420E-A260-5350F62D70F7.html",
							"GUID-C620CB5A-6247-420E-A260-5350F62D70F7.html",
							"GUID-C620CB5A-6247-420E-A260-5350F62D70F7.html",
							"GUID-C5E394FE-B52D-4484-85BD-9C42D1CCB540.html",
							"GUID-C5E394FE-B52D-4484-85BD-9C42D1CCB540.html",
							"GUID-C5E394FE-B52D-4484-85BD-9C42D1CCB540.html",
							"GUID-C5E394FE-B52D-4484-85BD-9C42D1CCB540.html",
							"GUID-C5E394FE-B52D-4484-85BD-9C42D1CCB540.html",
							"GUID-C5E394FE-B52D-4484-85BD-9C42D1CCB540.html",
							"GUID-C5E394FE-B52D-4484-85BD-9C42D1CCB540.html",
							"GUID-C5E394FE-B52D-4484-85BD-9C42D1CCB540.html",
							"GUID-C5E394FE-B52D-4484-85BD-9C42D1CCB540.html",
							"GUID-64C748F5-8A8A-4F85-ACA1-91BACBD20A53.html",
							"GUID-64C748F5-8A8A-4F85-ACA1-91BACBD20A53.html",
							"GUID-64C748F5-8A8A-4F85-ACA1-91BACBD20A53.html",
							"GUID-64C748F5-8A8A-4F85-ACA1-91BACBD20A53.html",
							"GUID-64C748F5-8A8A-4F85-ACA1-91BACBD20A53.html",
							"GUID-64C748F5-8A8A-4F85-ACA1-91BACBD20A53.html",
							"GUID-64C748F5-8A8A-4F85-ACA1-91BACBD20A53.html",
							"GUID-64C748F5-8A8A-4F85-ACA1-91BACBD20A53.html",
							"GUID-64C748F5-8A8A-4F85-ACA1-91BACBD20A53.html",
							"GUID-3966A3D3-92CB-4B70-A673-51EA0BF318F1.html",
							"GUID-3966A3D3-92CB-4B70-A673-51EA0BF318F1.html",
							"GUID-3966A3D3-92CB-4B70-A673-51EA0BF318F1.html",
							"GUID-3966A3D3-92CB-4B70-A673-51EA0BF318F1.html",
							"GUID-3966A3D3-92CB-4B70-A673-51EA0BF318F1.html",
							"GUID-3966A3D3-92CB-4B70-A673-51EA0BF318F1.html",
							"GUID-3966A3D3-92CB-4B70-A673-51EA0BF318F1.html",
							"GUID-3966A3D3-92CB-4B70-A673-51EA0BF318F1.html",
							"GUID-3966A3D3-92CB-4B70-A673-51EA0BF318F1.html",
							"GUID-BF7BCBE3-A362-4DD5-81B5-8A7037353CCC.html",
							"GUID-BF7BCBE3-A362-4DD5-81B5-8A7037353CCC.html",
							"GUID-BF7BCBE3-A362-4DD5-81B5-8A7037353CCC.html",
							"GUID-BF7BCBE3-A362-4DD5-81B5-8A7037353CCC.html",
							"GUID-BF7BCBE3-A362-4DD5-81B5-8A7037353CCC.html",
							"GUID-BF7BCBE3-A362-4DD5-81B5-8A7037353CCC.html",
							"GUID-BF7BCBE3-A362-4DD5-81B5-8A7037353CCC.html",
							"GUID-BF7BCBE3-A362-4DD5-81B5-8A7037353CCC.html",
							"GUID-BF7BCBE3-A362-4DD5-81B5-8A7037353CCC.html",
							"GUID-1017B1C8-B505-4C3E-88C5-676BDB100A87.html",
							"GUID-1017B1C8-B505-4C3E-88C5-676BDB100A87.html",
							"GUID-1017B1C8-B505-4C3E-88C5-676BDB100A87.html",
							"GUID-1017B1C8-B505-4C3E-88C5-676BDB100A87.html",
							"GUID-1017B1C8-B505-4C3E-88C5-676BDB100A87.html",
							"GUID-1017B1C8-B505-4C3E-88C5-676BDB100A87.html",
							"GUID-1017B1C8-B505-4C3E-88C5-676BDB100A87.html",
							"GUID-1017B1C8-B505-4C3E-88C5-676BDB100A87.html",
							"GUID-1017B1C8-B505-4C3E-88C5-676BDB100A87.html",
							"GUID-B7A6EC0C-5131-48B0-AA51-4F396DA97785.html",
							"GUID-B7A6EC0C-5131-48B0-AA51-4F396DA97785.html",
							"GUID-B7A6EC0C-5131-48B0-AA51-4F396DA97785.html",
							"GUID-B7A6EC0C-5131-48B0-AA51-4F396DA97785.html",
							"GUID-B7A6EC0C-5131-48B0-AA51-4F396DA97785.html",
							"GUID-B7A6EC0C-5131-48B0-AA51-4F396DA97785.html",
							"GUID-B7A6EC0C-5131-48B0-AA51-4F396DA97785.html",
							"GUID-B7A6EC0C-5131-48B0-AA51-4F396DA97785.html",
							"GUID-B7A6EC0C-5131-48B0-AA51-4F396DA97785.html",
							"GUID-A235E91D-B728-4F9C-9B77-54B79265196A.html",
							"GUID-A235E91D-B728-4F9C-9B77-54B79265196A.html",
							"GUID-A235E91D-B728-4F9C-9B77-54B79265196A.html",
							"GUID-A235E91D-B728-4F9C-9B77-54B79265196A.html",
							"GUID-A235E91D-B728-4F9C-9B77-54B79265196A.html",
							"GUID-0B4B2BDA-18B7-4F86-908E-5B087BBE6DB4.html",
							"GUID-0B4B2BDA-18B7-4F86-908E-5B087BBE6DB4.html",
							"GUID-0B4B2BDA-18B7-4F86-908E-5B087BBE6DB4.html",
							"GUID-0B4B2BDA-18B7-4F86-908E-5B087BBE6DB4.html",
							"GUID-8ABDCCF3-A786-4FB6-A424-52803779706D.html",
							"GUID-8ABDCCF3-A786-4FB6-A424-52803779706D.html",
							"GUID-8ABDCCF3-A786-4FB6-A424-52803779706D.html",
							"GUID-8ABDCCF3-A786-4FB6-A424-52803779706D.html",
							"GUID-8ABDCCF3-A786-4FB6-A424-52803779706D.html",
							"GUID-C7D1D845-C908-4F60-9BCF-56C32DBEB467.html",
							"GUID-C7D1D845-C908-4F60-9BCF-56C32DBEB467.html",
							"GUID-C7D1D845-C908-4F60-9BCF-56C32DBEB467.html",
							"GUID-C7D1D845-C908-4F60-9BCF-56C32DBEB467.html",
							"GUID-C7D1D845-C908-4F60-9BCF-56C32DBEB467.html",
							"GUID-C89A507B-B9DA-4537-971D-8A44FC2D028E.html",
							"GUID-C89A507B-B9DA-4537-971D-8A44FC2D028E.html",
							"GUID-C89A507B-B9DA-4537-971D-8A44FC2D028E.html",
							"GUID-C89A507B-B9DA-4537-971D-8A44FC2D028E.html",
							"GUID-CB25A98A-1CED-45A3-B538-027D927C97E0.html",
							"GUID-CB25A98A-1CED-45A3-B538-027D927C97E0.html",
							"GUID-CB25A98A-1CED-45A3-B538-027D927C97E0.html",
							"GUID-CB25A98A-1CED-45A3-B538-027D927C97E0.html",
							"GUID-CB25A98A-1CED-45A3-B538-027D927C97E0.html",
							"GUID-CB25A98A-1CED-45A3-B538-027D927C97E0.html",
							"GUID-CB25A98A-1CED-45A3-B538-027D927C97E0.html",
							"GUID-CB25A98A-1CED-45A3-B538-027D927C97E0.html",
							"GUID-CB25A98A-1CED-45A3-B538-027D927C97E0.html",
							"GUID-7249D18B-E049-45D9-96DD-B6329375E344.html",
							"GUID-7D1381D7-9A05-495B-B0A8-D195FA444618.html",
							"GUID-F2389E2B-C0EA-4408-B910-EBC4B92C005F.html",
							"GUID-CA73D5E6-E69E-4ED9-8BAE-47DF7EBB82AB.html",
							"GUID-E082A9CA-FC12-4A79-8A83-E0902DF83721.html",
							"GUID-000B6F77-4664-4A72-9723-F697040A7436.html",
							"GUID-1522E7A9-D0DA-48E9-A893-7AFF88739328.html",
							"GUID-1522E7A9-D0DA-48E9-A893-7AFF88739328.html",
							"GUID-1522E7A9-D0DA-48E9-A893-7AFF88739328.html",
							"GUID-1522E7A9-D0DA-48E9-A893-7AFF88739328.html",
							"GUID-1522E7A9-D0DA-48E9-A893-7AFF88739328.html",
							"GUID-1522E7A9-D0DA-48E9-A893-7AFF88739328.html",
							"GUID-1522E7A9-D0DA-48E9-A893-7AFF88739328.html",
							"GUID-1522E7A9-D0DA-48E9-A893-7AFF88739328.html",
							"GUID-1522E7A9-D0DA-48E9-A893-7AFF88739328.html",
							"GUID-D90F34DE-49C2-4D1F-9762-5555B6F2F06C.html",
							"GUID-D90F34DE-49C2-4D1F-9762-5555B6F2F06C.html",
							"GUID-D90F34DE-49C2-4D1F-9762-5555B6F2F06C.html",
							"GUID-D90F34DE-49C2-4D1F-9762-5555B6F2F06C.html",
							"GUID-D90F34DE-49C2-4D1F-9762-5555B6F2F06C.html",
							"GUID-D90F34DE-49C2-4D1F-9762-5555B6F2F06C.html",
							"GUID-D90F34DE-49C2-4D1F-9762-5555B6F2F06C.html",
							"GUID-D90F34DE-49C2-4D1F-9762-5555B6F2F06C.html",
							"GUID-D90F34DE-49C2-4D1F-9762-5555B6F2F06C.html",
							"GUID-2D66D8A2-D985-4A4B-903C-D713C835DDC3.html",
							"GUID-2D66D8A2-D985-4A4B-903C-D713C835DDC3.html",
							"GUID-2D66D8A2-D985-4A4B-903C-D713C835DDC3.html",
							"GUID-2D66D8A2-D985-4A4B-903C-D713C835DDC3.html",
							"GUID-2D66D8A2-D985-4A4B-903C-D713C835DDC3.html",
							"GUID-2D66D8A2-D985-4A4B-903C-D713C835DDC3.html",
							"GUID-2D66D8A2-D985-4A4B-903C-D713C835DDC3.html",
							"GUID-2D66D8A2-D985-4A4B-903C-D713C835DDC3.html",
							"GUID-2D66D8A2-D985-4A4B-903C-D713C835DDC3.html",
							"GUID-3893EFC2-A6FE-4963-9744-99AF06FA28E9.html",
							"GUID-3893EFC2-A6FE-4963-9744-99AF06FA28E9.html",
							"GUID-3893EFC2-A6FE-4963-9744-99AF06FA28E9.html",
							"GUID-3893EFC2-A6FE-4963-9744-99AF06FA28E9.html",
							"GUID-3893EFC2-A6FE-4963-9744-99AF06FA28E9.html",
							"GUID-3893EFC2-A6FE-4963-9744-99AF06FA28E9.html",
							"GUID-3893EFC2-A6FE-4963-9744-99AF06FA28E9.html",
							"GUID-3893EFC2-A6FE-4963-9744-99AF06FA28E9.html",
							"GUID-3893EFC2-A6FE-4963-9744-99AF06FA28E9.html",
							"GUID-4EBEC168-246F-401E-8D76-A04EACD7EFB9.html",
							"GUID-4EBEC168-246F-401E-8D76-A04EACD7EFB9.html",
							"GUID-4EBEC168-246F-401E-8D76-A04EACD7EFB9.html",
							"GUID-4EBEC168-246F-401E-8D76-A04EACD7EFB9.html",
							"GUID-4EBEC168-246F-401E-8D76-A04EACD7EFB9.html",
							"GUID-4EBEC168-246F-401E-8D76-A04EACD7EFB9.html",
							"GUID-4EBEC168-246F-401E-8D76-A04EACD7EFB9.html",
							"GUID-4EBEC168-246F-401E-8D76-A04EACD7EFB9.html",
							"GUID-4EBEC168-246F-401E-8D76-A04EACD7EFB9.html",
							"GUID-C5D32B8C-8006-47DC-82E4-380055D681F3.html",
							"GUID-C5D32B8C-8006-47DC-82E4-380055D681F3.html",
							"GUID-C5D32B8C-8006-47DC-82E4-380055D681F3.html",
							"GUID-C5D32B8C-8006-47DC-82E4-380055D681F3.html",
							"GUID-C5D32B8C-8006-47DC-82E4-380055D681F3.html",
							"GUID-C5D32B8C-8006-47DC-82E4-380055D681F3.html",
							"GUID-C5D32B8C-8006-47DC-82E4-380055D681F3.html",
							"GUID-C5D32B8C-8006-47DC-82E4-380055D681F3.html",
							"GUID-C5D32B8C-8006-47DC-82E4-380055D681F3.html",
							"GUID-4307AF8B-71ED-471F-B1D1-804772B8F545.html",
							"GUID-4307AF8B-71ED-471F-B1D1-804772B8F545.html",
							"GUID-4307AF8B-71ED-471F-B1D1-804772B8F545.html",
							"GUID-4307AF8B-71ED-471F-B1D1-804772B8F545.html",
							"GUID-4307AF8B-71ED-471F-B1D1-804772B8F545.html",
							"GUID-4307AF8B-71ED-471F-B1D1-804772B8F545.html",
							"GUID-4307AF8B-71ED-471F-B1D1-804772B8F545.html",
							"GUID-4307AF8B-71ED-471F-B1D1-804772B8F545.html",
							"GUID-4307AF8B-71ED-471F-B1D1-804772B8F545.html",
							"GUID-5B30F7C8-8E1C-47DD-834E-5DCEB9726A84.html",
							"GUID-5B30F7C8-8E1C-47DD-834E-5DCEB9726A84.html",
							"GUID-5B30F7C8-8E1C-47DD-834E-5DCEB9726A84.html",
							"GUID-5B30F7C8-8E1C-47DD-834E-5DCEB9726A84.html",
							"GUID-5B30F7C8-8E1C-47DD-834E-5DCEB9726A84.html",
							"GUID-5B30F7C8-8E1C-47DD-834E-5DCEB9726A84.html",
							"GUID-5B30F7C8-8E1C-47DD-834E-5DCEB9726A84.html",
							"GUID-5B30F7C8-8E1C-47DD-834E-5DCEB9726A84.html",
							"GUID-5B30F7C8-8E1C-47DD-834E-5DCEB9726A84.html",
							"GUID-AD2A8D50-5953-4F48-AA6E-2C472D92EEB3.html",
							"GUID-AD2A8D50-5953-4F48-AA6E-2C472D92EEB3.html",
							"GUID-AD2A8D50-5953-4F48-AA6E-2C472D92EEB3.html",
							"GUID-AD2A8D50-5953-4F48-AA6E-2C472D92EEB3.html",
							"GUID-AD2A8D50-5953-4F48-AA6E-2C472D92EEB3.html",
							"GUID-AD2A8D50-5953-4F48-AA6E-2C472D92EEB3.html",
							"GUID-AD2A8D50-5953-4F48-AA6E-2C472D92EEB3.html",
							"GUID-AD2A8D50-5953-4F48-AA6E-2C472D92EEB3.html",
							"GUID-AD2A8D50-5953-4F48-AA6E-2C472D92EEB3.html",
							"GUID-CF0C439F-1F3C-4557-A0D6-08E15536CDAD.html",
							"GUID-CF0C439F-1F3C-4557-A0D6-08E15536CDAD.html",
							"GUID-CF0C439F-1F3C-4557-A0D6-08E15536CDAD.html",
							"GUID-CF0C439F-1F3C-4557-A0D6-08E15536CDAD.html",
							"GUID-CF0C439F-1F3C-4557-A0D6-08E15536CDAD.html",
							"GUID-9728BCD2-2DB9-456F-8B5F-E88D61261ABC.html",
							"GUID-9728BCD2-2DB9-456F-8B5F-E88D61261ABC.html",
							"GUID-9728BCD2-2DB9-456F-8B5F-E88D61261ABC.html",
							"GUID-9728BCD2-2DB9-456F-8B5F-E88D61261ABC.html",
							"GUID-9728BCD2-2DB9-456F-8B5F-E88D61261ABC.html",
							"GUID-64D5F998-D72C-42CD-902F-D3FED8339A94.html",
							"GUID-3FAC72DB-7A84-4EBF-82E8-F3756D795DB1.html",
							"GUID-3FF0F5C9-1505-4639-A838-A412BD8D6E00.html",
							"GUID-342F6C48-844D-418B-BD00-E9185853672D.html",
							"GUID-6CBA8AA0-7EF7-44B1-8D12-CD6A3067E53A.html",
							"GUID-C229D91A-4D07-4CCB-9521-11B574AC2007.html",
							"GUID-C229D91A-4D07-4CCB-9521-11B574AC2007.html",
							"GUID-C229D91A-4D07-4CCB-9521-11B574AC2007.html",
							"GUID-C229D91A-4D07-4CCB-9521-11B574AC2007.html",
							"GUID-C229D91A-4D07-4CCB-9521-11B574AC2007.html",
							"GUID-C229D91A-4D07-4CCB-9521-11B574AC2007.html",
							"GUID-C229D91A-4D07-4CCB-9521-11B574AC2007.html",
							"GUID-C229D91A-4D07-4CCB-9521-11B574AC2007.html",
							"GUID-C229D91A-4D07-4CCB-9521-11B574AC2007.html",
							"GUID-366CB061-A2E0-4D4A-B02F-901280740EB5.html",
							"GUID-366CB061-A2E0-4D4A-B02F-901280740EB5.html",
							"GUID-366CB061-A2E0-4D4A-B02F-901280740EB5.html",
							"GUID-366CB061-A2E0-4D4A-B02F-901280740EB5.html",
							"GUID-366CB061-A2E0-4D4A-B02F-901280740EB5.html",
							"GUID-366CB061-A2E0-4D4A-B02F-901280740EB5.html",
							"GUID-366CB061-A2E0-4D4A-B02F-901280740EB5.html",
							"GUID-366CB061-A2E0-4D4A-B02F-901280740EB5.html",
							"GUID-366CB061-A2E0-4D4A-B02F-901280740EB5.html",
							"GUID-E9EE1AF3-0468-48C4-80E2-F56FE58D751D.html",
							"GUID-E9EE1AF3-0468-48C4-80E2-F56FE58D751D.html",
							"GUID-E9EE1AF3-0468-48C4-80E2-F56FE58D751D.html",
							"GUID-E9EE1AF3-0468-48C4-80E2-F56FE58D751D.html",
							"GUID-E9EE1AF3-0468-48C4-80E2-F56FE58D751D.html",
							"GUID-E9EE1AF3-0468-48C4-80E2-F56FE58D751D.html",
							"GUID-E9EE1AF3-0468-48C4-80E2-F56FE58D751D.html",
							"GUID-E9EE1AF3-0468-48C4-80E2-F56FE58D751D.html",
							"GUID-E9EE1AF3-0468-48C4-80E2-F56FE58D751D.html",
							"GUID-01EDD938-2B06-45D4-B301-E5A39BB8BAE7.html",
							"GUID-01EDD938-2B06-45D4-B301-E5A39BB8BAE7.html",
							"GUID-01EDD938-2B06-45D4-B301-E5A39BB8BAE7.html",
							"GUID-01EDD938-2B06-45D4-B301-E5A39BB8BAE7.html",
							"GUID-01EDD938-2B06-45D4-B301-E5A39BB8BAE7.html",
							"GUID-01EDD938-2B06-45D4-B301-E5A39BB8BAE7.html",
							"GUID-01EDD938-2B06-45D4-B301-E5A39BB8BAE7.html",
							"GUID-01EDD938-2B06-45D4-B301-E5A39BB8BAE7.html",
							"GUID-01EDD938-2B06-45D4-B301-E5A39BB8BAE7.html",
							"GUID-50DB3018-16B7-42E8-AC34-7EA47E1DBDD1.html",
							"GUID-50DB3018-16B7-42E8-AC34-7EA47E1DBDD1.html",
							"GUID-50DB3018-16B7-42E8-AC34-7EA47E1DBDD1.html",
							"GUID-50DB3018-16B7-42E8-AC34-7EA47E1DBDD1.html",
							"GUID-50DB3018-16B7-42E8-AC34-7EA47E1DBDD1.html",
							"GUID-50DB3018-16B7-42E8-AC34-7EA47E1DBDD1.html",
							"GUID-50DB3018-16B7-42E8-AC34-7EA47E1DBDD1.html",
							"GUID-50DB3018-16B7-42E8-AC34-7EA47E1DBDD1.html",
							"GUID-50DB3018-16B7-42E8-AC34-7EA47E1DBDD1.html",
							"GUID-0767C1BA-B8A2-4C3D-85C2-A43620242B0E.html",
							"GUID-0767C1BA-B8A2-4C3D-85C2-A43620242B0E.html",
							"GUID-0767C1BA-B8A2-4C3D-85C2-A43620242B0E.html",
							"GUID-0767C1BA-B8A2-4C3D-85C2-A43620242B0E.html",
							"GUID-0767C1BA-B8A2-4C3D-85C2-A43620242B0E.html",
							"GUID-0767C1BA-B8A2-4C3D-85C2-A43620242B0E.html",
							"GUID-0767C1BA-B8A2-4C3D-85C2-A43620242B0E.html",
							"GUID-0767C1BA-B8A2-4C3D-85C2-A43620242B0E.html",
							"GUID-0767C1BA-B8A2-4C3D-85C2-A43620242B0E.html",
							"GUID-78A85F1D-D719-4E26-A023-EDB229B985C1.html",
							"GUID-78A85F1D-D719-4E26-A023-EDB229B985C1.html",
							"GUID-78A85F1D-D719-4E26-A023-EDB229B985C1.html",
							"GUID-78A85F1D-D719-4E26-A023-EDB229B985C1.html",
							"GUID-78A85F1D-D719-4E26-A023-EDB229B985C1.html",
							"GUID-78A85F1D-D719-4E26-A023-EDB229B985C1.html",
							"GUID-78A85F1D-D719-4E26-A023-EDB229B985C1.html",
							"GUID-78A85F1D-D719-4E26-A023-EDB229B985C1.html",
							"GUID-78A85F1D-D719-4E26-A023-EDB229B985C1.html",
							"GUID-225EDAEC-C9BA-4CA7-8889-E9C3BC89AA6D.html",
							"GUID-225EDAEC-C9BA-4CA7-8889-E9C3BC89AA6D.html",
							"GUID-225EDAEC-C9BA-4CA7-8889-E9C3BC89AA6D.html",
							"GUID-225EDAEC-C9BA-4CA7-8889-E9C3BC89AA6D.html",
							"GUID-225EDAEC-C9BA-4CA7-8889-E9C3BC89AA6D.html",
							"GUID-225EDAEC-C9BA-4CA7-8889-E9C3BC89AA6D.html",
							"GUID-225EDAEC-C9BA-4CA7-8889-E9C3BC89AA6D.html",
							"GUID-225EDAEC-C9BA-4CA7-8889-E9C3BC89AA6D.html",
							"GUID-225EDAEC-C9BA-4CA7-8889-E9C3BC89AA6D.html",
							"GUID-42AEC39F-A1C0-453E-A45A-43725FDC6205.html",
							"GUID-42AEC39F-A1C0-453E-A45A-43725FDC6205.html",
							"GUID-42AEC39F-A1C0-453E-A45A-43725FDC6205.html",
							"GUID-42AEC39F-A1C0-453E-A45A-43725FDC6205.html",
							"GUID-42AEC39F-A1C0-453E-A45A-43725FDC6205.html",
							"GUID-42AEC39F-A1C0-453E-A45A-43725FDC6205.html",
							"GUID-42AEC39F-A1C0-453E-A45A-43725FDC6205.html",
							"GUID-42AEC39F-A1C0-453E-A45A-43725FDC6205.html",
							"GUID-42AEC39F-A1C0-453E-A45A-43725FDC6205.html",
							"GUID-2C7BBB24-1695-482B-A1AA-F29D74F7916D.html",
							"GUID-2C7BBB24-1695-482B-A1AA-F29D74F7916D.html",
							"GUID-2C7BBB24-1695-482B-A1AA-F29D74F7916D.html",
							"GUID-2C7BBB24-1695-482B-A1AA-F29D74F7916D.html",
							"GUID-2C7BBB24-1695-482B-A1AA-F29D74F7916D.html",
							"GUID-E71D9730-F3C8-4F9F-819A-B7B27C8E137C.html",
							"GUID-E71D9730-F3C8-4F9F-819A-B7B27C8E137C.html",
							"GUID-E71D9730-F3C8-4F9F-819A-B7B27C8E137C.html",
							"GUID-E71D9730-F3C8-4F9F-819A-B7B27C8E137C.html",
							"GUID-E71D9730-F3C8-4F9F-819A-B7B27C8E137C.html",
							"GUID-85503CF7-E808-426B-B680-8CC5F981CAD1.html",
							"GUID-85503CF7-E808-426B-B680-8CC5F981CAD1.html",
							"GUID-85503CF7-E808-426B-B680-8CC5F981CAD1.html",
							"GUID-85503CF7-E808-426B-B680-8CC5F981CAD1.html",
							"GUID-85503CF7-E808-426B-B680-8CC5F981CAD1.html",
							"GUID-85503CF7-E808-426B-B680-8CC5F981CAD1.html",
							"GUID-8AEFE0B0-CE35-4F99-ACF4-7C8E10D3BBB6.html",
							"GUID-7D215256-2053-48D0-AB96-FD429F5D67ED.html",
							"GUID-0EE2CCDD-3C1B-4DA6-90EB-50B9B67AC895.html",
							"GUID-959D7A17-0006-48BC-B5B5-00FB6D26B38D.html",
							"GUID-430ED88C-3DBA-4821-ABD7-E4C30EAB006C.html",
							"GUID-5A8FD263-9070-43FB-9578-AE6D97182339.html",
							"GUID-B770DB97-5472-46CE-9CEC-39A8C892C5B3.html",
							"GUID-09ED0A48-5AA8-44E4-BC15-6BCCF5C9D516.html",
							"GUID-2729150D-D502-4BC4-BB41-653718EF531C.html",
							"GUID-61E30825-2446-4436-A7F5-806E1A1CEB7B.html",
							"GUID-61E30825-2446-4436-A7F5-806E1A1CEB7B.html",
							"GUID-61E30825-2446-4436-A7F5-806E1A1CEB7B.html",
							"GUID-61E30825-2446-4436-A7F5-806E1A1CEB7B.html",
							"GUID-61E30825-2446-4436-A7F5-806E1A1CEB7B.html",
							"GUID-61E30825-2446-4436-A7F5-806E1A1CEB7B.html",
							"GUID-61E30825-2446-4436-A7F5-806E1A1CEB7B.html",
							"GUID-61E30825-2446-4436-A7F5-806E1A1CEB7B.html",
							"GUID-61E30825-2446-4436-A7F5-806E1A1CEB7B.html",
							"GUID-0EE74238-A733-42E6-A088-EFDF6DAA51BF.html",
							"GUID-0EE74238-A733-42E6-A088-EFDF6DAA51BF.html",
							"GUID-0EE74238-A733-42E6-A088-EFDF6DAA51BF.html",
							"GUID-0EE74238-A733-42E6-A088-EFDF6DAA51BF.html",
							"GUID-0EE74238-A733-42E6-A088-EFDF6DAA51BF.html",
							"GUID-0EE74238-A733-42E6-A088-EFDF6DAA51BF.html",
							"GUID-0EE74238-A733-42E6-A088-EFDF6DAA51BF.html",
							"GUID-0EE74238-A733-42E6-A088-EFDF6DAA51BF.html",
							"GUID-0EE74238-A733-42E6-A088-EFDF6DAA51BF.html",
							"GUID-60EB59D7-F592-4497-B5C0-7939FE2B4C38.html",
							"GUID-60EB59D7-F592-4497-B5C0-7939FE2B4C38.html",
							"GUID-60EB59D7-F592-4497-B5C0-7939FE2B4C38.html",
							"GUID-60EB59D7-F592-4497-B5C0-7939FE2B4C38.html",
							"GUID-60EB59D7-F592-4497-B5C0-7939FE2B4C38.html",
							"GUID-60EB59D7-F592-4497-B5C0-7939FE2B4C38.html",
							"GUID-60EB59D7-F592-4497-B5C0-7939FE2B4C38.html",
							"GUID-60EB59D7-F592-4497-B5C0-7939FE2B4C38.html",
							"GUID-60EB59D7-F592-4497-B5C0-7939FE2B4C38.html",
							"GUID-9303AF61-5D37-4A3D-9032-D9B898B2FDA7.html",
							"GUID-9303AF61-5D37-4A3D-9032-D9B898B2FDA7.html",
							"GUID-9303AF61-5D37-4A3D-9032-D9B898B2FDA7.html",
							"GUID-9303AF61-5D37-4A3D-9032-D9B898B2FDA7.html",
							"GUID-9303AF61-5D37-4A3D-9032-D9B898B2FDA7.html",
							"GUID-9303AF61-5D37-4A3D-9032-D9B898B2FDA7.html",
							"GUID-9303AF61-5D37-4A3D-9032-D9B898B2FDA7.html",
							"GUID-9303AF61-5D37-4A3D-9032-D9B898B2FDA7.html",
							"GUID-9303AF61-5D37-4A3D-9032-D9B898B2FDA7.html",
							"GUID-5C0AEA33-6394-4333-83D2-32BB5910D53C.html",
							"GUID-5C0AEA33-6394-4333-83D2-32BB5910D53C.html",
							"GUID-5C0AEA33-6394-4333-83D2-32BB5910D53C.html",
							"GUID-5C0AEA33-6394-4333-83D2-32BB5910D53C.html",
							"GUID-5C0AEA33-6394-4333-83D2-32BB5910D53C.html",
							"GUID-5C0AEA33-6394-4333-83D2-32BB5910D53C.html",
							"GUID-5C0AEA33-6394-4333-83D2-32BB5910D53C.html",
							"GUID-5C0AEA33-6394-4333-83D2-32BB5910D53C.html",
							"GUID-5C0AEA33-6394-4333-83D2-32BB5910D53C.html",
							"GUID-2048879B-0811-4B9F-9087-0A5B733969C8.html",
							"GUID-2048879B-0811-4B9F-9087-0A5B733969C8.html",
							"GUID-2048879B-0811-4B9F-9087-0A5B733969C8.html",
							"GUID-2048879B-0811-4B9F-9087-0A5B733969C8.html",
							"GUID-2048879B-0811-4B9F-9087-0A5B733969C8.html",
							"GUID-2048879B-0811-4B9F-9087-0A5B733969C8.html",
							"GUID-2048879B-0811-4B9F-9087-0A5B733969C8.html",
							"GUID-2048879B-0811-4B9F-9087-0A5B733969C8.html",
							"GUID-2048879B-0811-4B9F-9087-0A5B733969C8.html",
							"GUID-E18B22E2-C723-4978-8396-6D7B0BF705FB.html",
							"GUID-E18B22E2-C723-4978-8396-6D7B0BF705FB.html",
							"GUID-E18B22E2-C723-4978-8396-6D7B0BF705FB.html",
							"GUID-E18B22E2-C723-4978-8396-6D7B0BF705FB.html",
							"GUID-E18B22E2-C723-4978-8396-6D7B0BF705FB.html",
							"GUID-E18B22E2-C723-4978-8396-6D7B0BF705FB.html",
							"GUID-E18B22E2-C723-4978-8396-6D7B0BF705FB.html",
							"GUID-E18B22E2-C723-4978-8396-6D7B0BF705FB.html",
							"GUID-E18B22E2-C723-4978-8396-6D7B0BF705FB.html",
							"GUID-D90DF2C4-0C7E-4406-B84B-8DB9179CC0F0.html",
							"GUID-D90DF2C4-0C7E-4406-B84B-8DB9179CC0F0.html",
							"GUID-D90DF2C4-0C7E-4406-B84B-8DB9179CC0F0.html",
							"GUID-D90DF2C4-0C7E-4406-B84B-8DB9179CC0F0.html",
							"GUID-D90DF2C4-0C7E-4406-B84B-8DB9179CC0F0.html",
							"GUID-D90DF2C4-0C7E-4406-B84B-8DB9179CC0F0.html",
							"GUID-D90DF2C4-0C7E-4406-B84B-8DB9179CC0F0.html",
							"GUID-D90DF2C4-0C7E-4406-B84B-8DB9179CC0F0.html",
							"GUID-D90DF2C4-0C7E-4406-B84B-8DB9179CC0F0.html",
							"GUID-579BC909-4BCE-4587-A825-4F7B97A4C022.html",
							"GUID-579BC909-4BCE-4587-A825-4F7B97A4C022.html",
							"GUID-579BC909-4BCE-4587-A825-4F7B97A4C022.html",
							"GUID-579BC909-4BCE-4587-A825-4F7B97A4C022.html",
							"GUID-579BC909-4BCE-4587-A825-4F7B97A4C022.html",
							"GUID-579BC909-4BCE-4587-A825-4F7B97A4C022.html",
							"GUID-579BC909-4BCE-4587-A825-4F7B97A4C022.html",
							"GUID-579BC909-4BCE-4587-A825-4F7B97A4C022.html",
							"GUID-579BC909-4BCE-4587-A825-4F7B97A4C022.html",
							"GUID-1CB9B19B-380F-4016-B314-A50414DDACD2.html",
							"GUID-1CB9B19B-380F-4016-B314-A50414DDACD2.html",
							"GUID-1CB9B19B-380F-4016-B314-A50414DDACD2.html",
							"GUID-1CB9B19B-380F-4016-B314-A50414DDACD2.html",
							"GUID-1CB9B19B-380F-4016-B314-A50414DDACD2.html",
							"GUID-1CB9B19B-380F-4016-B314-A50414DDACD2.html",
							"GUID-1CB9B19B-380F-4016-B314-A50414DDACD2.html",
							"GUID-1CB9B19B-380F-4016-B314-A50414DDACD2.html",
							"GUID-1CB9B19B-380F-4016-B314-A50414DDACD2.html",
							"GUID-DCAFBDDA-42E1-48B2-B29E-AEB0A54E534A.html",
							"GUID-DCAFBDDA-42E1-48B2-B29E-AEB0A54E534A.html",
							"GUID-DCAFBDDA-42E1-48B2-B29E-AEB0A54E534A.html",
							"GUID-DCAFBDDA-42E1-48B2-B29E-AEB0A54E534A.html",
							"GUID-DCAFBDDA-42E1-48B2-B29E-AEB0A54E534A.html",
							"GUID-DCAFBDDA-42E1-48B2-B29E-AEB0A54E534A.html",
							"GUID-DCAFBDDA-42E1-48B2-B29E-AEB0A54E534A.html",
							"GUID-DCAFBDDA-42E1-48B2-B29E-AEB0A54E534A.html",
							"GUID-DCAFBDDA-42E1-48B2-B29E-AEB0A54E534A.html",
							"GUID-F1C71FFE-A026-4E58-B946-FB7DC6E407A0.html",
							"GUID-F1C71FFE-A026-4E58-B946-FB7DC6E407A0.html",
							"GUID-F1C71FFE-A026-4E58-B946-FB7DC6E407A0.html",
							"GUID-F1C71FFE-A026-4E58-B946-FB7DC6E407A0.html",
							"GUID-F1C71FFE-A026-4E58-B946-FB7DC6E407A0.html",
							"GUID-F1C71FFE-A026-4E58-B946-FB7DC6E407A0.html",
							"GUID-F1C71FFE-A026-4E58-B946-FB7DC6E407A0.html",
							"GUID-F1C71FFE-A026-4E58-B946-FB7DC6E407A0.html",
							"GUID-F1C71FFE-A026-4E58-B946-FB7DC6E407A0.html",
							"GUID-79165D33-BC36-4AA0-AF89-E59BA4F86A95.html",
							"GUID-79165D33-BC36-4AA0-AF89-E59BA4F86A95.html",
							"GUID-79165D33-BC36-4AA0-AF89-E59BA4F86A95.html",
							"GUID-79165D33-BC36-4AA0-AF89-E59BA4F86A95.html",
							"GUID-79165D33-BC36-4AA0-AF89-E59BA4F86A95.html",
							"GUID-79165D33-BC36-4AA0-AF89-E59BA4F86A95.html",
							"GUID-79165D33-BC36-4AA0-AF89-E59BA4F86A95.html",
							"GUID-79165D33-BC36-4AA0-AF89-E59BA4F86A95.html",
							"GUID-79165D33-BC36-4AA0-AF89-E59BA4F86A95.html",
							"GUID-5B486700-48D3-4B8B-AEEC-F8CE0222E988.html",
							"GUID-5B486700-48D3-4B8B-AEEC-F8CE0222E988.html",
							"GUID-5B486700-48D3-4B8B-AEEC-F8CE0222E988.html",
							"GUID-5B486700-48D3-4B8B-AEEC-F8CE0222E988.html",
							"GUID-5B486700-48D3-4B8B-AEEC-F8CE0222E988.html",
							"GUID-5B486700-48D3-4B8B-AEEC-F8CE0222E988.html",
							"GUID-5B486700-48D3-4B8B-AEEC-F8CE0222E988.html",
							"GUID-5B486700-48D3-4B8B-AEEC-F8CE0222E988.html",
							"GUID-5B486700-48D3-4B8B-AEEC-F8CE0222E988.html",
							"GUID-8ABC2A31-6978-4216-AA28-6A2D7AA6A672.html",
							"GUID-8ABC2A31-6978-4216-AA28-6A2D7AA6A672.html",
							"GUID-8ABC2A31-6978-4216-AA28-6A2D7AA6A672.html",
							"GUID-8ABC2A31-6978-4216-AA28-6A2D7AA6A672.html",
							"GUID-8ABC2A31-6978-4216-AA28-6A2D7AA6A672.html",
							"GUID-8ABC2A31-6978-4216-AA28-6A2D7AA6A672.html",
							"GUID-8ABC2A31-6978-4216-AA28-6A2D7AA6A672.html",
							"GUID-8ABC2A31-6978-4216-AA28-6A2D7AA6A672.html",
							"GUID-8ABC2A31-6978-4216-AA28-6A2D7AA6A672.html",
							"GUID-E5A3917B-236F-47F9-9F78-41BD64D2D920.html",
							"GUID-E5A3917B-236F-47F9-9F78-41BD64D2D920.html",
							"GUID-E5A3917B-236F-47F9-9F78-41BD64D2D920.html",
							"GUID-E5A3917B-236F-47F9-9F78-41BD64D2D920.html",
							"GUID-E5A3917B-236F-47F9-9F78-41BD64D2D920.html",
							"GUID-E5A3917B-236F-47F9-9F78-41BD64D2D920.html",
							"GUID-E5A3917B-236F-47F9-9F78-41BD64D2D920.html",
							"GUID-E5A3917B-236F-47F9-9F78-41BD64D2D920.html",
							"GUID-E5A3917B-236F-47F9-9F78-41BD64D2D920.html",
							"GUID-0C40AEB7-D68A-4AE4-AC5B-E5580C634399.html",
							"GUID-0C40AEB7-D68A-4AE4-AC5B-E5580C634399.html",
							"GUID-0C40AEB7-D68A-4AE4-AC5B-E5580C634399.html",
							"GUID-0C40AEB7-D68A-4AE4-AC5B-E5580C634399.html",
							"GUID-0C40AEB7-D68A-4AE4-AC5B-E5580C634399.html",
							"GUID-10D16A6B-098F-4F29-BCAA-4657A6ADB972.html",
							"GUID-10D16A6B-098F-4F29-BCAA-4657A6ADB972.html",
							"GUID-10D16A6B-098F-4F29-BCAA-4657A6ADB972.html",
							"GUID-10D16A6B-098F-4F29-BCAA-4657A6ADB972.html",
							"GUID-10D16A6B-098F-4F29-BCAA-4657A6ADB972.html",
							"GUID-0BDF001D-9151-4D5E-BC98-4DCD1B5ABD24.html",
							"GUID-0BDF001D-9151-4D5E-BC98-4DCD1B5ABD24.html",
							"GUID-0BDF001D-9151-4D5E-BC98-4DCD1B5ABD24.html",
							"GUID-0BDF001D-9151-4D5E-BC98-4DCD1B5ABD24.html",
							"GUID-0BDF001D-9151-4D5E-BC98-4DCD1B5ABD24.html",
							"GUID-4A2E496A-C280-44A4-AEA9-F4BE35F47721.html",
							"GUID-4A2E496A-C280-44A4-AEA9-F4BE35F47721.html",
							"GUID-4A2E496A-C280-44A4-AEA9-F4BE35F47721.html",
							"GUID-4A2E496A-C280-44A4-AEA9-F4BE35F47721.html",
							"GUID-4A2E496A-C280-44A4-AEA9-F4BE35F47721.html",
							"GUID-D5093933-5E4E-42E6-BB97-C88CC3D15DD6.html",
							"GUID-D5093933-5E4E-42E6-BB97-C88CC3D15DD6.html",
							"GUID-D5093933-5E4E-42E6-BB97-C88CC3D15DD6.html",
							"GUID-D5093933-5E4E-42E6-BB97-C88CC3D15DD6.html",
							"GUID-D5093933-5E4E-42E6-BB97-C88CC3D15DD6.html",
							"GUID-2FB7347D-8FBD-411F-88D8-58A813EA9498.html",
							"GUID-60D60732-08A7-4E99-97BB-FEF4A339F8F6.html",
							"GUID-AADCF888-80C7-4848-AE21-5D37C9738F12.html",
							"GUID-2AD6AC66-AB70-4E20-B1EF-00555DCC0F66.html",
							"GUID-78DA8A5A-9D66-4746-9FB9-E5625A0C5F14.html",
							"GUID-F1244C57-71EF-492B-8104-473C8CECC20F.html"];

var SearchTitles = ["MPLAB® Harmony Core Library",
"Driver Libraries",
"Common Driver Library",
"DRV_CLIENT_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"DRV_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"DRV_IO_INTENT Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_IO_ISBLOCKING Macro",
"C",
"Summary",
"Description",
"Remarks",
"DRV_IO_ISNONBLOCKING Macro",
"C",
"Summary",
"Description",
"Remarks",
"DRV_IO_ISEXCLUSIVE Macro",
"C",
"Summary",
"Description",
"Remarks",
"DRV_IO_BUFFER_TYPES Enum",
"C",
"Summary",
"Description",
"I2C Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_I2C_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_Status Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_Open Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_TransferSetup Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_ErrorGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_WriteTransferAdd Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_ForcedWriteTransferAdd Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_ReadTransferAdd Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_WriteReadTransferAdd Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_TransferEventHandlerSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_TransferStatusGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_WriteTransfer Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_ForcedWriteTransfer Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_ReadTransfer Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_WriteReadTransfer Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_TRANSFER_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"DRV_I2C_TRANSFER_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"DRV_I2C_TRANSFER_EVENT Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_I2C_TRANSFER_EVENT_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_I2C_ERROR Enum",
"C",
"Summary",
"Description",
"Remarks",
"Memory Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_MEMORY_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_Status Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_Tasks Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_Open Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_AsyncErase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_SyncErase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_AsyncEraseWrite Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_SyncEraseWrite Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_AsyncWrite Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_SyncWrite Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_AsyncRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_SyncRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_GeometryGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_TransferStatusGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_CommandStatusGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_TransferHandlerSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_IsAttached Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_IsWriteProtected Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_AddressGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MEMORY_Erase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Remarks",
"DRV_MEMORY_EraseWrite Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Remarks",
"DRV_MEMORY_Write Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Remarks",
"DRV_MEMORY_Read Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Remarks",
"DRV_MEMORY_COMMAND_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"DRV_MEMORY_COMMAND_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"DRV_MEMORY_EVENT Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_MEMORY_COMMAND_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_MEMORY_TRANSFER_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"MEMORY_DEVICE_TRANSFER_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"MEMORY_DEVICE_GEOMETRY Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_MEMORY_DEVICE_INTERFACE Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_MEMORY_INIT Struct",
"C",
"Summary",
"Description",
"Remarks",
"NAND Flash Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_NAND_FLASH_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_Open Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_Status Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_ResetFlash Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_TransferStatusGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_IdRead Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_FeatureSet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_FeatureGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_GeometryGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_ParameterPageRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_SkipBlock_BlockCheck Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_SkipBlock_BlockTag Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_SkipBlock_BlockErase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_SkipBlock_BlockRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_SkipBlock_BlockWrite Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_SkipBlock_PageRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_SkipBlock_PageWrite Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_NAND_FLASH_TRANSFER_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_NAND_FLASH_GEOMETRY Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_NAND_FLASH_DATA Struct",
"C",
"Summary",
"Description",
"Remarks",
"SDMMC Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_SDMMC_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDMMC_Status Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDMMC_Tasks Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDMMC_Open Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDMMC_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDMMC_AsyncRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDMMC_AsyncWrite Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDMMC_CommandStatus Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDMMC_GeometryGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDMMC_EventHandlerSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDMMC_IsAttached Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDMMC_IsWriteProtected Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDMMC_COMMAND_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SDMMC_COMMAND_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SDMMC_COMMAND_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SDMMC_EVENT Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SDMMC_EVENT_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SDSPI Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_SDSPI_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_Status Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_Open Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_Tasks Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_SyncRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_AsyncRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_SyncWrite Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_AsyncWrite Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_IsAttached Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_IsWriteProtected Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_GeometryGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_EventHandlerSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_CommandStatusGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_Read Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_Write Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SDSPI_COMMAND_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SDSPI_COMMAND_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SDSPI_COMMAND_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SDSPI_EVENT Enum",
"C",
"Summary",
"Description",
"Remarks",
"Remarks",
"DRV_SDSPI_EVENT_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SPI Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_SPI_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_Status Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_Open Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_TransferSetup Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_Lock Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_WriteReadTransferAdd Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_WriteTransferAdd Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_ReadTransferAdd Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_TransferEventHandlerSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_TransferStatusGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_WriteTransfer Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_ReadTransfer Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_WriteReadTransfer Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_TRANSFER_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SPI_TRANSFER_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SPI_TRANSFER_EVENT Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SPI_TRANSFER_EVENT_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SPI_CLOCK_PHASE Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SPI_CLOCK_POLARITY Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SPI_DATA_BITS Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SPI_CS_POLARITY Enum",
"C",
"Summary",
"Description",
"Remarks",
"Summary",
"Description",
"Remarks",
"USART Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_USART_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_Status Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_Open Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_ErrorGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_SerialSetup Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_BufferEventHandlerSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_WriteBufferAdd Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_ReadBufferAdd Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_BufferCompletedBytesGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_BufferStatusGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_WriteQueuePurge Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_ReadQueuePurge Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_ReadAbort Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_WriteBuffer Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_ReadBuffer Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_BUFFER_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"DRV_USART_BUFFER_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"DRV_USART_BUFFER_EVENT Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_USART_BUFFER_EVENT_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_USART_ERROR Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_USART_INIT Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_USART_SERIAL_SETUP Struct",
"C",
"Summary",
"Description",
"Remarks",
"I2C EEPROM Drivers",
"AT24 Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_AT24_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT24_Status Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT24_Open Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT24_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT24_Read Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT24_Write Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT24_PageWrite Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT24_TransferStatusGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT24_GeometryGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT24_EventHandlerSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT24_TRANSFER_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_AT24_GEOMETRY Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_AT24_EVENT_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SPI EEPROM Drivers",
"AT25 Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_AT25_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25_Status Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25_Open Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25_Read Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25_Write Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25_PageWrite Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25_TransferStatusGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25_GeometryGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25_EventHandlerSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25_TRANSFER_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_AT25_GEOMETRY Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_AT25_EVENT_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SPI Flash Drivers",
"AT25DF Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_AT25DF_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_Status Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_Open Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_Read Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_Write Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_PageWrite Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_SectorErase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_BlockErase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_ChipErase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_TransferStatusGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_GeometryGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_EventHandlerSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_AT25DF_TRANSFER_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_AT25DF_GEOMETRY Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_AT25DF_EVENT_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SQI Flash Drivers",
"MX25L Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_MX25L_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_Open Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_Status Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_ResetFlash Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_ReadJedecId Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_SectorErase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_BlockErase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_ChipErase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_Read Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_PageWrite Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_TransferStatusGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_GeometryGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_MX25L_TRANSFER_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_MX25L_GEOMETRY Struct",
"C",
"Summary",
"Description",
"Remarks",
"SST26 Driver",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"DRV_SST26_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_Open Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_Close Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_Status Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_UnlockFlash Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_ReadJedecId Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_SectorErase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_BulkErase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_ChipErase Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_Read Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_PageWrite Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_TransferStatusGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_GeometryGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_EventHandlerSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"DRV_SST26_TRANSFER_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SST26_GEOMETRY Struct",
"C",
"Summary",
"Description",
"Remarks",
"DRV_SST26_EVENT_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"System Service Libraries",
"Common System Services Library",
"SYS_MEDIA_BLOCK_COMMAND_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MEDIA_EVENT_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Remarks",
"SYS_MEDIA_BLOCK_EVENT Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MEDIA_PROPERTY Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MEDIA_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MEDIA_COMMAND_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MEDIA_GEOMETRY_TABLE_ENTRY Macros",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MEDIA_REGION_GEOMETRY Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MEDIA_GEOMETRY Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MODULE_INDEX Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MODULE_OBJ Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MODULE_OBJ_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MODULE_OBJ_STATIC Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MODULE_INIT Union",
"C",
"Summary",
"Description",
"Remarks",
"SYS_MODULE_INITIALIZE_ROUTINE Typedef",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Remarks",
"SYS_MODULE_REINITIALIZE_ROUTINE Typedef",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_MODULE_DEINITIALIZE_ROUTINE Typedef",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_MODULE_STATUS_ROUTINE Typedef",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Remarks",
"SYS_MODULE_TASKS_ROUTINE Typedef",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"Cache System Service",
"SYS_CACHE_EnableCaches Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CACHE_DisableCaches Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CACHE_EnableICache Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CACHE_DisableICache Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CACHE_InvalidateICache Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CACHE_EnableDCache Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CACHE_DisableDCache Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CACHE_InvalidateDCache Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CACHE_CleanDCache Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CACHE_CleanInvalidateDCache Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CACHE_InvalidateDCache_by_Addr Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CACHE_CleanDCache_by_Addr Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CACHE_CleanInvalidateDCache_by_Addr Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"Command Processor System Service",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"SYS_CMD_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Remarks",
"SYS_CMD_ADDGRP Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Example",
"Returns",
"Remarks",
"SYS_CMD_DELETE Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Remarks",
"SYS_CMD_READY_TO_READ Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Remarks",
"SYS_CMD_READY_TO_WRITE Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Remarks",
"SYS_CMD_Tasks Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Remarks",
"SYS_CMD_MESSAGE Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Remarks",
"SYS_CMD_PRINT Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Remarks",
"SYS_CMDIO_GET_HANDLE Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Remarks",
"SYS_CMDIO_ADD Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Remarks",
"COMMAND_HISTORY_DEPTH Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_MAX_LENGTH Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_READ_BUFFER_SIZE Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_CallbackFunction Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_MSG_FNC Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_PRINT_FNC Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_PUTC_FNC Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_DATA_RDY_FNC Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_GETC_FNC Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_READC_FNC Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_API Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_EVENT Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_CONSOLE_IO_PARAM Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_INIT Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_DEVICE_NODE Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_FNC Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CMD_DESCRIPTOR Struct",
"C",
"Summary",
"Description",
"Remarks",
"Console System Service",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"SYS_CONSOLE_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_Tasks Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_Status Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_HandleGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_DeviceGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_Read Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_Write Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_Flush Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_ReadFreeBufferCountGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_ReadCountGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_WriteFreeBufferCountGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_WriteCountGet Function",
"C",
"Summary",
"Description",
"Preconditions",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_Print Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_CONSOLE_Message Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"STDXXX_FILENO Numbers",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CONSOLE_DEFAULT_INSTANCE Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CONSOLE_MESSAGE Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CONSOLE_PRINT Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CONSOLE_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CONSOLE_DEVICE Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CONSOLE_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_CONSOLE_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"Debug System Service",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"SYS_DEBUG_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DEBUG_Status Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DEBUG_ErrorLevelSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DEBUG_ErrorLevelGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DEBUG_Redirect Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DEBUG_ConsoleInstanceGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_ERROR_LEVEL Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_DEBUG_INDEX_0 Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_DEBUG_MESSAGE Macro",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DEBUG_PRINT Macro",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DEBUG_BreakPoint Macro",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"Direct Memory Access (DMA) System Service",
"SYS_DMA_ChannelCallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DMA_ChannelTransfer Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DMA_ChannelIsBusy Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DMA_ChannelDisable Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DMA_AddressingModeSetup Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DMA_DataWidthSetup Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_DMA_CHANNEL Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_DMA_TRANSFER_EVENT Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_DMA_SOURCE_ADDRESSING_MODE Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_DMA_DESTINATION_ADDRESSING_MODE Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_DMA_WIDTH Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_DMA_CHANNEL_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Remarks",
"File System Service",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"SYS_FS_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"SYS_FS_Tasks Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_Mount Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_Unmount Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"SYS_FS_EventHandlerSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileOpen Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileClose Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileStat Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileSeek Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileTell Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileSize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileEOF Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileNameGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_Error Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileError Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileStringGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileStringPut Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileWrite Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileSync Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileTruncate Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileCharacterPut Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FilePrintf Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileTestError Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_DirOpen Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_DirClose Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_DirRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_DirRewind Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_DirSearch Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_DirectoryMake Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_DirectoryChange Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_CurrentWorkingDirectoryGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileDirectoryRemove Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileDirectoryRenameMove Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileDirectoryModeSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_FileDirectoryTimeSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_CurrentDriveGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_CurrentDriveSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_DriveLabelGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_DriveLabelSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_DriveFormat Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_DrivePartition Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_DriveSectorGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_FS_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_FILE_SYSTEM_TYPE Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_FILE_DIR_ATTR Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_FILE_SEEK_CONTROL Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_RESULT Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_FORMAT Macros",
"C",
"Summary",
"Description",
"SYS_FS_FORMAT_PARAM Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_FILE_OPEN_ATTRIBUTES Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_ERROR Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_EVENT Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_FUNCTIONS Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_REGISTRATION_TABLE Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_FSTAT Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_TIME Union",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_EVENT_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Remarks",
"SYS_FS_MEDIA_MANAGER_AddressGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"SYS_FS_MEDIA_MANAGER_CommandStatusGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"SYS_FS_MEDIA_MANAGER_Register Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Remarks",
"SYS_FS_MEDIA_MANAGER_DeRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"SYS_FS_MEDIA_MANAGER_Read Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"SYS_FS_MEDIA_MANAGER_SectorRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"SYS_FS_MEDIA_MANAGER_SectorWrite Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"SYS_FS_MEDIA_MANAGER_VolumePropertyGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"SYS_FS_MEDIA_MANAGER_MediaStatusGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"SYS_FS_MEDIA_MANAGER_EventHandlerSet Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Remarks",
"SYS_FS_MEDIA_MANAGER_RegisterTransferHandler Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"SYS_FS_MEDIA_MANAGER_GetMediaGeometry Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"SYS_FS_MEDIA_MANAGER_TransferTask Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"SYS_FS_MEDIA_MANAGER_Tasks Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_BLOCK_EVENT Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_PROPERTY Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_STATE Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_TYPE Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_COMMAND_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_REGION_GEOMETRY Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_GEOMETRY Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_MOUNT_DATA Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_VOLUME_PROPERTY Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_FUNCTIONS Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_FS_MEDIA_EVENT_HANDLER Typedef",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Remarks",
"Interrupt System Service",
"SYS_INT_Enable Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_INT_Disable Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_INT_IsEnabled Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_INT_Restore Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_INT_SourceEnable Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_INT_SourceDisable Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_INT_SourceRestore Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_INT_SourceIsEnabled Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_INT_SourceStatusGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_INT_SourceStatusSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_INT_SourceStatusClear Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"INT_SOURCE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"Ports System Service",
"SYS_PORT_PinWrite Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_PORT_PinRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_PORT_PinLatchRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_PORT_PinToggle Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_PORT_PinSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_PORT_PinClear Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_PORT_PinInputEnable Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_PORT_PinOutputEnable Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_PORT Enum",
"C",
"Summary",
"Description",
"Remarks",
"SYS_PORT_PIN Enum",
"C",
"Summary",
"Description",
"Remarks",
"Reset System Service",
"SYS_RESET_SoftwareReset Function",
"C",
"Summary",
"Description",
"PreCondition:",
"Parameters",
"Returns",
"Example",
"Remarks",
"Time System Service",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"SYS_TIME_Initialize Function",
"C",
"Summary",
"Description",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_Deinitialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_Status Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_CallbackRegisterUS Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_CallbackRegisterMS Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_DelayUS Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_DelayMS Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_DelayIsComplete Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_FrequencyGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_CounterGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_Counter64Get Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_CounterSet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_CountToUS Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_CountToMS Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_USToCount Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_MSToCount Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_TimerCreate Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_TimerReload Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_TimerDestroy Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_TimerCounterGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_TimerStart Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_TimerStop Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_TimerPeriodHasExpired Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"SYS_TIME_INIT Struct",
"C",
"Summary",
"Description",
"Remarks",
"SYS_TIME_RESULT Enum",
"C",
"Summary",
"Description",
"SYS_TIME_HANDLE Typedef",
"C",
"Summary",
"Description",
"Remarks",
"SYS_TIME_HANDLE_INVALID Macro",
"C",
"Summary",
"Description",
"Remarks",
"SYS_TIME_CALLBACK_TYPE Enum",
"C",
"Summary",
"Remarks",
"SYS_TIME_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"Software Libraries",
"Emulated EEPROM",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"EMU_EEPROM_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"EMU_EEPROM_StatusGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"EMU_EEPROM_FormatMemory Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"EMU_EEPROM_ParametersGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"EMU_EEPROM_PageBufferCommit Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"EMU_EEPROM_PageWrite Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"EMU_EEPROM_PageRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"EMU_EEPROM_BufferWrite Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"EMU_EEPROM_BufferRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"EMU_EEPROM_STATUS Enum",
"C",
"Summary",
"Description",
"Remarks",
"EMU_EEPROM_PARAMETERS Struct",
"C",
"Summary",
"Description",
"Remarks",
"I2C Bit Bang",
"How the Library Works",
"Using The Library",
"Configuring The Library",
"Library Interface",
"I2C_BB_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"I2C_BB_Read Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"I2C_BB_Write Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"I2C_BB_WriteForced Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"I2C_BB_WriteRead Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"I2C_BB_ErrorGet Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"I2C_BB_IsBusy Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"I2C_BB_TransferSetup Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"I2C_BB_CallbackRegister Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"I2CBB_ERROR Enum",
"C",
"Summary",
"Description",
"Remarks",
"I2CBB_TRANSFER_SETUP Struct",
"C",
"Summary",
"Description",
"Remarks",
"I2CBB_CALLBACK Typedef",
"C",
"Summary",
"Description",
"Example",
"Remarks",
"OSAL Library",
"How The Library Works",
"Using The Library",
"Semaphore Operations",
"Mutex Operations",
"Critical Section Operations",
"Memory Operations",
"Configuring the Library",
"Library Interface",
"OSAL_SEM_Create Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_SEM_Delete Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_SEM_Pend Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_SEM_Post Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_SEM_PostISR Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_SEM_GetCount Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_CRIT_Enter Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_CRIT_Leave Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_MUTEX_Create Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_MUTEX_Delete Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_MUTEX_Lock Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_MUTEX_Unlock Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_Malloc Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_Free Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_Initialize Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_Name Function",
"C",
"Summary",
"Description",
"Precondition",
"Parameters",
"Returns",
"Example",
"Remarks",
"OSAL_SEM_TYPE Enum",
"C",
"Summary",
"Description",
"Remarks",
"OSAL_CRIT_TYPE Enum",
"C",
"Summary",
"Description",
"Remarks",
"OSAL_RESULT Enum",
"C",
"Summary",
"Description",
"Remarks",
"OSAL_SEM_DECLARE Macro",
"C",
"Summary",
"Description",
"Remarks",
"OSAL_MUTEX_DECLARE Macro",
"C",
"Summary",
"Description",
"Remarks",
"Third party Products",
"FreeRTOS",
"Micrium OS III",
"Azure RTOS ThreadX",
"Mbed OS RTOS",
"Configuring The Harmony Core Library"];

var SearchInfo = [" MPLAB® Harmony Core Library MPLAB Harmony Core library includes help for below modules: ",
							" Driver Libraries MPLAB Harmony device drivers (usually referred to as \"drivers\") provide simple highly abstracted C-language interfaces to peripherals and other resources A driver's interface allows applications and other client modules to easily interact with the peripheral it controls using consistent usage models Harmony Driver Modes Asynchronous Mode Synchronous Mode Works in both Bare-Metal and RTOS environment Works only in RTOS Environment Provides Non-Blocking behavior Provides Blocking behavior Application thread gets blocked on a semaphore until transfer request is completed API's return with a valid handle which can be used to check whether transfer request is accepted API's return true or false to indicate whether the whole transfer is completed For Bare-Metal a dedicated task routine is either called from SYS_Tasks() or is interrupt driven to process the data from the instance queue For RTOS either a blocking dedicated thread is created for task routine or is interrupt driven to process the data from the instance queue As the Driver works in complete blocking behavior there is no task routine generated Driver Usage Models harmony_driver_usage_model Single instance single client The driver manages a single instance of the peripheral and there is a single client (application) accessing the driver instance Multiple instances single client (one client per driver instance) The driver manages multiple instances of the peripheral and there is a single client to each instance of the driver For example the SPI driver instance 0 manages SPI peripheral instance 3 and SPI driver instance 1 manages SPI peripheral instance 5 Single instance multiple clients Multiple clients to an instance of the driver For example there can be two application clients; one client interacting with SPI EEPROM and the second client interacting with SPI based temperature sensor both interfaced to the same instance of SPI peripheral Harmony Drivers provide Same API for all the instances of a peripheral This allows the application to remain the same when the peripheral instance is changed and across different platforms harmony_driver_api_table Support for multiple clients Seamlessly handle client specific differences Drivers allow multiple clients to a driver instance For example there can be multiple application clients to a SPI driver instance having multiple SPI slaves The SPI slave specific information such as clock phase clock polarity clock speed and chip select are all handled by the SPI driver based on the client that submitted the request Queue support (Asynchronous Mode) Drivers allow queuing of multiple requests Each instance of a driver has a dedicated queue The requests submitted by all the clients of the driver instance are queued in the driver instance queue Queuing allows the application to submit requests before waiting for the driver to finish the previous requests For each submitted request the application can choose to get notified or poll the status of the submitted request using the handle provided by the driver for the submitted request Cache management Drivers manage cache related operations on devices that have cache thereby simplifying application development Harmony Driver Execution Flow harmony_driver_execution_flow ",
							" Common Driver Library Common driver library provides the following data types and constants that are shared and common to all drivers Data types and constants Name Type Description DRV_CLIENT_STATUS Enum Identifies the current status/state of a client's connection to a driver DRV_HANDLE Typedef Handle to an opened device driver DRV_HANDLE_INVALID Macro Invalid device handle DRV_IO_INTENT Enum Identifies the intended usage of the device when it is opened DRV_IO_ISBLOCKING Macro Returns if the I/O intent provided is blocking DRV_IO_ISNONBLOCKING Macro Returns if the I/O intent provided is non-blocking DRV_IO_ISEXCLUSIVE Macro Returns if the I/O intent provided is non-blocking DRV_IO_BUFFER_TYPES Enum Identifies to which buffer a device operation will apply ",
							" DRV_CLIENT_STATUS Enum ",
							" C typedef  enum  {  /* Indicates that a driver-specific error has occurred */ DRV_CLIENT_STATUS_ERROR_EXTENDED =  - 10   /* An unspecified error has occurred */ DRV_CLIENT_STATUS_ERROR =  - 1   /* The driver is closed no operations for this client are ongoing and/or the given handle is invalid */ DRV_CLIENT_STATUS_CLOSED =  0   /* The driver is currently busy and cannot start additional operations */ DRV_CLIENT_STATUS_BUSY =  1   /* The module is running and ready for additional operations */ DRV_CLIENT_STATUS_READY =  2   /* Indicates that the module is in a driver-specific ready/run state */ DRV_CLIENT_STATUS_READY_EXTENDED =  10  } DRV_CLIENT_STATUS ;  ",
							" Summary Identifies the current status/state of a client's connection to a driver ",
							" Description This enumeration identifies the current status/state of a client's link to a driver ",
							" Remarks The enumeration used as the return type for the client-level status routines defined by each device driver or system module (for example DRV_USART_ClientStatus) must be based on the values in this enumeration ",
							" DRV_HANDLE Typedef ",
							" C typedef uintptr_t DRV_HANDLE ;  ",
							" Summary Handle to an opened device driver ",
							" Description This handle identifies the open instance of a device driver It must be passed to all other driver routines (except the initialization deinitialization or power routines) to identify the caller ",
							" Remarks Every application or module that wants to use a driver must first call the driver's open routine This is the only routine that is absolutely required for every driver If a driver is unable to allow an additional module to use it it must then return the special value DRV_HANDLE_INVALID Callers should check the handle returned for this value to ensure this value was not returned before attempting to call any other driver routines using the handle ",
							" DRV_HANDLE_INVALID Macro ",
							" C # define DRV_HANDLE_INVALID (((DRV_HANDLE) -1))  ",
							" Summary Invalid device handle ",
							" Description If a driver is unable to allow an additional module to use it it must then return the special value DRV_HANDLE_INVALID Callers should check the handle returned for this value to ensure this value was not returned before attempting to call any other driver routines using the handle ",
							" Remarks None ",
							" DRV_IO_INTENT Enum ",
							" C typedef  enum  {  /* Read */ DRV_IO_INTENT_READ =  1    0   /* Write */ DRV_IO_INTENT_WRITE =  1    1   /* Read and Write*/ DRV_IO_INTENT_READWRITE = DRV_IO_INTENT_READ | DRV_IO_INTENT_WRITE   /* The driver will block and will return when the operation is complete */ DRV_IO_INTENT_BLOCKING =  0    2   /* The driver will return immediately */ DRV_IO_INTENT_NONBLOCKING =  1    2   /* The driver will support only one client at a time */ DRV_IO_INTENT_EXCLUSIVE =  1    3   /* The driver will support multiple clients at a time */ DRV_IO_INTENT_SHARED =  0    3  } DRV_IO_INTENT ;  ",
							" Summary Identifies the intended usage of the device when it is opened ",
							" Description This enumeration identifies the intended usage of the device when the caller opens the device It identifies the desired behavior of the device driver for the following: Blocking or non-blocking I/O behavior (do I/O calls such as read and write block until the operation is finished or do they return immediately and require the caller to call another routine to check the status of the operation) Support reading and/or writing of data from/to the device Identify the buffering behavior (sometimes called \"double buffering\" of the driver Indicates if the driver should maintain its own read/write buffers and copy data to/from these buffers to/from the caller's buffers Identify the DMA behavior of the peripheral ",
							" Remarks The buffer allocation method is not identified by this enumeration Buffers can be allocated statically at build time dynamically at run-time or even allocated by the caller and passed to the driver for its own usage if a driver-specific routine is provided for such This choice is left to the design of the individual driver and is considered part of its interface These values can be considered \"flags\" One selection from each of the groups below can be ORed together to create the complete value passed to the driver's open routine ",
							" DRV_IO_ISBLOCKING Macro ",
							" C # define DRV_IO_ISBLOCKING(intent) (intent DRV_IO_INTENT_BLOCKING)  ",
							" Summary Returns if the I/O intent provided is blocking ",
							" Description This macro returns if the I/O intent provided is blocking ",
							" Remarks None ",
							" DRV_IO_ISNONBLOCKING Macro ",
							" C # define DRV_IO_ISNONBLOCKING(intent) (intent DRV_IO_INTENT_NONBLOCKING )  ",
							" Summary Returns if the I/O intent provided is non-blocking ",
							" Description This macro returns if the I/O intent provided is non-blocking ",
							" Remarks None ",
							" DRV_IO_ISEXCLUSIVE Macro ",
							" C # define DRV_IO_ISEXCLUSIVE(intent) (intent DRV_IO_INTENT_EXCLUSIVE)  ",
							" Summary Returns if the I/O intent provided is non-blocking ",
							" Description This macro returns if the I/O intent provided is non-blocking ",
							" Remarks None ",
							" DRV_IO_BUFFER_TYPES Enum ",
							" C typedef  enum  {  // Operation does not apply to any buffer DRV_IO_BUFFER_TYPE_NONE =  0x00   // Operation applies to read buffer DRV_IO_BUFFER_TYPE_READ =  0x01   // Operation applies to write buffer DRV_IO_BUFFER_TYPE_WRITE =  0x02   // Operation applies to both read and write buffers DRV_IO_BUFFER_TYPE_RW = DRV_IO_BUFFER_TYPE_READ | DRV_IO_BUFFER_TYPE_WRITE } DRV_IO_BUFFER_TYPES ;  ",
							" Summary Identifies to which buffer a device operation will apply ",
							" Description This enumeration identifies to which buffer (read write both or neither) a device operation will apply This is used for \"flush\" (or similar) operations ",
							" I2C Driver The I2C driver provides application ready routines to read and write data using the I2C protocol thus minimizing developer�s awareness of the working of the I2C protocol Key Features of I2C Driver: Supports I2C master functionality Provides write read and write-read transfers Support multi-client and multi-instance operation Provides data transfer events Supports Asynchronous and Synchronous modes of operation ",
							" How the Library Works The I2C driver library is a multi-client multi-instance buffer queue model based driver interface Abstraction Model The following diagram illustrates the model used by the I2C Driver Note: Queue is not present in Synchronous mode of the driver drv_i2c_abstraction_model Working Flow The I2C driver is built on top of the I2C peripheral library The I2C driver is capable of supporting multiple instances of the I2C peripheral The I2C driver supports multiple clients to a driver instance This is used when there are more than one I2C slaves on the same bus The driver changes the I2C clock speed automatically based on the I2C slave being talked to you (that is based on which client submitted the request) I2C driver is capable of working in both Asynchronous and Synchronous modes I2C driver in Asynchronous mode Asynchronous mode APIs are non-blocking in nature These APIs submit a request and return back to the application Typically if there are no on-going or pending requests in the driver's transfer queue then the transfer is started by the API and completed from the peripheral interrupt If there is an on-going transfer or one or more requests pending in the driver's transfer queue then the request is added to the queue and executed when all the pending requests are complete The size of the transfer queue is configurable using MCC based on application needs The transfer APIs provide a transfer handle back to the application If the driver was unable to accept the request then the transfer handle will be set to NULL This usually happens if the transfer queue is full or if invalid argruments are passed to the API Application must check the value of the transfer handle to ensure the request was accepted successfully Transfer handle can be used to identify/track the request Application can either register a callback to get notified when the transfer is complete or poll the status of the request by calling the DRV_I2C_TransferStatusGet() API Asynchronous mode APIs are available in both bare-metal and RTOS mode I2C driver in Synchronous mode Synchronous mode APIs are blocking in nature These APIs block until the transfer/request is complete Synchronous mode APIs are only supported in RTOS mode These APIs initate the transfer and then block on a semaphore while the transfer is in progress thereby allowing other ready tasks to run Once the transfer is complete the semaphore is given (from the peripheral interrupt's context) thereby unblocking the calling task The return value usually provides the status of the transfer Slave Address Format The slave address format used to submit the transfer request is shown below drv_i2c_slave_address_format ",
							" Using The Library The I2C driver builds on top of the I2C peripheral library (PLIB) and provides write read and write-read API's in blocking and non-blocking mode for I2C master functionality Provides Write Read and Write followed by Read API's Supports multiple slaves connected to the same I2C peripheral instance (multi-client mode) In asynchronous (non-blocking) mode application can either register a callback to get notified once the data transfer is complete or can poll the status of the data transfer using the status APIs In asynchronous mode application can queue more than one transmit/receive requests without waiting for the previous request to be completed The number of transmit/receive requests that can be queued depends on the depth of the transfer queue configured using the MHC The asynchronous mode is supported in both bare-metal and RTOS environment The synchronous (blocking) mode of the driver is supported only in an RTOS environment The synchronous mode of the driver does not support callback or queuing multiple requests This is because the implementation is blocking in nature Example application to Read and Write from I2C EEPROM in Asynchronous mode # define APP_EEPROM_MEMORY_ADDR 0x0000  /* Size of the string written to EEPROM must be less than or equal to the EEPROM page size */  # define APP_EEPROM_TEST_DATA \"I2C EEPROM Demo\"  # define APP_EEPROM_TEST_DATA_SIZE (sizeof(APP_EEPROM_TEST_DATA)-1)  # define APP_EEPROM_RX_BUFFER_SIZE APP_EEPROM_TEST_DATA_SIZE  # if APP_EEPROM_ADDR_LEN_BITS == 18 || APP_EEPROM_ADDR_LEN_BITS == 16  /* For 18 bit address A16 and A17 are part of the EEPROM slave address * The A16 and A17 bits are set to 0 in this demonstration */  # define APP_EEPROM_NUM_ADDR_BYTES 2  # elif APP_EEPROM_ADDR_LEN_BITS == 8  # define APP_EEPROM_NUM_ADDR_BYTES 1  # endif  # define APP_EEPROM_TX_BUFFER_SIZE (APP_EEPROM_TEST_DATA_SIZE + APP_EEPROM_NUM_ADDR_BYTES) APP_DATA appData ;  static uint8_t testTxData [ APP_EEPROM_TX_BUFFER_SIZE ]  =  { 0 } ;  static uint8_t testRxData [ APP_EEPROM_RX_BUFFER_SIZE ]  =  { 0 } ;  void APP_I2CEventHandler ( DRV_I2C_TRANSFER_EVENT event  DRV_I2C_TRANSFER_HANDLE transferHandle  uintptr_t context )  { APP_TRANSFER_STATUS * transferStatus =  ( APP_TRANSFER_STATUS * ) context ;  if  ( event == DRV_I2C_TRANSFER_EVENT_COMPLETE )  {  if  ( transferStatus )  {  * transferStatus = APP_TRANSFER_STATUS_SUCCESS ;  }  }  else  {  if  ( transferStatus )  {  * transferStatus = APP_TRANSFER_STATUS_ERROR ;  }  }  }  void APP_Initialize (  void  )  {  /* Initialize the appData structure */ appData  state = APP_STATE_INIT ; appData  drvI2CHandle = DRV_HANDLE_INVALID ; appData  transferHandle = DRV_I2C_TRANSFER_HANDLE_INVALID ; appData  transferStatus = APP_TRANSFER_STATUS_ERROR ;  # if APP_EEPROM_NUM_ADDR_BYTES == 2 testTxData [ 0 ]  =  ( APP_EEPROM_MEMORY_ADDR   8 ) ; testTxData [ 1 ]  = APP_EEPROM_MEMORY_ADDR ;  memcpy (  testTxData [ 2 ]   ( const  void * ) APP_EEPROM_TEST_DATA  APP_EEPROM_TEST_DATA_SIZE ) ;  # else testTxData [ 0 ]  = APP_EEPROM_MEMORY_ADDR ;  memcpy (  testTxData [ 1 ]   ( const  void * ) APP_EEPROM_TEST_DATA  APP_EEPROM_TEST_DATA_SIZE ) ;  # endif  }  void APP_Tasks (  void  )  {  /* Check the application's current state */  switch  ( appData  state )  {  /* Application's initial state */  case APP_STATE_INIT :  /* Open the I2C Driver */ appData  drvI2CHandle =  DRV_I2C_Open ( DRV_I2C_INDEX_0  DRV_IO_INTENT_READWRITE ) ;  if ( appData  drvI2CHandle == DRV_HANDLE_INVALID )  { appData  state = APP_STATE_ERROR ;  }  else  {  /* Register the I2C Driver event Handler */  DRV_I2C_TransferEventHandlerSet ( appData  drvI2CHandle  APP_I2CEventHandler   ( uintptr_t )  appData  transferStatus ) ; appData  state = APP_STATE_IS_EEPROM_READY ;  }  break ;  case APP_STATE_IS_EEPROM_READY : appData  transferStatus = APP_TRANSFER_STATUS_IN_PROGRESS ;  /* Add a dummy write transfer request to verify whether EEPROM is ready */  DRV_I2C_WriteTransferAdd ( appData  drvI2CHandle  APP_EEPROM_SLAVE_ADDR   ( void  * )  appData  dummyData   1    appData  transferHandle ) ;  if ( appData  transferHandle == DRV_I2C_TRANSFER_HANDLE_INVALID )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_DATA_WRITE ;  }  break ;  case APP_STATE_DATA_WRITE :  if  ( appData  transferStatus == APP_TRANSFER_STATUS_SUCCESS )  { appData  transferStatus = APP_TRANSFER_STATUS_IN_PROGRESS ;  /* Add a request to write the application data */  DRV_I2C_WriteTransferAdd ( appData  drvI2CHandle  APP_EEPROM_SLAVE_ADDR   ( void  * )  testTxData [ 0 ]  APP_EEPROM_TX_BUFFER_SIZE    appData  transferHandle ) ;  if ( appData  transferHandle == DRV_I2C_TRANSFER_HANDLE_INVALID )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_WAIT_WRITE_COMPLETE ;  }  }  else  if  ( appData  transferStatus == APP_TRANSFER_STATUS_ERROR )  {  //EEPROM is not ready Keep checking until it is ready to receive commands  //Some EEPROMs need stabilization time before they can start responding to commands appData  state = APP_STATE_IS_EEPROM_READY ;  }  break ;  case APP_STATE_WAIT_WRITE_COMPLETE :  if  ( appData  transferStatus == APP_TRANSFER_STATUS_SUCCESS )  { appData  transferStatus = APP_TRANSFER_STATUS_IN_PROGRESS ;  /* Add a dummy write request to check if EEPROM's internal write cycle is complete */  DRV_I2C_WriteTransferAdd ( appData  drvI2CHandle  APP_EEPROM_SLAVE_ADDR   ( void  * )  appData  dummyData   1    appData  transferHandle ) ;  if ( appData  transferHandle == DRV_I2C_TRANSFER_HANDLE_INVALID )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_EEPROM_CHECK_INTERNAL_WRITE_STATUS ;  }  }  else  if  ( appData  transferStatus == APP_TRANSFER_STATUS_ERROR )  { appData  state = APP_STATE_ERROR ;  }  break ;  case APP_STATE_EEPROM_CHECK_INTERNAL_WRITE_STATUS :  if  ( appData  transferStatus == APP_TRANSFER_STATUS_SUCCESS )  { appData  state = APP_STATE_DATA_READ ;  }  else  if  ( appData  transferStatus == APP_TRANSFER_STATUS_ERROR )  { appData  transferStatus = APP_TRANSFER_STATUS_IN_PROGRESS ;  /* Keep checking if EEPROM's internal write cycle is complete */  DRV_I2C_WriteTransferAdd ( appData  drvI2CHandle  APP_EEPROM_SLAVE_ADDR   ( void  * )  appData  dummyData   1    appData  transferHandle ) ;  if ( appData  transferHandle == DRV_I2C_TRANSFER_HANDLE_INVALID )  { appData  state = APP_STATE_ERROR ;  }  }  break ;  case APP_STATE_DATA_READ : appData  transferStatus = APP_TRANSFER_STATUS_IN_PROGRESS ;  /* Add a request to read data from EEPROM */  DRV_I2C_WriteReadTransferAdd ( appData  drvI2CHandle  APP_EEPROM_SLAVE_ADDR   ( void  * )  testTxData [ 0 ]  APP_EEPROM_NUM_ADDR_BYTES   ( void  * )  testRxData [ 0 ]  APP_EEPROM_TEST_DATA_SIZE    appData  transferHandle ) ;  if ( appData  transferHandle == DRV_I2C_TRANSFER_HANDLE_INVALID )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_WAIT_READ_COMPLETE ;  }  break ;  case APP_STATE_WAIT_READ_COMPLETE :  if  ( appData  transferStatus == APP_TRANSFER_STATUS_SUCCESS )  { appData  state = APP_STATE_DATA_VERIFY ;  }  else  if  ( appData  transferStatus == APP_TRANSFER_STATUS_ERROR )  { appData  state = APP_STATE_ERROR ;  }  break ;  case APP_STATE_DATA_VERIFY :  /* Compare data written and data read */  if  ( memcmp (  testTxData [ APP_EEPROM_NUM_ADDR_BYTES ]    testRxData [ 0 ]  APP_EEPROM_TEST_DATA_SIZE )  ==  0 )  { appData  state = APP_STATE_SUCCESS ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  case APP_STATE_SUCCESS : appData  state = APP_STATE_IDLE ;  break ;  case APP_STATE_ERROR : appData  state = APP_STATE_IDLE ;  break ;  case APP_STATE_IDLE :  default :  break ;  }  } ",
							" Configuring The Library I2C Driver Library should be configured via MHC The following figures show the MHC configuration window for I2C driver and brief description Common User Configuration for all Instances Driver Mode: Allows User to select the mode of driver(Asynchronous or Synchronous) This setting is common for all the instances Instance Specific User Configurations I2C Driver Configuration in Asynchronous Mode drv_i2c_mhc_config_async I2C Driver Configuration in Synchronous Mode drv_i2c_mhc_config_sync PLIB Used: Indicates the underlying I2C PLIB used by the driver The I2C driver only supports connecting to the I2C PLIB in master mode Number Of Clients: The total number of clients that can open the given I2C driver instance Transfer Queue Size: Indicates the size of the transfer queue for the given I2C driver instance Available only in Asynchronous mode of Operations ",
							" Library Interface I2C driver library provides the following interfaces: Functions Name Description Asynchronous Mode Synchronous Mode DRV_I2C_Initialize Initializes the I2C instance for the specified driver index Yes Yes DRV_I2C_Status Gets the current status of the I2C driver module Yes Yes DRV_I2C_Open Opens the specified I2C driver instance and returns a handle to it Yes Yes DRV_I2C_Close Closes an opened-instance of the I2C driver Yes Yes DRV_I2C_TransferSetup Sets the dynamic transfer setup of the driver Yes Yes DRV_I2C_ErrorGet Gets the I2C hardware errors associated with the the transfer request Yes Yes DRV_I2C_WriteTransferAdd Queues a write operation Yes No DRV_I2C_ForcedWriteTransferAdd Queues a write operation Yes No DRV_I2C_ReadTransferAdd Queues a read operation Yes No DRV_I2C_WriteReadTransferAdd Queues a write followed by read operation Yes No DRV_I2C_TransferEventHandlerSet Allows a client to identify a transfer event handling function for the driver to call back when queued transfers have finished Yes No DRV_I2C_TransferStatusGet Returns the status of the write/read/write-read transfer request Yes No DRV_I2C_WriteTransfer This is a blocking function that performs a I2C write operation No Yes DRV_I2C_ForcedWriteTransfer This is a blocking function that performs a I2C write operation No Yes DRV_I2C_ReadTransfer This is a blocking function that performs a I2C read operation No Yes DRV_I2C_WriteReadTransfer This is a blocking function that performs a I2C write followed by a I2C read operation No Yes Data types and constants Name Type Description DRV_I2C_TRANSFER_HANDLE Typedef Handle identifying a read write or write followed by read transfer passed to the driver DRV_I2C_TRANSFER_HANDLE_INVALID Macro Definition of an invalid transfer handle DRV_I2C_TRANSFER_EVENT Enum Identifies the possible events that can result from a buffer add request DRV_I2C_TRANSFER_EVENT_HANDLER Typedef Pointer to a I2C Driver Transfer Event handler function DRV_I2C_ERROR Enum Defines the I2C error values ",
							" DRV_I2C_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_I2C_Initialize (  const SYS_MODULE_INDEX drvIndex   const SYS_MODULE_INIT *  const init ) ",
							" Summary Initializes the I2C instance for the specified driver index ",
							" Description This routine initializes the I2C driver instance for the specified driver index making it ready for clients to open and use it The initialization data is specified by the init parameter The initialization may fail if the number of driver objects allocated are insufficient or if the specified driver instance is already initialized The driver instance index is independent of the I2C peripheral instance it is associated with For example driver instance 0 can be assigned to I2C peripheral instance 2 ",
							" Precondition None ",
							" Parameters Param Description drvIndex Identifier for the instance to be initialized init Pointer to the init data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise returns SYS_MODULE_OBJ_INVALID ",
							" Example // The following code snippet shows an example I2C driver initialization SYS_MODULE_OBJ objectHandle ; DRV_I2C_CLIENT_OBJ drvI2C0ClientObjPool [ DRV_I2C_CLIENTS_NUMBER_IDX0 ]  =  { 0 } ; DRV_I2C_TRANSFER_OBJ drvI2C0TransferObjPool [ DRV_I2C_QUEUE_SIZE_IDX0 ]  =  { 0 } ; DRV_I2C_PLIB_INTERFACE drvI2C0PLibAPI =  {   read =  ( DRV_I2C_PLIB_READ ) TWIHS0_Read    write =  ( DRV_I2C_PLIB_WRITE ) TWIHS0_Write    writeRead =  ( DRV_I2C_PLIB_WRITE_READ ) TWIHS0_WriteRead    errorGet =  ( DRV_I2C_PLIB_ERROR_GET ) TWIHS0_ErrorGet    callbackRegister =  ( DRV_I2C_PLIB_CALLBACK_REGISTER ) TWIHS0_CallbackRegister   } ; DRV_I2C_INIT drvI2C0InitData =  {   i2cPlib =   drvI2C0PLibAPI    numClients = DRV_I2C_CLIENTS_NUMBER_IDX0  clientObjPool =  ( uintptr_t )  drvI2C0ClientObjPool [ 0 ]    interruptI2C = DRV_I2C_INT_SRC_IDX0    queueSize = DRV_I2C_QUEUE_SIZE_IDX0    transferObj =  ( uintptr_t )  drvI2C0TransferObj [ 0 ]    clockSpeed = DRV_I2C_CLOCK_SPEED_IDX0   } ; objectHandle =  DRV_I2C_Initialize ( DRV_I2C_INDEX_0   ( SYS_MODULE_INIT * )  drvI2C0InitData ) ;  if  ( objectHandle == SYS_MODULE_OBJ_INVALID )  {  // Handle error  } ",
							" Remarks This routine must be called before any other I2C routine is called This routine should only be called once during system initialization ",
							" DRV_I2C_Status Function ",
							" C SYS_STATUS DRV_I2C_Status (  const SYS_MODULE_OBJ object ) ",
							" Summary Gets the current status of the I2C driver module ",
							" Description This routine provides the current status of the I2C driver module ",
							" Precondition Function DRV_I2C_Initialize should have been called before calling this function ",
							" Parameters Param Description object Driver object handle returned from the DRV_I2C_Initialize routine ",
							" Returns SYS_STATUS_READY - Initialization has succeeded and the I2C is ready for additional operations SYS_STATUS_UNINITIALIZED - Indicates that the driver is not initialized ",
							" Example SYS_MODULE_OBJ object ;  // Returned from DRV_I2C_Initialize SYS_STATUS i2cStatus ; i2cStatus =  DRV_I2C_Status ( object ) ;  if  ( i2cStatus == SYS_STATUS_READY )  {  // This means the driver can be opened using the  // DRV_I2C_Open() function  } ",
							" Remarks A driver can be opened only when its status is SYS_STATUS_READY ",
							" DRV_I2C_Open Function ",
							" C DRV_HANDLE DRV_I2C_Open (  const SYS_MODULE_INDEX drvIndex   const DRV_IO_INTENT ioIntent ) ",
							" Summary Opens the specified I2C driver instance and returns a handle to it ",
							" Description This routine opens the specified I2C driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver The ioIntent parameter defines how the client interacts with this driver instance Specifying a DRV_IO_INTENT_EXCLUSIVE will cause the driver to provide exclusive access to this client The driver cannot be opened by any other client ",
							" Precondition Function DRV_I2C_Initialize must have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the object instance to be opened ioIntent Zero or more of the values from the enumeration DRV_IO_INTENT \"ORed\" together to indicate the intended use of the driver See function description for details ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) If an error occurs the return value is DRV_HANDLE_INVALID Error can occur if the number of client objects allocated via DRV_I2C_CLIENTS_NUMBER is insufficient if the client is trying to open the driver but driver has been opened exclusively by another client if the driver instance being opened is not initialized or is invalid if the client is trying to open the driver exclusively but has already been opened in a non exclusive mode by another client if the driver is not ready to be opened typically when the initialize routine has not completed execution ",
							" Example DRV_HANDLE handle ; handle =  DRV_I2C_Open ( DRV_I2C_INDEX_0  DRV_IO_INTENT_EXCLUSIVE ) ;  if  ( handle == DRV_HANDLE_INVALID )  {  // Unable to open the driver  // May be the driver is not initialized or the initialization  // is not complete  } ",
							" Remarks The handle returned is valid until the DRV_I2C_Close routine is called ",
							" DRV_I2C_Close Function ",
							" C void  DRV_I2C_Close (  const DRV_HANDLE handle ) ",
							" Summary Closes an opened-instance of the I2C driver ",
							" Description This routine closes an opened-instance of the I2C driver invalidating the handle Any buffers in the driver queue that were submitted by this client will be removed A new handle must be obtained by calling DRV_I2C_Open before the caller may use the driver again ",
							" Precondition DRV_I2C_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns None ",
							" Example // 'handle' returned from the DRV_I2C_Open  DRV_I2C_Close ( handle ) ;  ",
							" Remarks None ",
							" DRV_I2C_TransferSetup Function ",
							" C bool DRV_I2C_TransferSetup ( DRV_HANDLE handle  DRV_I2C_TRANSFER_SETUP * setup ) ",
							" Summary Sets the dynamic transfer setup of the driver ",
							" Description This function should be used to update any of the DRV_I2C_TRANSFER_SETUP parameters for the selected client of the driver dynamically It is mainly helpful for multi client scenario where different clients need different setup like clock speed The DRV_I2C_TransferSetup function must be called before submitting any I2C driver read/write requests ",
							" Preconditions DRV_I2C_Open must have been called to obtain a valid opened device handle In case of asynchronous driver all transfer requests from the queue must have been processed ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine setup Pointer to the structure containing the new configuration settings ",
							" Returns None ",
							" Example // myI2CHandle is the handle returned by the DRV_I2C_Open function DRV_I2C_TRANSFER_SETUP setup ; setup  clockSpeed =  400000 ; DRV_I2C_TransferSetup ( myI2CHandle    setup ) ; ",
							" Remarks None ",
							" DRV_I2C_ErrorGet Function ",
							" C DRV_I2C_ERROR DRV_I2C_ErrorGet (  const DRV_I2C_TRANSFER_HANDLE transferHandle ) ",
							" Summary Gets the I2C hardware errors associated with the the transfer request ",
							" Description This function returns the errors associated with the given bufferHandle The call to this function also clears all the associated error flags ",
							" Precondition DRV_I2C_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description transferHandle A valid handle to the transfer request ",
							" Returns Errors occurred as listed by DRV_I2C_ERROR This function reports I2C errors if occurred ",
							" Example // 'bufferHandle' returned by any of the I2C transfer APIs ##Example // (Example: DRV_I2C_WriteTransferAdd / DRV_I2C_ReadTransferAdd etc )  if  ( DRV_I2C_ErrorGet ( bufferHandle )  == DRV_I2C_ERROR_NACK )  {  //Errors are cleared by the driver take respective action  //for the error case  } ",
							" Remarks The driver clears all the errors internally ",
							" DRV_I2C_WriteTransferAdd Function ",
							" C void  DRV_I2C_WriteTransferAdd (  const DRV_HANDLE handle   const uint16_t address   void  *  const buffer   const size_t size  DRV_I2C_TRANSFER_HANDLE *  const transferHandle ) ",
							" Summary Queues a write operation ",
							" Description This function schedules a non-blocking write operation The function returns with a valid transfer handle in the transferHandle argument if the write request was scheduled successfully The function adds the request to the driver instance transfer queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified On returning the transferHandle parameter may be DRV_I2C_TRANSFER_HANDLE_INVALID for the following reasons: if a transfer buffer could not be allocated to the request if the input buffer pointer is NULL if the buffer size is 0 If the requesting client registered an event callback with the driver the driver will issue a DRV_I2C_TRANSFER_EVENT_COMPLETE event if the buffer was processed successfully or a DRV_I2C_TRANSFER_EVENT_ERROR event if the buffer was not processed successfully ",
							" Precondition DRV_I2C_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine DRV_I2C_Open function address Slave address buffer Data to be written size Transfer size in bytes transferHandle Pointer to an argument that will contain the return transfer handle This will be DRV_I2C_TRANSFER_HANDLE_INVALID if the function was not successful ",
							" Returns None ",
							" Example uint8_t myBuffer [ MY_BUFFER_SIZE ] ; DRV_I2C_TRANSFER_HANDLE transferHandle ;  // myI2CHandle is the handle returned  // by the DRV_I2C_Open function  // slaveAddress is address of I2C slave device  // to which data is to be written  DRV_I2C_WriteTransferAdd ( myI2CHandle  slaveAddress  myBuffer  MY_BUFFER_SIZE    transferHandle ) ;  if ( transferHandle == DRV_I2C_TRANSFER_HANDLE_INVALID )  {  // Error handling here  }  // Event is received when the buffer is processed ",
							" Remarks This function is thread safe in a RTOS application It can be called from within the I2C Driver Transfer Event Handler that is registered by this client It should not be called in the event handler associated with another I2C driver instance It should not otherwise be called directly in an ISR This function is available only in the asynchronous mode ",
							" DRV_I2C_ForcedWriteTransferAdd Function ",
							" C void  DRV_I2C_ForcedWriteTransferAdd (  const DRV_HANDLE handle   const uint16_t address   void  *  const buffer   const size_t size  DRV_I2C_TRANSFER_HANDLE *  const transferHandle ) ",
							" Summary Queues a write operation ",
							" Description I2C Master calls this function to transmit the entire buffer to the slave even if the slave ACKs or NACKs the address or any of the data bytes This is typically used for slaves that have to initiate a reset sequence by sending a dummy I2C transaction Since the slave is still in reset any or all the bytes can be NACKed In the normal operation of the driver if the address or data byte is NACKed then the transmission is aborted and a STOP condition is asserted on the bus This function schedules a non-blocking write operation The function returns with a valid transfer handle in the transferHandle argument if the write request was scheduled successfully The function adds the request to the driver instance transfer queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified On returning the transferHandle parameter may be DRV_I2C_TRANSFER_HANDLE_INVALID for the following reasons: if a transfer buffer could not be allocated to the request if the input buffer pointer is NULL if the buffer size is 0 If the requesting client registered an event callback with the driver the driver will issue a DRV_I2C_TRANSFER_EVENT_COMPLETE event if the buffer was processed successfully or a DRV_I2C_TRANSFER_EVENT_ERROR event if the buffer was not processed successfully ",
							" Precondition DRV_I2C_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine DRV_I2C_Open function address Slave address buffer Data to be written size Transfer size in bytes transferHandle Pointer to an argument that will contain the return transfer handle This will be DRV_I2C_TRANSFER_HANDLE_INVALID if the function was not successful ",
							" Returns None ",
							" Example uint8_t myBuffer [ MY_BUFFER_SIZE ] ; DRV_I2C_TRANSFER_HANDLE transferHandle ;  // myI2CHandle is the handle returned  // by the DRV_I2C_Open function  // slaveAddress is address of I2C slave device  // to which data is to be written  DRV_I2C_ForcedWriteTransferAdd ( myI2CHandle  slaveAddress  myBuffer  MY_BUFFER_SIZE    transferHandle ) ;  if ( transferHandle == DRV_I2C_TRANSFER_HANDLE_INVALID )  {  // Error handling here  }  // Event is received when the buffer is processed ",
							" Remarks This API is generated only if the underlying peripheral and the peripheral library supports forced write feature that ignore the NACK from a slave during transfer and the forced write feature is enabled in one of the connected periphreal library This API must be used only if the underlying PLIB is enabled to generate the Forced write API If the PLIB is not enabled to generate the Forced Write API the API will return an invalid transfer handle (DRV_I2C_TRANSFER_HANDLE_INVALID) This function is thread safe in a RTOS application It can be called from within the I2C Driver Transfer Event Handler that is registered by this client It should not be called in the event handler associated with another I2C driver instance It should not otherwise be called directly in an ISR This function is available only in the asynchronous mode ",
							" DRV_I2C_ReadTransferAdd Function ",
							" C void  DRV_I2C_ReadTransferAdd (  const DRV_HANDLE handle   const uint16_t address   void  *  const buffer   const size_t size  DRV_I2C_TRANSFER_HANDLE *  const transferHandle ) ",
							" Summary Queues a read operation ",
							" Description This function schedules a non-blocking read operation The function returns with a valid transfer handle in the transferHandle argument if the read request was scheduled successfully The function adds the request to the driver instance transfer queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified The function returns DRV_I2C_TRANSFER_HANDLE_INVALID in the transferHandle argument: if a buffer could not be allocated to the request if the input buffer pointer is NULL if the buffer size is 0 if the driver handle is invalid If the requesting client registered an event callback with the driver the driver will issue a DRV_I2C_TRANSFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_I2C_TRANSFER_EVENT_ERROR event if the buffer was not processed successfully ",
							" Precondition DRV_I2C_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine DRV_I2C_Open function address Slave address buffer buffer where the read data will be stored size Transfer size in bytes transferHandle Pointer to an argument that will contain the return transfer handle This is DRV_I2C_TRANSFER_HANDLE_INVALID if the request was not successful ",
							" Returns None ",
							" Example uint8_t myBuffer [ MY_BUFFER_SIZE ] ; DRV_I2C_TRANSFER_HANDLE transferHandle ;  // myI2CHandle is the handle returned  // by the DRV_I2C_Open function  // slaveAddress is address of I2C slave device  // to which data is to be written  DRV_I2C_ReadTransferAdd ( myI2CHandle  slaveAddress  myBuffer  MY_BUFFER_SIZE    transferHandle ) ;  if ( transferHandle == DRV_I2C_TRANSFER_HANDLE_INVALID )  {  // Error handling here  }  // Event is received when the buffer is processed ",
							" Remarks This function is thread safe in a RTOS application It can be called from within the I2C Driver Transfer Event Handler that is registered by the client It should not be called in the event handler associated with another I2C driver instance It should not be called directly in an ISR This function is available only in the asynchronous mode ",
							" DRV_I2C_WriteReadTransferAdd Function ",
							" C void DRV_I2C_WriteReadTransferAdd (  const DRV_HANDLE handle   const uint16_t address   void  *  const writeBuffer   const size_t writeSize   void  *  const readBuffer   const size_t readSize  DRV_I2C_TRANSFER_HANDLE *  const transferHandle ) ",
							" Summary Queues a write followed by read operation ",
							" Description This function schedules a non-blocking write followed by read operation The function returns with a valid transfer handle in the transferHandle argument if the write request was scheduled successfully The function adds the request to the driver instance transfer queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified On returning the transferHandle parameter may be DRV_I2C_TRANSFER_HANDLE_INVALID for the following reasons: if a buffer could not be allocated to the request if the input write or read buffer pointer is NULL if the write or read buffer size is 0 If the requesting client registered an event callback with the driver the driver will issue a DRV_I2C_TRANSFER_EVENT_COMPLETE event if the buffer was processed successfully or a DRV_I2C_TRANSFER_EVENT_ERROR event if the buffer was not processed successfully ",
							" Precondition DRV_I2C_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine DRV_I2C_Open function address Slave address writeBuffer Data to be written writeSize Size of write buffer in bytes readBuffer Buffer where data to be read is stored readSize Size of the read buffer in bytes transferHandle Pointer to an argument that will contain the return transfer handle This will be DRV_I2C_TRANSFER_HANDLE_INVALID if the function was not successful ",
							" Returns None ",
							" Example uint8_t myTxBuffer [ MY_TX_BUFFER_SIZE ] ; uint8_t myRxBuffer [ MY_RX_BUFFER_SIZE ] ; DRV_I2C_TRANSFER_HANDLE transferHandle ;  // myI2CHandle is the handle returned  // by the DRV_I2C_Open function  // slaveAddress is address of I2C slave device  // to which data is to be written  DRV_I2C_WriteReadTransferAdd ( myI2CHandle  slaveAddress  myTxBuffer  MY_TX_BUFFER_SIZE  myRxBuffer  MY_RX_BUFFER_SIZE    transferHandle ) ;  if ( transferHandle == DRV_I2C_TRANSFER_HANDLE_INVALID )  {  // Error handling here  }  // Event is received when the buffer is processed ",
							" Remarks This function is thread safe in a RTOS application It can be called from within the I2C Driver Transfer Event Handler that is registered by this client It should not be called in the event handler associated with another I2C driver instance It should not otherwise be called directly in an ISR This function is available only in the asynchronous mode ",
							" DRV_I2C_TransferEventHandlerSet Function ",
							" C void DRV_I2C_TransferEventHandlerSet (  const DRV_HANDLE handle   const DRV_I2C_TRANSFER_EVENT_HANDLER eventHandler   const uintptr_t context ) ",
							" Summary Allows a client to identify a transfer event handling function for the driver to call back when queued transfers have finished ",
							" Description This function allows a client to register a transfer event handling function with the driver to call back when queued transfers have finished When a client calls either the DRV_I2C_ReadTransferAdd DRV_I2C_WriteTransferAdd or DRV_I2C_WriteReadTransferAdd function it is provided with a handle identifying the transfer that was added to the driver's transfer queue The driver will pass this handle back to the client by calling \"eventHandler\" function when the transfer has completed The event handler should be set before the client performs any \"transfer add\" operations that could generate events The event handler once set persists until the client closes the driver or sets another event handler (which could be a \"NULL\" pointer to indicate no callback) ",
							" Precondition DRV_I2C_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine DRV_I2C_Open function eventHandler Pointer to the event handler function context The value of parameter will be passed back to the client unchanged when the eventHandler function is called It can be used to identify any client specific data object that identifies the instance of the client module (for example it may be a pointer to the client module's state structure) ",
							" Returns None ",
							" Example // myAppObj is an application specific state data object MY_APP_OBJ myAppObj ; uint8_t myBuffer [ MY_BUFFER_SIZE ] ; DRV_I2C_TRANSFER_HANDLE transferHandle ;  // The registered event handler is called when the transfer is completed  void  APP_I2CTransferEventHandler ( DRV_I2C_TRANSFER_EVENT event  DRV_I2C_TRANSFER_HANDLE handle  uintptr_t context )  {  // The context handle was set to an application specific  // object It is now retrievable easily in the event handler MY_APP_OBJ * pMyAppObj =  ( MY_APP_OBJ * ) context ;  switch ( event )  {  case DRV_I2C_TRANSFER_EVENT_COMPLETE :  {  // This means the data was transferred  break ;  }  case DRV_I2C_TRANSFER_EVENT_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  }  // myI2CHandle is the handle returned  // by the DRV_I2C_Open function  // Client registers an event handler with driver This is done once  DRV_I2C_TransferEventHandlerSet ( myI2CHandle  APP_I2CTransferEventHandler   ( uintptr_t )  myAppObj ) ;  DRV_I2C_ReadTransferAdd ( myI2CHandle  slaveAddress  myBuffer  MY_BUFFER_SIZE    transferHandle ) ;  if ( transferHandle == DRV_I2C_TRANSFER_HANDLE_INVALID )  {  // Error handling here  }  ",
							" Remarks If the client does not want to be notified when the queued buffer transfer has completed it does not need to register a callback This function is thread safe when called in a RTOS application This function is available only in the asynchronous mode ",
							" DRV_I2C_TransferStatusGet Function ",
							" C DRV_I2C_TRANSFER_EVENT DRV_I2C_TransferStatusGet (  const DRV_I2C_TRANSFER_HANDLE transferHandle ) ",
							" Summary Returns the status of the write/read/write-read transfer request ",
							" Description This function can be used to poll the status of the queued transfer request if the application doesn't prefer to use the event handler (callback) function to get notified ",
							" Precondition DRV_I2C_Open must have been called to obtain a valid opened device handle Either the DRV_I2C_ReadTransferAdd DRV_I2C_WriteTransferAdd or DRV_I2C_WriteReadTransferAdd function must have been called and a valid buffer handle returned ",
							" Parameters Param Description transferHandle Handle for the buffer of which the processed number of bytes to be obtained ",
							" Returns The success or error event of the transfer ",
							" Example uint8_t myBuffer [ MY_BUFFER_SIZE ] ; DRV_I2C_TRANSFER_HANDLE transferHandle ; DRV_I2C_TRANSFER_EVENT event ;  // myI2CHandle is the handle returned  // by the DRV_I2C_Open function  DRV_I2C_ReadTransferAdd ( myI2CHandle  slaveAddress  myBuffer  MY_BUFFER_SIZE    transferHandle ) ;  if ( transferHandle == DRV_I2C_TRANSFER_HANDLE_INVALID )  {  // Error handling here  }  //Check the status of the transfer  //This call can be used to wait until the transfer is processed event =  DRV_I2C_TransferStatusGet ( transferHandle ) ; ",
							" Remarks This function is available only in the asynchronous mode ",
							" DRV_I2C_WriteTransfer Function ",
							" C bool DRV_I2C_WriteTransfer (  const DRV_HANDLE handle  uint16_t address   void *  const buffer   const size_t size ) ",
							" Summary This is a blocking function that performs a I2C write operation ",
							" Description This function does a blocking write operation The function blocks till the write is complete or error has occurred during write Function will return false to report failure The failure will occur for the following reasons: Invalid input parameters ",
							" Precondition DRV_I2C_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine DRV_I2C_Open function address Slave Address buffer Source buffer containing data to be written size Size in bytes of data to be written ",
							" Returns true - write is successful false - error has occurred ",
							" Example uint8_t myTxBuffer [ MY_TX_BUFFER_SIZE ] ;  // myI2CHandle is the handle returned  // by the DRV_I2C_Open function  // slaveAddress is address of I2C slave device  // to which data is to be written  if  ( DRV_I2C_WriteTransfer ( myI2CHandle  slaveAddress  myTxBuffer  MY_TX_BUFFER_SIZE )  == false )  {  // Error handling here  }  ",
							" Remarks This function is thread safe in a RTOS application This function should not be called from an interrupt context This function is available only in the synchronous mode ",
							" DRV_I2C_ForcedWriteTransfer Function ",
							" C bool DRV_I2C_ForcedWriteTransfer (  const DRV_HANDLE handle  uint16_t address   void *  const buffer   const size_t size ) ",
							" Summary This is a blocking function that performs a I2C write operation ",
							" Description I2C Master calls this function to transmit the entire buffer to the slave even if the slave ACKs or NACKs the address or any of the data bytes This is typically used for slaves that have to initiate a reset sequence by sending a dummy I2C transaction Since the slave is still in reset any or all the bytes can be NACKed In the normal operation of the driver if the address or data byte is NACKed then the transmission is aborted and a STOP condition is asserted on the bus This function does a blocking write operation The function blocks till the write is complete or error has occurred during write Function will return false to report failure The failure will occur for the following reasons: Invalid input parameters ",
							" Precondition DRV_I2C_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine DRV_I2C_Open function address Slave Address buffer Source buffer containing data to be written size Size in bytes of data to be written ",
							" Returns true - write is successful false - error has occurred ",
							" Example uint8_t myTxBuffer [ MY_TX_BUFFER_SIZE ] ;  // myI2CHandle is the handle returned  // by the DRV_I2C_Open function  // slaveAddress is address of I2C slave device  // to which data is to be written  if  ( DRV_I2C_ForcedWriteTransfer ( myI2CHandle  slaveAddress  myTxBuffer  MY_TX_BUFFER_SIZE )  == false )  {  // Error handling here  }  ",
							" Remarks This API must be used only if the underlying PLIB is enabled to generate the Forced write API If the PLIB is not enabled to generate the Forced Write API the API will return false This function is thread safe in a RTOS application This function should not be called from an interrupt context This function is available only in the synchronous mode ",
							" DRV_I2C_ReadTransfer Function ",
							" C bool DRV_I2C_ReadTransfer (  const DRV_HANDLE handle  uint16_t address   void *  const buffer   const size_t size ) ",
							" Summary This is a blocking function that performs a I2C read operation ",
							" Description This function does a blocking read operation The function blocks till the read is complete or error has occurred during read Function will return false to report failure The failure will occur for the following reasons: Invalid input parameters Hardware error ",
							" Precondition DRV_I2C_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine DRV_I2C_Open function address Slave Address buffer Destination buffer where read data is stored size Size in bytes of data to be read ",
							" Returns true - read is successful false - error has occurred ",
							" Example uint8_t myRxBuffer [ MY_RX_BUFFER_SIZE ] ;  // myI2CHandle is the handle returned  // by the DRV_I2C_Open function  // slaveAddress is address of I2C slave device  // to which data is to be written  if  ( DRV_I2C_ReadTransfer ( myI2CHandle  slaveAddress  myRxBuffer  MY_RX_BUFFER_SIZE )  == false )  {  // Error handling here  }  ",
							" Remarks This function is thread safe in a RTOS application This function should not be called from an interrupt context This function is available only in the synchronous mode ",
							" DRV_I2C_WriteReadTransfer Function ",
							" C bool DRV_I2C_WriteReadTransfer (  const DRV_HANDLE handle  uint16_t address   void *  const writeBuffer   const size_t writeSize   void *  const readBuffer   const size_t readSize ) ",
							" Summary This is a blocking function that performs a I2C write followed by a I2C read operation ",
							" Description This function does a blocking write and read operation The function blocks till the write and read is complete or error has occurred during data transfer Function will return false to report failure The failure will occur for the following reasons: Invalid input parameters Hardware error ",
							" Precondition DRV_I2C_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine DRV_I2C_Open function address Slave Address writeBuffer Source buffer containing data to be written writeSize Size in bytes of data to be written readBuffer Destination buffer where read data is stored readSize Size in bytes of data to be read ",
							" Returns true - transfer is successful false - error has occurred ",
							" Example uint8_t myTxBuffer [ MY_TX_BUFFER_SIZE ] ; uint8_t myRxBuffer [ MY_RX_BUFFER_SIZE ] ;  // myI2CHandle is the handle returned  // by the DRV_I2C_Open function  // slaveAddress is address of I2C slave device  // to which data is to be written  if  ( DRV_I2C_WriteReadTransfer ( myI2CHandle  slaveAddress  myTxBuffer  MY_TX_BUFFER_SIZE  myRxBuffer  MY_RX_BUFFER_SIZE )  == false )  {  // Error handling here  }  ",
							" Remarks This function is thread safe in a RTOS application This function should not be called from an interrupt context This function is available only in the synchronous mode ",
							" DRV_I2C_TRANSFER_HANDLE Typedef ",
							" C typedef uintptr_t DRV_I2C_TRANSFER_HANDLE ;  ",
							" Summary Handle identifying a read write or write followed by read transfer passed to the driver ",
							" Description A transfer handle value is returned by a call to the DRV_I2C_ReadTransferAdd/ DRV_I2C_WriteTransferAdd or DRV_I2C_WriteReadTransferAdd functions This handle is associated with the transfer passed into the function and it allows the application to track the completion of the data from (or into) that transfer The transfer handle value returned from the \"transfer add\" function is returned back to the client by the \"event handler callback\" function registered with the driver The transfer handle assigned to a client request expires when the client has been notified of the completion of the buffer transfer (after event handler function that notifies the client returns) or after the transfer has been retired by the driver if no event handler callback was set ",
							" Remarks None ",
							" DRV_I2C_TRANSFER_HANDLE_INVALID Macro ",
							" C # define DRV_I2C_TRANSFER_HANDLE_INVALID ((DRV_I2C_TRANSFER_HANDLE)(-1))  ",
							" Summary Definition of an invalid transfer handle ",
							" Description This is the definition of an invalid transfer handle An invalid transfer handle is returned by DRV_I2C_ReadTransferAdd DRV_I2C_WriteTransferAdd and DRV_I2C_WriteReadTransferAdd functions if the buffer add request was not successful ",
							" Remarks None ",
							" DRV_I2C_TRANSFER_EVENT Enum ",
							" C typedef  enum  {  /* Transfer request is pending */ DRV_I2C_TRANSFER_EVENT_PENDING =  0   /* All data from or to the buffer was transferred successfully */ DRV_I2C_TRANSFER_EVENT_COMPLETE =  1   /* Transfer Handle given is expired It means transfer is completed but with or without error is not known */ DRV_I2C_TRANSFER_EVENT_HANDLE_EXPIRED =  2   /* There was an error while processing the buffer transfer request */ DRV_I2C_TRANSFER_EVENT_ERROR =  - 1  DRV_I2C_TRANSFER_EVENT_HANDLE_INVALID =  - 2  } DRV_I2C_TRANSFER_EVENT ;  ",
							" Summary Identifies the possible events that can result from a buffer add request ",
							" Description This enumeration identifies the possible events that can result from a buffer add request caused by the client calling either the DRV_I2C_ReadTransferAdd DRV_I2C_WriteTransferAdd or DRV_I2C_WriteReadTransferAdd functions ",
							" Remarks One of these values is passed in the \"event\" parameter of the event handling callback function that the client registered with the driver by calling the DRV_I2C_TransferEventHandlerSet function when a buffer transfer request is completed ",
							" DRV_I2C_TRANSFER_EVENT_HANDLER Typedef ",
							" C typedef  void  ( * DRV_I2C_TRANSFER_EVENT_HANDLER ) ( DRV_I2C_TRANSFER_EVENT event  DRV_I2C_TRANSFER_HANDLE transferHandle  uintptr_t context ) ;  ",
							" Summary Pointer to a I2C Driver Transfer Event handler function ",
							" Description This data type defines the required function signature for the I2C driver buffer event handling callback function A client must register a pointer using the buffer event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive buffer related event calls back from the driver The parameters and return values are described here and a partial example implementation is provided ",
							" Parameters Param Description event Identifies the type of event transferHandle Handle identifying the buffer to which the vent relates context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Example void  APP_MyTransferEventHandler ( DRV_I2C_TRANSFER_EVENT event  DRV_I2C_TRANSFER_HANDLE transferHandle  uintptr_t context )  { MY_APP_DATA_STRUCT * pAppData =  ( MY_APP_DATA_STRUCT * ) context ;  switch ( event )  {  case DRV_I2C_TRANSFER_EVENT_COMPLETE :  {  // Handle the completed buffer  break ;  }  case DRV_I2C_TRANSFER_EVENT_ERROR :  default :  {  // Handle error  break ;  }  }  } ",
							" Remarks If the event is DRV_I2C_TRANSFER_EVENT_COMPLETE it means that the data was transferred successfully If the event is DRV_I2C_TRANSFER_EVENT_ERROR it means that the data was not transferred successfully The transferHandle parameter contains the transfer handle of the transfer that associated with the event And transferHandle will be valid while the transfer request is in the queue and during callback unless an error occurred After callback returns the driver will retire the transfer handle The context parameter contains the a handle to the client context provided at the time the event handling function was registered using the DRV_I2C_TransferEventHandlerSet function This context handle value is passed back to the client as the \"context\" parameter It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request The event handler function executes in the peripheral's interrupt context It is recommended of the application to not perform process intensive or blocking operations with in this function The DRV_I2C_ReadTransferAdd DRV_I2C_WriteTransferAdd and DRV_I2C_WriteReadTransferAdd functions can be called in the event handler to add a buffer to the driver queue These functions can only be called to add buffers to the driver whose event handler is running For example I2C2 driver buffers cannot be added in I2C1 driver event handler ",
							" DRV_I2C_ERROR Enum ",
							" C typedef  enum  {  /* Busy*/ DRV_I2C_ERROR_NONE   /* Transfer Successful */ DRV_I2C_ERROR_NACK   } DRV_I2C_ERROR ;  ",
							" Summary Defines the I2C error values ",
							" Description This data type defines the error values for the errors occured during transfer ",
							" Remarks None ",
							" Memory Driver The Memory driver is a multi-client multi-instance buffer model based block driver interface which can be used to communicate with various media devices Key Features of Memory Driver: It works in both Asynchronous and Synchronous modes of operation It works in both Bare Metal and RTOS environment It can be used to communicate with Different Media's via common Media Interface Media which can be accessed directly by Peripheral Libraries (NVM RAM) Media which can be accessed by protocol drivers which in-turn connect to respective peripheral Libraries Example: SST26 Driver -- QSPI peripheral library ",
							" How the Library Works The memory driver library is a multi-client multi-instance buffer queue model based block driver interface Abstraction Model The Memory driver provides abstraction to communicate with different media devices via a common Media Interface (DRV_MEMORY_DEVICE_INTERFACE)  Note: Queue is not present in Synchronous mode of the driver drv_memory_abstraction_model Memory Driver Common Features: Each instance of the driver has its own buffer queue which allows the capability to not block other media operations Each instance of the driver can either have File-system as client or an application as client Every transfer request expects data in blocks Block details (Size and number of blocks) can be retrieved by DRV_MEMORY_GeometryGet() Driver provides feature to register call back for transfer complete event which can used by clients to get notified When the Memory driver is connected to the File System the buffer queue is disabled as it is a blocking interface Overview on behavior of memory driver in below two modes: Asynchronous Mode Synchronous Mode Works in both Bare-Metal and RTOS environment Works only in RTOS Environment Provides Non-Blocking behavior Provides Blocking behavior Application thread gets blocked on a semaphore until transfer request is completed API's to be used DRV_MEMORY_AsyncXxx() API's to be used DRV_MEMORY_SyncXxx() API's return with a valid handle which can be used to check whether transfer request is accepted API's return true or false to indicate whether the whole transfer is completed For Bare-Metal a dedicated task routine DRV_MEMORY_Tasks() is called from SYS_Tasks() to process the data from the instance queue For RTOS a blocking dedicated thread is created for task routine DRV_MEMORY_Tasks() to process the data from the instance queue As the Driver works in complete blocking behavior there is no task routine generated A Client specific handler will be called to indicate the status of transfer A Client specific handler will be called to indicate the status of transfer before returning from API Although the return type of API also can be used to identify the status of transfer How to plugin Media's to Memory Driver The DRV_MEMORY_INIT data structure allows a Media driver Or Media peripheral library to be plugged into the Memory block driver Any media that needs to be plugged into the Memory block driver needs to implement the interface (function pointer signatures) specified by the DRV_MEMORY_DEVICE_INTERFACE type // This code snippet shows an example of initializing the Memory Driver  // with SST26 serial flash device attached and File system Enabled SYS_MODULE_OBJ objectHandle ;  static uint8_t gDrvMemory0EraseBuffer [ DRV_SST26_ERASE_BUFFER_SIZE ] CACHE_ALIGN ;  static DRV_MEMORY_CLIENT_OBJECT gDrvMemory0ClientObject [ DRV_MEMORY_CLIENTS_NUMBER_IDX0 ]  =  {  0  } ;  static DRV_MEMORY_BUFFER_OBJECT gDrvMemory0BufferObject [ DRV_MEMORY_BUFFER_QUEUE_SIZE_IDX0 ]  =  {  0  } ;  const DRV_MEMORY_DEVICE_INTERFACE drvMemory0DeviceAPI =  {   Open = DRV_SST26_Open    Close = DRV_SST26_Close    Status = DRV_SST26_Status    SectorErase = DRV_SST26_SectorErase    Read = DRV_SST26_Read    PageWrite = DRV_SST26_PageWrite    EventHandlerSet =  NULL    GeometryGet =  ( DRV_MEMORY_DEVICE_GEOMETRY_GET ) DRV_SST26_GeometryGet    TransferStatusGet =  ( DRV_MEMORY_DEVICE_TRANSFER_STATUS_GET ) DRV_SST26_TransferStatusGet } ;  const DRV_MEMORY_INIT drvMemory0InitData =  {   memDevIndex = DRV_SST26_INDEX    memoryDevice =   drvMemory0DeviceAPI    isFsEnabled = true    deviceMediaType =  ( uint8_t ) SYS_FS_MEDIA_TYPE_SPIFLASH    ewBuffer =   gDrvMemory0EraseBuffer [ 0 ]    clientObjPool =  ( uintptr_t )  gDrvMemory0ClientObject [ 0 ]    bufferObj =  ( uintptr_t )  gDrvMemory0BufferObject [ 0 ]    queueSize = DRV_MEMORY_BUFFER_QUEUE_SIZE_IDX0    nClientsMax = DRV_MEMORY_CLIENTS_NUMBER_IDX0 } ;  //usage of DRV_MEMORY_INDEX_0 indicates usage of Flash-related APIs objectHandle =  DRV_MEMORY_Initialize ( ( SYS_MODULE_INDEX ) DRV_MEMORY_INDEX_0   ( SYS_MODULE_INIT * )  drvMemory0InitData ) ;  if  ( SYS_MODULE_OBJ_INVALID == objectHandle )  {  // Handle error  } ",
							" Using The Library The Memory driver can be used to communicate with various media devices using common interface functions The library interface functions can be used in two different modes Modes supported: Asynchronous mode : Supported in both Bare-metal and RTOS environment Synchronous mode : Supported in only RTOS environment Usage Methods Application can directly use the Memory driver API's to perform Media operations Application can use File System service layer which in-turn uses Memory driver to perform file operations on the media It can be interfaced with Middleware's like USB Example application to Erase Write and Read SST26 Flash Memory in Asynchronous mode /* Will Erase Write and Read into 4 Sectors of 4KB each*/  # define SST26_BUFFER_SIZE (16384U)  # define GEOMETRY_TABLE_READ_ENTRY (0)  # define GEOMETRY_TABLE_WRITE_ENTRY (1)  # define GEOMETRY_TABLE_ERASE_ENTRY (2)  # define BLOCK_START 0x0 SYS_MEDIA_GEOMETRY * geometry =  NULL ; APP_SST26_DATA CACHE_ALIGN appSST26Data ;  void appTransferHandler ( DRV_MEMORY_EVENT event  DRV_MEMORY_COMMAND_HANDLE commandHandle  uintptr_t context )  { APP_SST26_DATA * app_data =  ( APP_SST26_DATA * ) context ;  switch ( event )  {  case DRV_MEMORY_EVENT_COMMAND_COMPLETE :  {  /* Wait until the last request that is Read request is done */  if  ( commandHandle == app_data - readHandle )  { appSST26Data  xfer_done = true ;  }  break ;  }  case DRV_MEMORY_EVENT_COMMAND_ERROR :  { appSST26Data  state = APP_SST26_STATE_ERROR ;  break ;  }  default :  {  break ;  }  }  }  void APP_SST26_Initialize (  void  )  { uint32_t i =  0 ;  /* Place the App state machine in its initial state */ appSST26Data  state = APP_SST26_STATE_OPEN_DRIVER ;  for  ( i =  0 ; i  SST26_BUFFER_SIZE ; i ++ )  { appSST26Data  writeBuffer [ i ]  = i ;  }  }  void APP_SST26_Tasks (  void  )  {  /* Check the application's current state */  switch  ( appSST26Data  state )  {  case APP_SST26_STATE_OPEN_DRIVER :  { appSST26Data  memoryHandle =  DRV_MEMORY_Open ( DRV_MEMORY_INDEX_0  DRV_IO_INTENT_READWRITE ) ;  if  ( DRV_HANDLE_INVALID = appSST26Data  memoryHandle )  {  DRV_MEMORY_TransferHandlerSet ( appSST26Data  memoryHandle  appTransferHandler   ( uintptr_t )  appSST26Data ) ; appSST26Data  state = APP_SST26_STATE_GEOMETRY_GET ;  }  break ;  }  case APP_SST26_STATE_GEOMETRY_GET :  { geometry =  DRV_MEMORY_GeometryGet ( appSST26Data  memoryHandle ) ;  if  ( geometry ==  NULL )  { appSST26Data  state = APP_SST26_STATE_ERROR ;  break ;  } appSST26Data  numReadBlocks =  ( SST26_BUFFER_SIZE / geometry - geometryTable [ GEOMETRY_TABLE_READ_ENTRY ]  blockSize ) ; appSST26Data  numWriteBlocks =  ( SST26_BUFFER_SIZE / geometry - geometryTable [ GEOMETRY_TABLE_WRITE_ENTRY ]  blockSize ) ; appSST26Data  numEraseBlocks =  ( SST26_BUFFER_SIZE / geometry - geometryTable [ GEOMETRY_TABLE_ERASE_ENTRY ]  blockSize ) ; appSST26Data  state = APP_SST26_STATE_ERASE_FLASH ;  break ;  }  case APP_SST26_STATE_ERASE_FLASH :  {  DRV_MEMORY_AsyncErase ( appSST26Data  memoryHandle    appSST26Data  eraseHandle  BLOCK_START  appSST26Data  numEraseBlocks ) ;  if  ( DRV_MEMORY_COMMAND_HANDLE_INVALID == appSST26Data  eraseHandle )  { appSST26Data  state = APP_SST26_STATE_ERROR ;  break ;  }  else  { appSST26Data  state = APP_SST26_STATE_WRITE_MEMORY ;  }  // Fall Through to submit Write request in the Memory Driver Queue  }  case APP_SST26_STATE_WRITE_MEMORY :  {  DRV_MEMORY_AsyncWrite ( appSST26Data  memoryHandle    appSST26Data  writeHandle   ( void  * )  appSST26Data  writeBuffer  BLOCK_START  appSST26Data  numWriteBlocks ) ;  if  ( DRV_MEMORY_COMMAND_HANDLE_INVALID == appSST26Data  writeHandle )  { appSST26Data  state = APP_SST26_STATE_ERROR ;  break ;  }  else  { appSST26Data  state = APP_SST26_STATE_READ_MEMORY ;  }  // Fall Through to submit Read request in the Memory Driver Queue  }  case APP_SST26_STATE_READ_MEMORY :  {  DRV_MEMORY_AsyncRead ( appSST26Data  memoryHandle    appSST26Data  readHandle   ( void  * ) appSST26Data  readBuffer  BLOCK_START  appSST26Data  numReadBlocks ) ;  if  ( DRV_MEMORY_COMMAND_HANDLE_INVALID == appSST26Data  readHandle )  { appSST26Data  state = APP_SST26_STATE_ERROR ;  break ;  }  else  { appSST26Data  state = APP_SST26_STATE_XFER_WAIT ;  }  // Fall Through to Wait for all above requests to be completed  }  case APP_SST26_STATE_XFER_WAIT :  {  /* Wait until all the above queued transfer requests are done */  if ( appSST26Data  xfer_done )  { appSST26Data  xfer_done = false ; appSST26Data  state = APP_SST26_STATE_VERIFY_DATA ;  }  break ;  }  case APP_SST26_STATE_VERIFY_DATA :  {  if  (  memcmp ( appSST26Data  writeBuffer  appSST26Data  readBuffer  SST26_BUFFER_SIZE ) )  { appSST26Data  state = APP_SST26_STATE_SUCCESS ;  }  else  { appSST26Data  state = APP_SST26_STATE_ERROR ;  }  DRV_MEMORY_Close ( appSST26Data  memoryHandle ) ;  break ;  }  case APP_SST26_STATE_SUCCESS :  case APP_SST26_STATE_ERROR :  default :  {  break ;  }  }  }  ",
							" Configuring The Library Memory Driver Library should be configured via MHC The following figures show the MHC configuration window for Memory Driver and brief description Common User Configuration for all Instances drv_memory_mhc_config_async_common Driver Mode: Allows User to select the mode of driver(Asynchronous or Synchronous) This setting is common for all the instances Instance Specific User Configurations Asynchronous Mode with RTOS and File System drv_memory_mhc_config_async_rtos_fs Synchronous Mode with RTOS and Without File System drv_memory_mhc_config_sync_rtos Number Of Clients: Specifies number of clients to access the specific instance of the driver File System Enabled For Memory Driver: Specifies if File system service is connected to the instance of Memory Driver Buffer Queue Size: Specifies maximum number of requests to be buffered in queue This Configuration is displayed only in Asynchronous mode Memory Device Type: Specifies the type of the memory device to be used when the File system is connected to this instance Memory Device Used: Specifies the Media device connected Memory Device Status Polling Rate Microseconds: Specifies the interval to poll for the transfer status Option is displayed only in Synchronous mode and when Memory device used does not support interrupt mode RTOS Settings: This configuration is displayed only in asynchronous mode Stack Size (in bytes): Specifies the number of bytes to be allocated on the stack for the Memory driver task of the instance Task Priority: Specifies priority for the Memory driver task thread The value can vary based on RTOS used Use Task Delay When enabled the Memory driver task will be scheduled out voluntarily after every run based on the delay configured Task Delay: Specifies the duration the task has to go to sleep after every run Should be configured carefully based on the application need and number of task running along in the system RTOS Settings For MicriumOS-III RTOS Below additional options are visible in drivers instance RTOS settings when the MicriumOS-III is added into project graph rtos_settings_micrium_os_iii Maximum Message Queue Size: This argument specifies the maximum number of messages that the task can receive through internal message queue A MicriumOS-III task contains an optional internal message queue (if OS_CFG_TASK_Q_EN is set to DEF_ENABLED in os_cfg h) The user may specify that the task is unable to receive messages by setting this argument to 0 Task Time Quanta: The amount of time (in clock ticks) for the time quanta when Round Robin is enabled If you specify 0 then the default time quanta will be used which is the tick rate divided by 10 Task Specific Options: Contains task-specific options Each option consists of one bit The option is selected when the bit is set The current version of MicriumOS-III supports the following options: Stack checking is allowed for the task: Specifies whether stack checking is allowed for the task Stack needs to be cleared: Specifies whether the stack needs to be cleared Floating-point registers needs to be saved: Specifies whether floating-point registers are saved This option is only valid if the processor has floating-point hardware and the processor-specific code saves the floating-point registers TLS (Thread Local Storage) support needed for the task: If the caller doesn�t want or need TLS (Thread Local Storage) support for the task being created If you do not include this option TLS will be supported by default TLS support was added in V3 03 00 ",
							" Library Interface Memory driver library provides the following interfaces: Functions Name Description DRV_MEMORY_Initialize Initializes the Memory instance for the specified driver index DRV_MEMORY_Status Gets the current status of the Memory driver module DRV_MEMORY_Tasks Maintains the Memory driver's internal state machine DRV_MEMORY_Open Opens the specified Memory driver instance and returns a handle to it DRV_MEMORY_Close Closes an opened-instance of the Memory driver DRV_MEMORY_AsyncErase Erase the specified number of memory blocks in Asynchronous mode DRV_MEMORY_SyncErase Erase the specified number of memory blocks in Synchronous mode DRV_MEMORY_AsyncEraseWrite Erase and Write data for the specified number of memory blocks in Asynchronous mode DRV_MEMORY_SyncEraseWrite Erase and Write data for the specified number of memory blocks in Synchronous mode DRV_MEMORY_AsyncWrite Writes data for the specified number of memory blocks in Asynchronous mode DRV_MEMORY_SyncWrite Writes data for the specified number of memory blocks in Synchronous mode DRV_MEMORY_AsyncRead Reads data for the specified number of memory blocks in Asynchronous mode DRV_MEMORY_SyncRead Reads data for the specified number of memory blocks in Synchronous mode DRV_MEMORY_GeometryGet Returns the geometry of the memory device DRV_MEMORY_TransferStatusGet Gets the current status of the transfer request on attached device DRV_MEMORY_CommandStatusGet Gets the current status of the command DRV_MEMORY_TransferHandlerSet Sets the pointer to the function (and it's context) to be called when queued operation has completed DRV_MEMORY_IsAttached Returns the physical attach status of the Media DRV_MEMORY_IsWriteProtected Returns the write protect status of the Memory DRV_MEMORY_AddressGet Returns the Memory media start address DRV_MEMORY_Erase Interface to the file system to perform a erase operation in Synchronous mode DRV_MEMORY_EraseWrite Interface to the file system to perform a erase-write operation in Synchronous mode DRV_MEMORY_Write Interface to the file system to perform a write operation in Synchronous mode DRV_MEMORY_Read Interface to the file system to perform a read operation in Synchronous mode Data types and constants Name Type Description DRV_MEMORY_COMMAND_HANDLE Typedef Handle to identify commands queued in the driver DRV_MEMORY_COMMAND_HANDLE_INVALID Macro This value defines the Memory Driver's Invalid Command Handle DRV_MEMORY_EVENT Enum Identifies the possible events that can result from a request DRV_MEMORY_COMMAND_STATUS Enum Memory Driver command Status DRV_MEMORY_TRANSFER_HANDLER Typedef Pointer to a Memory Driver Event handler function MEMORY_DEVICE_TRANSFER_STATUS Enum Memory Device Transfer Status MEMORY_DEVICE_GEOMETRY Struct Memory Device Geometry Table DRV_MEMORY_DEVICE_INTERFACE Struct Memory Device API Interface DRV_MEMORY_INIT Struct Memory Driver Initialization Data ",
							" DRV_MEMORY_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_MEMORY_Initialize (  const SYS_MODULE_INDEX drvIndex   const SYS_MODULE_INIT *  const init ) ; ",
							" Summary Initializes the Memory instance for the specified driver index ",
							" Description This routine initializes the Memory driver instance for the specified driver index making it ready for clients to open and use it ",
							" Precondition None ",
							" Parameters Param Description drvIndex Identifier for the instance to be initialized init Pointer to a data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example // This code snippet shows an example of initializing the Memory Driver  // with SST26 serial flash device attached and File system Enabled SYS_MODULE_OBJ objectHandle ;  static uint8_t gDrvMemory0EraseBuffer [ DRV_SST26_ERASE_BUFFER_SIZE ] CACHE_ALIGN ;  static DRV_MEMORY_CLIENT_OBJECT gDrvMemory0ClientObject [ DRV_MEMORY_CLIENTS_NUMBER_IDX0 ]  =  {  0  } ;  static DRV_MEMORY_BUFFER_OBJECT gDrvMemory0BufferObject [ DRV_MEMORY_BUFFER_QUEUE_SIZE_IDX0 ]  =  {  0  } ;  const DRV_MEMORY_DEVICE_INTERFACE drvMemory0DeviceAPI =  {   Open = DRV_SST26_Open    Close = DRV_SST26_Close    Status = DRV_SST26_Status    SectorErase = DRV_SST26_SectorErase    Read = DRV_SST26_Read    PageWrite = DRV_SST26_PageWrite    EventHandlerSet =  NULL    GeometryGet =  ( DRV_MEMORY_DEVICE_GEOMETRY_GET ) DRV_SST26_GeometryGet    TransferStatusGet =  ( DRV_MEMORY_DEVICE_TRANSFER_STATUS_GET ) DRV_SST26_TransferStatusGet } ;  const DRV_MEMORY_INIT drvMemory0InitData =  {   memDevIndex = DRV_SST26_INDEX    memoryDevice =   drvMemory0DeviceAPI    isFsEnabled = true    deviceMediaType =  ( uint8_t ) SYS_FS_MEDIA_TYPE_SPIFLASH    ewBuffer =   gDrvMemory0EraseBuffer [ 0 ]    clientObjPool =  ( uintptr_t )  gDrvMemory0ClientObject [ 0 ]    bufferObj =  ( uintptr_t )  gDrvMemory0BufferObject [ 0 ]    queueSize = DRV_MEMORY_BUFFER_QUEUE_SIZE_IDX0    nClientsMax = DRV_MEMORY_CLIENTS_NUMBER_IDX0 } ;  //usage of DRV_MEMORY_INDEX_0 indicates usage of Flash-related APIs objectHandle =  DRV_MEMORY_Initialize ( ( SYS_MODULE_INDEX ) DRV_MEMORY_INDEX_0   ( SYS_MODULE_INIT * )  drvMemory0InitData ) ;  if  ( SYS_MODULE_OBJ_INVALID == objectHandle )  {  // Handle error  } ",
							" Remarks This routine must be called before any other Memory routine is called This routine should only be called once during system initialization This routine will NEVER block for hardware access If the operation requires time to allow the hardware to initialize it will be reported by the DRV_MEMORY_Status operation The system must use DRV_MEMORY_Status to find out when the driver is in the ready state ",
							" DRV_MEMORY_Status Function ",
							" C SYS_STATUS DRV_MEMORY_Status ( SYS_MODULE_OBJ object ) ; ",
							" Summary Gets the current status of the Memory driver module ",
							" Description This routine provides the current status of the Memory driver module ",
							" Preconditions Function DRV_MEMORY_Initialize should have been called before calling this function ",
							" Parameters Param Description object Driver object handle returned from the DRV_MEMORY_Initialize routine ",
							" Returns SYS_STATUS_READY - Indicates that the driver is ready and accept requests for new operations SYS_STATUS_UNINITIALIZED - Indicates the driver is not initialized SYS_STATUS_BUSY - Indicates the driver is in busy state ",
							" Example SYS_MODULE_OBJ object ;  // Returned from DRV_MEMORY_Initialize SYS_STATUS MEMORYStatus ; MEMORYStatus =  DRV_MEMORY_Status ( object ) ;  ",
							" Remarks This routine will NEVER block waiting for hardware ",
							" DRV_MEMORY_Tasks Function ",
							" C void  DRV_MEMORY_Tasks ( SYS_MODULE_OBJ object ) ; ",
							" Summary Maintains the Memory driver's internal state machine ",
							" Description This routine maintains the driver's internal state machine Initial state is put to process Queue so that driver can accept transfer requests(open erase read write etc) from client This routine is also responsible for checking the status of Erase Write and read transfer requests and notify the client through transferHandler registered if any The state of driver will be busy until transfer is completed Once transfer is done the state goes back to Process sate until new requests is received ",
							" Preconditions The DRV_MEMORY_Initialize routine must have been called for the specified Memory driver instance ",
							" Parameters Param Description object Driver object handle returned from the DRV_MEMORY_Initialize routine ",
							" Returns None ",
							" Example SYS_MODULE_OBJ object ;  // Returned from DRV_MEMORY_Initialize  void SYS_Tasks (  void  )  { DRV_Memory_Tasks ( object ) ;  // Do other tasks  } ",
							" Remarks This routine is generated only in Asynchronous mode This routine should not be called directly by application For Bare Metal it will be called by the system Task routine (SYS_Tasks) For RTOS a separate Thread will be created for this task and will be called in the thread context ",
							" DRV_MEMORY_Open Function ",
							" C DRV_HANDLE DRV_MEMORY_Open (  const SYS_MODULE_INDEX drvIndex   const DRV_IO_INTENT ioIntent ) ; ",
							" Summary Opens the specified Memory driver instance and returns a handle to it ",
							" Description This routine opens the specified Memory driver instance and provides a handle When Open is called for the first time for specified Memory driver instance it opens the attached media device and reads the geomerty details This handle returned must be provided to all other client-level operations to identify the caller and the instance of the driver ",
							" Preconditions Function DRV_MEMORY_Initialize must have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the instance to be opened ioIntent Zero or more of the values from the enumeration DRV_IO_INTENT \"ORed\" together to indicate the intended use of the driver ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) If an error occurs DRV_HANDLE_INVALID is returned Errors can occur under the following circumstances: if the attached media device is not ready or the geometry get fails if the number of client objects allocated via DRV_MEMORY_CLIENTS_NUMBER is insufficient if the client is trying to open the driver but driver has been opened exclusively by another client if the client is trying to open the driver exclusively but has already been opened in a non exclusive mode by another client if the driver hardware instance being opened is not initialized or is invalid - if the attached memory device open or geometry read fails for first time ",
							" Example DRV_HANDLE handle ; handle =  DRV_MEMORY_Open ( DRV_MEMORY_INDEX_0 ) ;  if  ( DRV_HANDLE_INVALID == handle )  {  // Unable to open the driver  } ",
							" Remarks The handle returned is valid until the DRV_MEMORY_Close routine is called If the driver innstance has already been opened it cannot be opened again ",
							" DRV_MEMORY_Close Function ",
							" C void  DRV_MEMORY_Close (  const DRV_HANDLE handle ) ; ",
							" Summary Closes an opened-instance of the Memory driver ",
							" Description This routine closes an opened-instance of the Memory driver invalidating the handle After calling this routine the handle passed in \"handle\" must not be used with any of the remaining driver routines A new handle must be obtained by calling DRV_MEMORY_Open before the caller may use the driver again Usually there is no need for the driver client to verify that the Close operation has completed ",
							" Precondition DRV_MEMORY_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns None ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_MEMORY_Open  DRV_MEMORY_Close ( handle ) ; ",
							" Remarks None ",
							" DRV_MEMORY_AsyncErase Function ",
							" C void DRV_MEMORY_AsyncErase (  const DRV_HANDLE handle  DRV_MEMORY_COMMAND_HANDLE * commandHandle  uint32_t blockStart  uint32_t nBlock ) ; ",
							" Summary Erase the specified number of memory blocks in Asynchronous mode ",
							" Description This function schedules a non-blocking sector erase operation for the specified number of memory blocks from the specified block start start address on attached memory device Each block is equal to sector size of the memory device attached The function returns with a valid erase handle in the commandHandle argument if the erase request was scheduled successfully The function adds the request to the hardware instance queue and returns immediately The function returns DRV_MEMORY_COMMAND_HANDLE_INVALID in the commandHandle argument under the following circumstances: if a buffer object could not be allocated to the request if the client opened the driver for read only if the number of blocks to be erased is either zero or more than the number of blocks actually available if the erase queue size is full or queue depth is insufficient if the driver handle is invalid If the requesting client registered a transfer handler callback with the driver It will issue a DRV_MEMORY_EVENT_COMMAND_COMPLETE event if the erase operation was successful or DRV_MEMORY_EVENT_COMMAND_ERROR event if the erase operation was not successful If the requesting client has not registered any transfer handler callback with the driver It can call DRV_MEMORY_CommandStatusGet() API to know the current status of the request ",
							" Preconditions The DRV_MEMORY_Open() must have been called with DRV_IO_INTENT_WRITE or DRV_IO_INTENT_READWRITE as a parameter to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return buffer handle blockStart Block start from where the blocks should be erased nBlock Total number of blocks to be erased ",
							" Returns The command handle is returned in the commandHandle argument It Will be DRV_MEMORY_COMMAND_HANDLE_INVALID if the request was not queued ",
							" Example // Use DRV_MEMORY_GeometryGet () to find the write region geometry uint32_t blockStart =  0 ; uint32_t nBlocks =  10 ; bool xfer_done = false ;  // memoryHandle is the handle returned by the DRV_MEMORY_Open function  // Event is received when the erase request is completed  void appTransferHandler ( DRV_MEMORY_EVENT event  DRV_MEMORY_COMMAND_HANDLE commandHandle  uintptr_t context )  {  switch ( event )  {  case DRV_MEMORY_EVENT_COMMAND_COMPLETE :  { xfer_done = true ;  break ;  }  case DRV_MEMORY_EVENT_COMMAND_ERROR :  {  // Handle Error  break ;  }  default :  {  break ;  }  }  }  DRV_MEMORY_TransferHandlerSet ( memoryHandle  appTransferHandler   ( uintptr_t ) NULL ) ;  DRV_MEMORY_AsyncErase ( memoryHandle    commandHandle  blockStart  nBlocks ) ;  if ( DRV_MEMORY_COMMAND_HANDLE_INVALID == commandHandle )  {  // Error handling here  }  // Wait for erase to be completed  while (  xfer_done ) ;  ",
							" Remarks This API is supported in Both Bare-Metal and RTOS environment ",
							" DRV_MEMORY_SyncErase Function ",
							" C bool DRV_MEMORY_SyncErase (  const DRV_HANDLE handle  uint32_t blockStart  uint32_t nBlock ) ; ",
							" Summary Erase the specified number of memory blocks in Synchronous mode ",
							" Description This function schedules a blocking sector erase operation for the specified number of memory blocks from the specified block start start address on attached memory device ",
							" Preconditions The DRV_MEMORY_Open() must have been called with DRV_IO_INTENT_WRITE or DRV_IO_INTENT_READWRITE as a parameter to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function blockStart block start from where the blocks should be erased nBlock Total number of blocks to be erased ",
							" Returns true If the transfer request is successfully completed false If the client opened the driver for read only If the number of blocks to be erased is either zero or more than the number of blocks actually available If the driver handle is invalid ",
							" Example // Use DRV_MEMORY_GeometryGet () to find the erase region geometry uint32_t blockStart =  0 ; uint32_t nBlocks =  10 ;  // memoryHandle is the handle returned by the DRV_MEMORY_Open function  if ( DRV_MEMORY_SyncErase ( memoryHandle  blockStart  nBlock )  == false )  {  // Error handling here  }  ",
							" Remarks This API is supported only in RTOS environment ",
							" DRV_MEMORY_AsyncEraseWrite Function ",
							" C void DRV_MEMORY_AsyncEraseWrite (  const DRV_HANDLE handle  DRV_MEMORY_COMMAND_HANDLE * commandHandle   void  * sourceBuffer  uint32_t blockStart  uint32_t nBlock ) ; ",
							" Summary Erase and Write data for the specified number of memory blocks in Asynchronous mode ",
							" Description This function combines the step of erasing a sector and then writing the page The application can use this function if it wants to avoid having to explicitly delete a sector in order to update the pages contained in the sector This function schedules a non-blocking operation to erase and write blocks of data into attached device memory The function returns with a valid command handle in the commandHandle argument if the write request was scheduled successfully The function adds the request to the hardware instance queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified The function returns DRV_MEMORY_COMMAND_HANDLE_INVALID in the commandHandle argument under the following circumstances: if a buffer could not be allocated to the request if the sourceBuffer pointer is NULL if the client opened the driver for read only if the number of blocks to be written is either zero or more than the number of blocks actually available if the driver handle is invalid If the requesting client registered an event callback with the driver the driver will issue a DRV_MEMORY_EVENT_COMMAND_COMPLETE event if the buffer was processed successfully or DRV_MEMORY_EVENT_COMMAND_ERROR event if the buffer was not processed successfully If the requesting client has not registered any transfer handler callback with the driver he can call DRV_MEMORY_CommandStatusGet() API to know the current status of the request ",
							" Precondition The DRV_MEMORY_Open() must have been called with DRV_IO_INTENT_WRITE or DRV_IO_INTENT_READWRITE as a parameter to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return command handle If NULL then command handle is not returned sourceBuffer The source buffer containing data to be programmed into media device memory blockStart Write block start where the write should begin nBlock Total number of blocks to be written ",
							" Returns The command handle is returned in the commandHandle argument It Will be DRV_MEMORY_COMMAND_HANDLE_INVALID if the request was not queued ",
							" Example # define BUFFER_SIZE 4096 uint8_t buffer [ BUFFER_SIZE ] ;  // Use DRV_MEMORY_GeometryGet () to find the write region geometry uint32_t blockStart =  0x0 ; uint32_t nBlock = BUFFER_SIZE / block_size ;  // block_size for write geometry DRV_MEMORY_COMMAND_HANDLE commandHandle ;  // memoryHandle is the handle returned by the DRV_MEMORY_Open function  // Client registers an event handler with driver  // Event is received when the erase-write request is completed  void appTransferHandler ( DRV_MEMORY_EVENT event  DRV_MEMORY_COMMAND_HANDLE commandHandle  uintptr_t context )  {  switch ( event )  {  case DRV_MEMORY_EVENT_COMMAND_COMPLETE :  { xfer_done = true ;  break ;  }  case DRV_MEMORY_EVENT_COMMAND_ERROR :  {  // Handle Error  break ;  }  default :  {  break ;  }  }  }  DRV_MEMORY_TransferHandlerSet ( memoryHandle  appTransferHandler   ( uintptr_t ) NULL ) ;  DRV_MEMORY_AsyncEraseWrite ( memoryHandle    commandHandle    myBuffer  blockStart  nBlock ) ;  if ( DRV_MEMORY_COMMAND_HANDLE_INVALID == commandHandle )  {  // Error handling here  }  // Wait for erase to be completed  while (  xfer_done ) ;  ",
							" Remarks This API is supported in Both Bare-Metal and RTOS environment ",
							" DRV_MEMORY_SyncEraseWrite Function ",
							" C bool DRV_MEMORY_SyncEraseWrite (  const DRV_HANDLE handle   void  * sourceBuffer  uint32_t blockStart  uint32_t nBlock ) ; ",
							" Summary Erase and Write data for the specified number of memory blocks in Synchronous mode ",
							" Description This function combines the step of erasing a sector and then writing the page The application can use this function if it wants to avoid having to explicitly delete a sector in order to update the pages contained in the sector This function schedules a blocking operation to erase and write blocks of data into attached device memory ",
							" Precondition The DRV_MEMORY_Open() must have been called with DRV_IO_INTENT_WRITE or DRV_IO_INTENT_READWRITE as a parameter to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function sourceBuffer The source buffer containing data to be programmed into media device memory blockStart block start where the write should begin nBlock Total number of blocks to be written ",
							" Returns true If the transfer request is successfully completed false If the sourceBuffer pointer is NULL If the client opened the driver for read only If the number of blocks to be written is either zero or more than the number of blocks actually available If the driver handle is invalid ",
							" Example # define BUFFER_SIZE 4096 uint8_t buffer [ BUFFER_SIZE ] ;  // Use DRV_MEMORY_GeometryGet () to find the write region geometry uint32_t blockStart =  0x0 ; uint32_t nBlock = BUFFER_SIZE / block_size ;  // block_size for write geometry  // memoryHandle is the handle returned by the DRV_MEMORY_Open function  if ( DRV_MEMORY_SyncEraseWrite ( memoryHandle    myBuffer  blockStart  nBlock )  == false )  {  // Error handling here  }  ",
							" Remarks This API is supported only in RTOS environment ",
							" DRV_MEMORY_AsyncWrite Function ",
							" C void DRV_MEMORY_AsyncWrite (  const DRV_HANDLE handle  DRV_MEMORY_COMMAND_HANDLE * commandHandle   void  * sourceBuffer  uint32_t blockStart  uint32_t nBlock ) ; ",
							" Summary Writes data for the specified number of memory blocks in Asynchronous mode ",
							" Description This function schedules a non-blocking write operation for writing blocks of data into attached devices memory The function returns with a valid command handle in the commandHandle argument if the write request was scheduled successfully The function adds the request to the hardware instance queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified The function returns DRV_MEMORY_COMMAND_HANDLE_INVALID in the commandHandle argument under the following circumstances: if a buffer object could not be allocated to the request if the source buffer pointer is NULL if the client opened the driver for read only if the number of blocks to be written is either zero or more than the number of blocks actually available if the driver handle is invalid If the requesting client registered an event callback with the driver the driver will issue a DRV_MEMORY_EVENT_COMMAND_COMPLETE event if the buffer was processed successfully or DRV_MEMORY_EVENT_COMMAND_ERROR event if the buffer was not processed successfully If the requesting client has not registered any transfer handler callback with the driver he can call DRV_MEMORY_CommandStatusGetGet() API to know the current status of the request ",
							" Preconditions DRV_MEMORY_Open() routine must have been called to obtain a valid opened device handle The memory address location which has to be written must have been erased before using the DRV_MEMORY_xxxErase() routine ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return buffer handle sourceBuffer The source buffer containing data to be programmed into media device memory blockStart Block start from where the data should be written to nBlock Total number of blocks to be written ",
							" Returns The command handle is returned in the commandHandle argument It will be DRV_MEMORY_COMMAND_HANDLE_INVALID if the request was not successful ",
							" Example # define BUFFER_SIZE 4096 uint8_t writeBuffer [ BUFFER_SIZE ] ;  // Use DRV_MEMORY_GeometryGet () to find the write region geometry uint32_t blockStart =  0x0 ; uint32_t nBlock = BUFFER_SIZE / block_size ;  // block_size for write geometry bool xfer_done = false ; DRV_MEMORY_COMMAND_HANDLE commandHandle ;  // memoryHandle is the handle returned by the DRV_MEMORY_Open function  // Event is received when the write request is completed  void appTransferHandler ( DRV_MEMORY_EVENT event  DRV_MEMORY_COMMAND_HANDLE commandHandle  uintptr_t context )  {  switch ( event )  {  case DRV_MEMORY_EVENT_COMMAND_COMPLETE :  { xfer_done = true ;  break ;  }  case DRV_MEMORY_EVENT_COMMAND_ERROR :  {  // Handle Error  break ;  }  default :  {  break ;  }  }  }  DRV_MEMORY_TransferHandlerSet ( memoryHandle  appTransferHandler   ( uintptr_t ) NULL ) ;  DRV_MEMORY_AsyncErase ( memoryHandle    commandHandle  blockStart  nBlock ) ;  if ( DRV_MEMORY_COMMAND_HANDLE_INVALID == commandHandle )  {  // Error handling here  }  // Wait for erase to be completed  while (  xfer_done ) ;  DRV_MEMORY_AsyncWrite ( memoryHandle    commandHandle    writeBuffer  blockStart  nBlock ) ;  if ( DRV_MEMORY_COMMAND_HANDLE_INVALID == commandHandle )  {  // Error handling here  }  // Wait for write to be completed  while (  xfer_done ) ;  ",
							" Remarks This API is supported in Both Bare-Metal and RTOS environment ",
							" DRV_MEMORY_SyncWrite Function ",
							" C bool DRV_MEMORY_SyncWrite (  const DRV_HANDLE handle   void  * sourceBuffer  uint32_t blockStart  uint32_t nBlock ) ; ",
							" Summary Writes data for the specified number of memory blocks in Synchronous mode ",
							" Description This function schedules a blocking write operation for writing blocks of data into attached devices memory ",
							" Preconditions DRV_MEMORY_Open() routine must have been called to obtain a valid opened device handle The memory block which has to be written must have been erased before using the DRV_MEMORY_xxxErase() routine ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function sourceBuffer The source buffer containing data to be programmed into media device memory blockStart Block start from where the data should be written to nBlock Total number of blocks to be written ",
							" Returns true If the transfer request is successfully completed false If the source buffer pointer is NULL If the client opened the driver for read only If the number of blocks to be written is either zero or more than the number of blocks actually available If the driver handle is invalid ",
							" Example # define BUFFER_SIZE 4096 uint8_t writeBuffer [ BUFFER_SIZE ] ;  // Use DRV_MEMORY_GeometryGet () to find the write region geometry uint32_t blockStart =  0x0 ; uint32_t nBlock = BUFFER_SIZE / block_size ;  // block_size for write geometry  // memoryHandle is the handle returned by the DRV_MEMORY_Open function  if ( DRV_MEMORY_SyncErase ( memoryHandle  blockStart  nBlock )  == false )  {  // Error handling here  }  if ( DRV_MEMORY_SyncWrite ( memoryHandle    writeBuffer  blockStart  nBlock )  == false )  {  // Error handling here  }  ",
							" Remarks This API is supported only in RTOS environment ",
							" DRV_MEMORY_AsyncRead Function ",
							" C void DRV_MEMORY_AsyncRead (  const DRV_HANDLE handle  DRV_MEMORY_COMMAND_HANDLE * commandHandle   void  * targetBuffer  uint32_t blockStart  uint32_t nBlock ) ; ",
							" Summary Reads data for the specified number of memory blocks in Asynchronous mode ",
							" Description This function schedules a non-blocking read operation for reading blocks of data from the memory device attached The function returns with a valid command handle in the commandHandle argument if the request was scheduled successfully The function adds the request to the hardware instance queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified The function returns DRV_MEMORY_COMMAND_HANDLE_INVALID in the commandHandle argument under the following circumstances: if a buffer object could not be allocated to the request if the target buffer pointer is NULL if the client opened the driver for write only if the number of blocks to be read is either zero or more than the number of blocks actually available if the driver handle is invalid ",
							" Precondition DRV_MEMORY_Open() must have been called with DRV_IO_INTENT_READ or DRV_IO_INTENT_READWRITE as the ioIntent to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the command handle targetBuffer Buffer into which the data read from the media device memory will be placed blockStart Block start from where the data should be read nBlock Total number of blocks to be read ",
							" Returns The command handle is returned in the commandHandle argument It will be DRV_MEMORY_COMMAND_HANDLE_INVALID if the request was not successful ",
							" Example uint8_t readBuffer [ BUFFER_SIZE ] ;  // Use DRV_MEMORY_GeometryGet () to find the read region geometry  // Find the block address from which to read data uint32_t blockStart =  0x0 ; uint32_t nBlock = BUFFER_SIZE ; DRV_MEMORY_COMMAND_HANDLE commandHandle ; bool xfer_done = false ;  // memoryHandle is the handle returned by the DRV_MEMORY_Open function  // Event is received when the read request is completed  void appTransferHandler ( DRV_MEMORY_EVENT event  DRV_MEMORY_COMMAND_HANDLE commandHandle  uintptr_t context )  {  switch ( event )  {  case DRV_MEMORY_EVENT_COMMAND_COMPLETE :  { xfer_done = true ;  break ;  }  case DRV_MEMORY_EVENT_COMMAND_ERROR :  {  // Handle Error  break ;  }  default :  {  break ;  }  }  }  DRV_MEMORY_TransferHandlerSet ( memoryHandle  appTransferHandler   ( uintptr_t ) NULL ) ;  DRV_MEMORY_AsyncRead ( memoryHandle    commandHandle    readBuffer  blockStart  nBlock ) ;  if ( DRV_MEMORY_COMMAND_HANDLE_INVALID == commandHandle )  {  // Error handling here  }  while (  xfer_done ) ;  ",
							" Remarks This API is supported in Both Bare-Metal and RTOS environment ",
							" DRV_MEMORY_SyncRead Function ",
							" C bool DRV_MEMORY_SyncRead (  const DRV_HANDLE handle   void  * targetBuffer  uint32_t blockStart  uint32_t nBlock ) ; ",
							" Summary Reads data for the specified number of memory blocks in Synchronous mode ",
							" Description This function schedules a blocking read operation for reading blocks of data from the memory device attached ",
							" Precondition DRV_MEMORY_Open() must have been called with DRV_IO_INTENT_READ or DRV_IO_INTENT_READWRITE as the ioIntent to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function targetBuffer Buffer into which the data read from the media device memory will be placed blockStart Block start from where the data should be read nBlock Total number of blocks to be read ",
							" Returns true If the transfer request is successfully completed false If the source buffer pointer is NULL If the client opened the driver for write only If the number of blocks to be read is either zero or more than the number of blocks actually available If the driver handle is invalid ",
							" Example # define BUFFER_SIZE 4096 uint8_t readBuffer [ BUFFER_SIZE ] ;  // Use DRV_MEMORY_GeometryGet () to find the read region geometry uint32_t blockStart =  0x0 ; uint32_t nBlock = BUFFER_SIZE / block_size ;  // block_size for read geometry  // memoryHandle is the handle returned by the DRV_MEMORY_Open function  if ( DRV_MEMORY_SyncRead ( memoryHandle    readBuffer  blockStart  nBlock )  == false )  {  // Error handling here  }  ",
							" Remarks This API is supported only in RTOS environment ",
							" DRV_MEMORY_GeometryGet Function ",
							" C SYS_MEDIA_GEOMETRY * DRV_MEMORY_GeometryGet (  const DRV_HANDLE handle ) ; ",
							" Summary Returns the geometry of the memory device ",
							" Description This API gives the following geometrical details of the attached memory device: Media Property Number of Read/Write/Erase regions in the memory device Number of Blocks and their size in each region of the device ",
							" Precondition The DRV_MEMORY_Open() routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function ",
							" Returns SYS_MEDIA_GEOMETRY - Pointer to structure which holds the media geometry information ",
							" Example SYS_MEDIA_GEOMETRY geometry ; uint32_t readBlockSize  writeBlockSize  eraseBlockSize ; uint32_t nReadBlocks  nReadRegions  totalFlashSize ;  if  ( true =  DRV_MEMORY_GeometryGet (  geometry ) )  {  // Handle Error  } readBlockSize = geometry  geometryTable [ SYS_MEDIA_GEOMETRY_TABLE_READ_ENTRY ]  blockSize ; nReadBlocks = geometry  geometryTable [ SYS_MEDIA_GEOMETRY_TABLE_READ_ENTRY ]  numBlocks ; nReadRegions = geometry  numReadRegions ; writeBlockSize = geometry  geometryTable [ SYS_MEDIA_GEOMETRY_TABLE_WRITE_ENTRY ]  blockSize ; eraseBlockSize = geometry  geometryTable [ SYS_MEDIA_GEOMETRY_TABLE_ERASE_ENTRY ]  blockSize ; totalFlashSize = readBlockSize * nReadBlocks * nReadRegions ;  ",
							" Remarks Refer sys_media h for definition of SYS_MEDIA_GEOMETRY ",
							" DRV_MEMORY_TransferStatusGet Function ",
							" C MEMORY_DEVICE_TRANSFER_STATUS DRV_MEMORY_TransferStatusGet (  const DRV_HANDLE handle ) ; ",
							" Summary Gets the current status of the transfer request on attached device ",
							" Description This routine gets the current status of the transfer request The application must use this routine where the status of a scheduled request needs to be polled on The application can alternatively register a transfer handler to receive the transfer completion events ",
							" Preconditions DRV_MEMORY_Open() must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function ",
							" Returns MEMORY_DEVICE_TRANSFER_ERROR_UNKNOWN If the handle is invalid If the status read request fails MEMORY_DEVICE_TRANSFER_BUSY If the current transfer request is still being processed MEMORY_DEVICE_TRANSFER_COMPLETED If the transfer request is completed ",
							" Example // memoryHandle is the handle returned by the DRV_MEMORY_Open function  if  ( MEMORY_DEVICE_TRANSFER_COMPLETED ==  DRV_MEMORY_TransferStatusGet ( memoryHandle ) )  {  // Operation Done  } ",
							" Remarks This routine will block for hardware access Used in Async mode of operation ",
							" DRV_MEMORY_CommandStatusGet Function ",
							" C DRV_MEMORY_COMMAND_STATUS DRV_MEMORY_CommandStatusGet (  const DRV_HANDLE handle   const DRV_MEMORY_COMMAND_HANDLE commandHandle ) ; ",
							" Summary Gets the current status of the command ",
							" Description This routine gets the current status of the buffer The application must use this routine where the status of a scheduled buffer needs to polled on The function may return DRV_MEMORY_COMMAND_HANDLE_INVALID in a case where the buffer handle has expired A buffer handle expires when the internal buffer object is re-assigned to another erase or write request It is recommended that this function be called regularly in order to track the buffer status correctly The application can alternatively register an event handler to receive write or erase operation completion events ",
							" Preconditions DRV_MEMORY_Open() must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the command handle ",
							" Returns DRV_MEMORY_COMMAND_COMPLETED If the transfer request is completed DRV_MEMORY_COMMAND_QUEUED If the command is Queued and waiting to be processed DRV_MEMORY_COMMAND_IN_PROGRESS If the current transfer request is still being processed DRV_MEMORY_COMMAND_ERROR_UNKNOWN If the handle is invalid If the status read request fails ",
							" Example // memoryHandle is the handle returned by the DRV_MEMORY_Open function  // commandHandle is the handle returned by any read/write/erase block operation  if  ( DRV_MEMORY_COMMAND_COMPLETED ==  DRV_MEMORY_CommandStatusGet ( memoryHandle  commandHandle ) )  {  // Operation Done  }  ",
							" Remarks Used in Async mode of operation ",
							" DRV_MEMORY_TransferHandlerSet Function ",
							" C void DRV_MEMORY_TransferHandlerSet (  const DRV_HANDLE handle   const  void  * transferHandler   const uintptr_t context ) ; ",
							" Summary Sets the pointer to the function (and it's context) to be called when queued operation has completed ",
							" Description This function allows a client to set an event handling function for the driver to call back when queued operation has completed When a client calls a read write erase or a erasewrite function it is provided with a handle identifying the command that was added to the driver's buffer queue The driver will pass this handle back to the client by calling \"transferHandler\" function when the queued operation has completed The event handler should be set before the client performs any operations that could generate events The event handler once set persists until the client closes the driver or sets another event handler (which could be a \"NULL\" pointer to indicate no callback) ",
							" Precondition The DRV_MEMORY_Open() routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function transferHandler Pointer to the event handler function implemented by the user context The value of parameter will be passed back to the client unchanged when the transferHandler function is called It can be used to identify any client specific data object that identifies the instance of the client module (for example it may be a pointer to the client module's state structure) ",
							" Returns None ",
							" Example DRV_MEMORY_COMMAND_HANDLE commandHandle ;  // memoryHandle is the handle returned by the DRV_MEMORY_Open function  // Client registers an event handler with driver  void appTransferHandler ( DRV_MEMORY_EVENT event  DRV_MEMORY_COMMAND_HANDLE commandHandle  uintptr_t context )  {  switch ( event )  {  case DRV_MEMORY_EVENT_COMMAND_COMPLETE :  { xfer_done = true ;  break ;  }  case DRV_MEMORY_EVENT_COMMAND_ERROR :  {  // Handle Error  break ;  }  default :  {  break ;  }  }  }  DRV_MEMORY_TransferHandlerSet ( memoryHandle  appTransferHandler   ( uintptr_t ) NULL ) ;  ",
							" Remarks If the client does not want to be notified when the queued operation has completed it does not need to register a callback Used in Asynchronous Mode of operation ",
							" DRV_MEMORY_IsAttached Function ",
							" C bool DRV_MEMORY_IsAttached (  const DRV_HANDLE handle ) ; ",
							" Summary Returns the physical attach status of the Media ",
							" Description This function returns the physical attach status of the Media device ",
							" Precondition The DRV_MEMORY_Open() routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function ",
							" Returns Returns false if the handle is invalid otherwise returns true ",
							" Example bool isMEMORYAttached ; isMEMORYAttached =  DRV_MEMORY_isAttached ( drvMEMORYHandle ) ;  ",
							" Remarks None ",
							" DRV_MEMORY_IsWriteProtected Function ",
							" C bool DRV_MEMORY_IsWriteProtected (  const DRV_HANDLE handle ) ; ",
							" Summary Returns the write protect status of the Memory ",
							" Description This function returns the write protect status of the Memory ",
							" Precondition The DRV_MEMORY_Open() routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function ",
							" Returns True - If the memory is write protected False - If the memory is not write protected ",
							" Example bool isWriteProtected ; isWriteProtected =  DRV_MEMORY_IsWriteProtected ( drvMEMORYHandle ) ;  ",
							" Remarks None ",
							" DRV_MEMORY_AddressGet Function ",
							" C uintptr_t DRV_MEMORY_AddressGet (  const DRV_HANDLE handle ) ; ",
							" Summary Returns the Memory media start address ",
							" Description This function returns the Memory Media start address ",
							" Precondition The DRV_MEMORY_Open() routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function ",
							" Returns Start address of the Memory Media if the handle is valid otherwise NULL ",
							" Example uintptr_t startAddress ; startAddress =  DRV_MEMORY_AddressGet ( drvMEMORYHandle ) ;  ",
							" Remarks None ",
							" DRV_MEMORY_Erase Function ",
							" C void DRV_MEMORY_Erase (  const DRV_HANDLE handle  SYS_MEDIA_BLOCK_COMMAND_HANDLE * commandHandle   void * sourceBuffer  uint32_t blockStart  uint32_t nBlock ) ",
							" Summary Interface to the file system to perform a erase operation in Synchronous mode ",
							" Description This routine provides interface to the file system to perform a media erase operation in synchronous mode of the Memory driver ",
							" Preconditions The DRV_MEMORY_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return buffer handle blockStart Start block address of SD Card where the writes should begin nBlock Total number of blocks to be written ",
							" Returns The buffer handle is returned in the commandHandle argument It will be DRV_MEMORY_COMMAND_HANDLE_INVALID if the request was not successful ",
							" Remarks This function is internally used by the file system and should not be used by application ",
							" DRV_MEMORY_EraseWrite Function ",
							" C void DRV_MEMORY_EraseWrite (  const DRV_HANDLE handle  SYS_MEDIA_BLOCK_COMMAND_HANDLE * commandHandle   void * sourceBuffer  uint32_t blockStart  uint32_t nBlock ) ",
							" Summary Interface to the file system to perform a erase-write operation in Synchronous mode ",
							" Description This routine provides interface to the file system to perform a media erase-write operation in synchronous mode of the Memory driver ",
							" Preconditions The DRV_MEMORY_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return buffer handle sourceBuffer The source buffer containing data to be programmed to the SD Card blockStart Start block address of SD Card where the writes should begin nBlock Total number of blocks to be written ",
							" Returns The buffer handle is returned in the commandHandle argument It will be DRV_MEMORY_COMMAND_HANDLE_INVALID if the request was not successful ",
							" Remarks This function is internally used by the file system and should not be used by application ",
							" DRV_MEMORY_Write Function ",
							" C void DRV_MEMORY_Write (  const DRV_HANDLE handle  SYS_MEDIA_BLOCK_COMMAND_HANDLE * commandHandle   void * sourceBuffer  uint32_t blockStart  uint32_t nBlock ) ",
							" Summary Interface to the file system to perform a write operation in Synchronous mode ",
							" Description This routine provides interface to the file system to perform a media write operation in synchronous mode of the Memory driver ",
							" Preconditions The DRV_MEMORY_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return buffer handle sourceBuffer The source buffer containing data to be programmed to the SD Card blockStart Start block address of SD Card where the writes should begin nBlock Total number of blocks to be written ",
							" Returns The buffer handle is returned in the commandHandle argument It will be DRV_MEMORY_COMMAND_HANDLE_INVALID if the request was not successful ",
							" Remarks This function is internally used by the file system and should not be used by application ",
							" DRV_MEMORY_Read Function ",
							" C void DRV_MEMORY_Read (  const DRV_HANDLE handle  SYS_MEDIA_BLOCK_COMMAND_HANDLE * commandHandle   void * sourceBuffer  uint32_t blockStart  uint32_t nBlock ) ",
							" Summary Interface to the file system to perform a read operation in Synchronous mode ",
							" Description This routine provides interface to the file system to perform a media read operation in synchronous mode of the Memory driver ",
							" Preconditions The DRV_MEMORY_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return buffer handle sourceBuffer The source buffer containing data to be programmed to the SD Card blockStart Start block address of SD Card where the writes should begin nBlock Total number of blocks to be written ",
							" Returns The buffer handle is returned in the commandHandle argument It will be DRV_MEMORY_COMMAND_HANDLE_INVALID if the request was not successful ",
							" Remarks This function is internally used by the file system and should not be used by application ",
							" DRV_MEMORY_COMMAND_HANDLE Typedef ",
							" C typedef SYS_MEDIA_BLOCK_COMMAND_HANDLE DRV_MEMORY_COMMAND_HANDLE ;  ",
							" Summary Handle to identify commands queued in the driver ",
							" Description A command handle is returned by a call to the Read Write Erase or EraseWrite functions This handle allows the application to track the completion of the operation This command handle is also returned to the client along with the event that has occurred with respect to the command This allows the application to connect the event to a specific command in case where multiple commands are queued The command handle associated with the command request expires when the client has been notified of the completion of the command (after event handler function that notifies the client returns) or after the command has been retired by the driver if no event handler callback was set ",
							" Remarks Refer sys_media h for definition of SYS_MEDIA_BLOCK_COMMAND_HANDLE ",
							" DRV_MEMORY_COMMAND_HANDLE_INVALID Macro ",
							" C # define DRV_MEMORY_COMMAND_HANDLE_INVALID SYS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID  ",
							" Summary This value defines the Memory Driver's Invalid Command Handle ",
							" Description This value defines the Memory Driver's Invalid Command Handle This value is returned by read/write/erase/erasewrite routines when the command request was not accepted ",
							" Remarks Refer sys_media h for definition of SYS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID ",
							" DRV_MEMORY_EVENT Enum ",
							" C typedef  enum  {  /* Operation has been completed successfully */ DRV_MEMORY_EVENT_COMMAND_COMPLETE = SYS_MEDIA_EVENT_BLOCK_COMMAND_COMPLETE   /* There was an error during the operation */ DRV_MEMORY_EVENT_COMMAND_ERROR = SYS_MEDIA_EVENT_BLOCK_COMMAND_ERROR } DRV_MEMORY_EVENT ;  ",
							" Summary Identifies the possible events that can result from a request ",
							" Description This enumeration identifies the possible events that can result from a read write erase or erasewrite request caused by the client One of these values is passed in the \"event\" parameter of the event handling callback function that client registered with the driver by calling the DRV_MEMORY_TransferHandlerSet function when a request is completed ",
							" Remarks Refer sys_media h for SYS_MEDIA_XXX definitions ",
							" DRV_MEMORY_COMMAND_STATUS Enum ",
							" C typedef  enum  {  /* Done OK and ready */ DRV_MEMORY_COMMAND_COMPLETED = SYS_MEDIA_COMMAND_COMPLETED   /* Scheduled but not started */ DRV_MEMORY_COMMAND_QUEUED = SYS_MEDIA_COMMAND_QUEUED   /* Currently being in transfer */ DRV_MEMORY_COMMAND_IN_PROGRESS = SYS_MEDIA_COMMAND_IN_PROGRESS   /* Unknown Command */ DRV_MEMORY_COMMAND_ERROR_UNKNOWN = SYS_MEDIA_COMMAND_UNKNOWN   } DRV_MEMORY_COMMAND_STATUS ;  ",
							" Summary Memory Driver command Status ",
							" Description Specifies the status of the command for the read write erase and erasewrite operations ",
							" Remarks Refer sys_media h for SYS_MEDIA_XXX definitions ",
							" DRV_MEMORY_TRANSFER_HANDLER Typedef ",
							" C typedef SYS_MEDIA_EVENT_HANDLER DRV_MEMORY_TRANSFER_HANDLER ; ",
							" Summary Pointer to a Memory Driver Event handler function ",
							" Description This data type defines the required function signature for the Memory event handling callback function A client must register a pointer to an event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive event calls back from the driver If the event is DRV_MEMORY_EVENT_COMMAND_COMPLETE it means that the requested operation was completed successfully If the event is DRV_MEMORY_EVENT_COMMAND_ERROR it means that the scheduled operation was not completed successfully The context parameter contains the handle to the client context provided at the time the event handling function was registered using the DRV_MEMORY_TransferHandlerSet function This context handle value is passed back to the client as the \"context\" parameter It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the read/write/erase request ",
							" Parameters Param Description event Identifies the type of event commandHandle Handle returned from the Read/Write/Erase/EraseWrite requests context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Example void appTransferHandler ( DRV_MEMORY_EVENT event  DRV_MEMORY_COMMAND_HANDLE commandHandle  uintptr_t context )  {  switch ( event )  {  case DRV_MEMORY_EVENT_COMMAND_COMPLETE :  { xfer_done = true ;  break ;  }  case DRV_MEMORY_EVENT_COMMAND_ERROR :  {  // Handle Error  break ;  }  default :  {  break ;  }  }  }  DRV_MEMORY_TransferHandlerSet ( memoryHandle  appTransferHandler   ( uintptr_t ) NULL ) ; ",
							" Remarks Used in Asynchronous mode of operation Refer sys_media h for definition of SYS_MEDIA_EVENT_HANDLER ",
							" MEMORY_DEVICE_TRANSFER_STATUS Enum ",
							" C typedef  enum  {  /* Transfer being processed */ MEMORY_DEVICE_TRANSFER_BUSY   /* Transfer is successfully completed*/ MEMORY_DEVICE_TRANSFER_COMPLETED   /* Transfer had error*/ MEMORY_DEVICE_TRANSFER_ERROR_UNKNOWN   } MEMORY_DEVICE_TRANSFER_STATUS ;  ",
							" Summary Memory Device Transfer Status ",
							" Description This Data structure is used to indicate the current transfer status of the attached media ",
							" Remarks None ",
							" MEMORY_DEVICE_GEOMETRY Struct ",
							" C typedef  struct  { uint32_t read_blockSize ; uint32_t read_numBlocks ; uint32_t numReadRegions ; uint32_t write_blockSize ; uint32_t write_numBlocks ; uint32_t numWriteRegions ; uint32_t erase_blockSize ; uint32_t erase_numBlocks ; uint32_t numEraseRegions ; uint32_t blockStartAddress ;  } MEMORY_DEVICE_GEOMETRY ;  ",
							" Summary Memory Device Geometry Table ",
							" Description This Data Structure is used by Memory driver to get the media geometry details The Media attached to memory driver needs to fill in this data structure when GEOMETRY_GET is called ",
							" Remarks None ",
							" DRV_MEMORY_DEVICE_INTERFACE Struct ",
							" C /* Function pointer typedef to open the attached media */  typedef DRV_HANDLE ( * DRV_MEMORY_DEVICE_OPEN ) (  const SYS_MODULE_INDEX drvIndex   const DRV_IO_INTENT ioIntent ) ;  /* Function pointer typedef to close the attached media */  typedef  void  ( * DRV_MEMORY_DEVICE_CLOSE ) (  const DRV_HANDLE handle ) ;  /* Function pointer typedef to erase a sector from attached media */  typedef bool ( * DRV_MEMORY_DEVICE_SECTOR_ERASE ) (  const DRV_HANDLE handle  uint32_t address ) ;  /* Function pointer typedef to get the status of the attached media */  typedef SYS_STATUS ( * DRV_MEMORY_DEVICE_STATUS ) (  const SYS_MODULE_INDEX drvIndex ) ;  /* Function pointer typedef to read from the attached media */  typedef bool ( * DRV_MEMORY_DEVICE_READ ) (  const DRV_HANDLE handle   void  * rx_data  uint32_t rx_data_length  uint32_t address ) ;  /* Function pointer typedef to write a page to the attached media */  typedef bool ( * DRV_MEMORY_DEVICE_PAGE_WRITE ) (  const DRV_HANDLE handle   void  * tx_data  uint32_t address ) ;  /* Function pointer typedef to get the Geometry details from attached media */  typedef bool ( * DRV_MEMORY_DEVICE_GEOMETRY_GET ) (  const DRV_HANDLE handle  MEMORY_DEVICE_GEOMETRY * geometry ) ;  /* Function pointer typedef to get the transfer Status from attached media */  typedef uint32_t ( * DRV_MEMORY_DEVICE_TRANSFER_STATUS_GET ) (  const DRV_HANDLE handle ) ;  /* Function pointer typedef for event handler to be sent to attached media */  typedef  void  ( * DRV_MEMORY_EVENT_HANDLER ) ( MEMORY_DEVICE_TRANSFER_STATUS status  uintptr_t context ) ;  /* Function pointer typedef to set the event handler with attached media */  typedef  void  ( * DRV_MEMORY_DEVICE_EVENT_HANDLER_SET )  (  const DRV_HANDLE handle  DRV_MEMORY_EVENT_HANDLER eventHandler  uintptr_t context ) ;  typedef  struct  { DRV_MEMORY_DEVICE_OPEN Open ; DRV_MEMORY_DEVICE_CLOSE Close ; DRV_MEMORY_DEVICE_SECTOR_ERASE SectorErase ; DRV_MEMORY_DEVICE_STATUS Status ; DRV_MEMORY_DEVICE_READ Read ; DRV_MEMORY_DEVICE_PAGE_WRITE PageWrite ; DRV_MEMORY_DEVICE_EVENT_HANDLER_SET EventHandlerSet ; DRV_MEMORY_DEVICE_GEOMETRY_GET GeometryGet ; DRV_MEMORY_DEVICE_TRANSFER_STATUS_GET TransferStatusGet ;  } DRV_MEMORY_DEVICE_INTERFACE ;  ",
							" Summary Memory Device API Interface ",
							" Description This Data Structure is used by attached media to populate the required device functions for media transactions This will be used in memory driver init structure ",
							" Remarks None ",
							" DRV_MEMORY_INIT Struct ",
							" C typedef  struct  {  /* Attached Memory Device index */ SYS_MODULE_INDEX memDevIndex ;  /* Flash Device functions */  const DRV_MEMORY_DEVICE_INTERFACE * memoryDevice ;  /* Flag to indicate if attached memory device configured to interrupt mode */ bool isMemDevInterruptEnabled ;  /* Number of milliseconds to poll for transfer status check */ uint32_t memDevStatusPollUs ;  /* FS enabled */ bool isFsEnabled ;  /* Memory Device Type */ uint8_t deviceMediaType ;  /* Erase Write Buffer pointer */ uint8_t * ewBuffer ;  /* Memory pool for Client Objects */ uintptr_t clientObjPool ;  /* Pointer to Buffer Objects array */ uintptr_t bufferObj ;  /* Buffer Queue Size */ size_t queueSize ;  /* Maximum number of clients */ size_t nClientsMax ;  } DRV_MEMORY_INIT ;  ",
							" Summary Memory Driver Initialization Data ",
							" Description This data type defines the data required to initialize the Memory Driver ",
							" Remarks Not all initialization features are available for all devices Please refer to the attached media device capabilities ",
							" NAND Flash Driver This driver provides the blocking functions to read write and erase NAND Flash memory The driver uses the below peripheral library to interface with the NAND Flash SMC Peripheral Library Supports NAND Flash Controller Programmable Multi-bit Error Correcting Code (PMECC) and Programmable Multibit ECC Error Location Controller (PMERRLOC) Key Features: Supports Open NAND Flash Interface (ONFI) 1 0-compliant NAND Flash devices Supports single instance of the NAND Flash and single client to the driver Supports Block Erase Operations Supports Page/Block Write and Read Operations Supports Skip Block management Supports Error Correction Code Supports Direct memory access (DMA) for NAND Flash write and read operations The library can be used in both Bare-Metal and RTOS environments ",
							" How the Library Works The NAND flash driver library is a single-client single-instance based driver interface Abstraction Model The NAND Flash driver interface provides read write and erase functions that abstract out the internal workings of the NAND Flash driver and the underlying External Bus Interface (EBI)/NAND Flash Controller drv_nand_flash_abstraction_model Working flow The NAND Flash Driver performs initialization and puts the driver to ready state This status of the driver can be checked using DRV_NAND_FLASH_Status() The NAND Flash driver library performs set of flash operations during DRV_NAND_FLASH_Open() If any of the below flash operations fails an invalid Handle will be returned DRV_NAND_FLASH_Open() can be repeatedly called until it returns a valid handle Resets the NAND Flash device Reads the Parameter page of the NAND Flash device Setup the PMECC descriptor if PMECC enabled The NAND Flash driver library reads NAND Flash geometry using DRV_NAND_FLASH_GeometryGet() The NAND Flash driver library performs a block erase using DRV_NAND_FLASH_SkipBlock_BlockErase() The NAND Flash driver library performs a page and block write using DRV_NAND_FLASH_SkipBlock_PageWrite() and DRV_NAND_FLASH_SkipBlock_BlockWrite() respectively The NAND Flash driver library performs a page and block read using DRV_NAND_FLASH_SkipBlock_PageRead() and DRV_NAND_FLASH_SkipBlock_BlockRead() respectively ",
							" Using The Library The NAND Flash driver provides the blocking API's to read write and erase NAND Flash memory The NAND Flash driver can be used in following ways: To perform page and block write to NAND Flash To perform page and block read from NAND Flash To perform block erase operation To read flash identifier codes Parameter page and geometry of the NAND Flash To reset the flash device and enable/disable target specific features To check whether NAND Flash block is bad or good and tag the NAND Flash block to bad or good Example application to Erase Write and Read NAND Flash Memory # define PAGE_SIZE 4096  # define SPARE_SIZE 224  # define BUFFER_SIZE (PAGE_SIZE + SPARE_SIZE)  # define NAND_FLASH_ADDR_ONFI_SIGNATURE 0x20  static APP_DATA appData ;  static uint16_t blockNum =  3 ;  static uint16_t pageNum =  0 ;  static  char  * ptrReadId =  0 ;  void APP_Initialize (  void  )  { uint32_t i =  0 ;  /* Place the App state machine in its initial state */ appData  state = APP_STATE_INIT ;  for  ( i =  0 ; i  PAGE_SIZE ; i ++ )  { appData  writeBuffer [ i ]  = i ;  }  }  void APP_Tasks (  void  )  {  /* Check the application's current state */  switch  ( appData  state )  {  /* Application's initial state */  case APP_STATE_INIT :  {  if  ( DRV_NAND_FLASH_Status ( DRV_NAND_FLASH_INDEX )  == SYS_STATUS_READY )  { appData  state = APP_STATE_OPEN_DRIVER ;  }  break ;  }  case APP_STATE_OPEN_DRIVER :  { appData  handle =  DRV_NAND_FLASH_Open ( ( SYS_MODULE_INDEX ) DRV_NAND_FLASH_INDEX  DRV_IO_INTENT_READWRITE ) ;  if  ( appData  handle = DRV_HANDLE_INVALID )  { appData  state = APP_STATE_ID_GET ;  }  break ;  }  case APP_STATE_ID_GET :  {  if  ( DRV_NAND_FLASH_IdRead ( appData  handle    appData  readId  NAND_FLASH_ADDR_ONFI_SIGNATURE )  = true )  { appData  state = APP_STATE_ERROR ;  }  else  { ptrReadId =  ( char  * )  appData  readId ;  if  ( ptrReadId [ 0 ]  ==  'O'   ptrReadId [ 1 ]  ==  'N'   ptrReadId [ 2 ]  ==  'F'   ptrReadId [ 3 ]  ==  'I' )  { appData  state = APP_STATE_GEOMETRY_GET ;  }  }  break ;  }  case APP_STATE_GEOMETRY_GET :  {  if  ( DRV_NAND_FLASH_GeometryGet ( appData  handle    appData  geometry )  = true )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_ERASE_FLASH ;  }  break ;  }  case APP_STATE_ERASE_FLASH :  {  if  ( DRV_NAND_FLASH_SkipBlock_BlockErase ( appData  handle  blockNum   0 )  = true )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_WRITE_MEMORY ;  }  break ;  }  case APP_STATE_WRITE_MEMORY :  {  if  ( DRV_NAND_FLASH_SkipBlock_PageWrite ( appData  handle  blockNum  pageNum  appData  writeBuffer   0  false )  = true )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_READ_MEMORY ;  }  break ;  }  case APP_STATE_READ_MEMORY :  {  if  ( DRV_NAND_FLASH_SkipBlock_PageRead ( appData  handle  blockNum  pageNum  appData  readBuffer   0  false )  = true )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_VERIFY_DATA ;  }  break ;  }  case APP_STATE_VERIFY_DATA :  {  if  (  memcmp ( appData  writeBuffer  appData  readBuffer  appData  geometry  pageSize ) )  { appData  state = APP_STATE_SUCCESS ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_SUCCESS :  {  DRV_NAND_FLASH_Close ( appData  handle ) ; appData  state = APP_STATE_IDLE ;  break ;  }  case APP_STATE_ERROR :  case APP_STATE_IDLE :  default :  break ;  }  }  ",
							" Configuring The Library The NAND Flash driver library should be configured through the MHC The following figures show the MHC configuration window for the NAND Flash driver and brief description NAND Flash Driver with SMC peripheral connected drv_nand_flash_mhc_config_with_smc Configuration Options PLIB Used: Specifies the Peripheral library connected Number Of Clients: Indicates maximum number of clients Always set to one as it supports only a single client Chip Select: NAND Flash chip select - NAND Flash Controller support available in this chip select number Enable Error Correction Code (PMECC): Provides hardware accelerated error correction code using PMECC and PMERRLOC The Programmable Multibit Error Correction Code Controller (PMECC) can be used to generate redundancy information for NAND Flash devices It supports redundancy for correction of 2 4 8 12 or 24 bits of error per sector of data Programmable Multibit ECC Error Location Controller (PMERRLOC) provides Hardware Acceleration to Determine Roots of Polynomials Defined over a Finite Field Use DMA for Transmit and Receive If this option is enabled then NAND Flash driver uses DMA for page/block read and write operations from/to the NAND Flash device ",
							" Library Interface NAND Flash driver library provides the following interfaces: Functions Name Description DRV_NAND_FLASH_Initialize Initializes the NAND FLASH Driver DRV_NAND_FLASH_Open Opens the specified NAND FLASH driver instance and returns a handle to it DRV_NAND_FLASH_Close Closes an opened-instance of the NAND FLASH driver DRV_NAND_FLASH_Status Gets the current status of the NAND FLASH driver module DRV_NAND_FLASH_ResetFlash Reset the flash device to standby mode DRV_NAND_FLASH_TransferStatusGet Gets the current status of the transfer request DRV_NAND_FLASH_IdRead Gets identifier codes from NAND Flash DRV_NAND_FLASH_FeatureSet Enables or disables target specific features DRV_NAND_FLASH_FeatureGet Read target specific features DRV_NAND_FLASH_ParameterPageRead Returns the Parameter page of the NAND Flash device DRV_NAND_FLASH_GeometryGet Returns the geometry of the NAND Flash device DRV_NAND_FLASH_SkipBlock_BlockCheck Checks whether NAND Flash block is bad or good DRV_NAND_FLASH_SkipBlock_BlockTag Tag NAND Flash block to bad or good DRV_NAND_FLASH_SkipBlock_BlockErase Erase a block DRV_NAND_FLASH_SkipBlock_BlockRead Reads the data of a whole block from NAND Flash DRV_NAND_FLASH_SkipBlock_BlockWrite Writes the data of a whole block to NAND Flash DRV_NAND_FLASH_SkipBlock_PageRead Reads the data and/or the spare area of a page of given block from NAND Flash DRV_NAND_FLASH_SkipBlock_PageWrite Writes the data and/or the spare area of a page of given block to NAND Flash Data types and constants Name Type Description DRV_NAND_FLASH_TRANSFER_STATUS Enum NAND FLASH Driver Transfer Status DRV_NAND_FLASH_GEOMETRY Struct NAND FLASH Device geometry DRV_NAND_FLASH_DATA Struct NAND FLASH Device data ",
							" DRV_NAND_FLASH_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_NAND_FLASH_Initialize (  const SYS_MODULE_INDEX drvIndex   const SYS_MODULE_INIT * const init ) ",
							" Summary Initializes the NAND FLASH Driver ",
							" Description This routine initializes the NAND FLASH driver making it ready for client to use Get the data address of NAND Flash ",
							" Precondition None ",
							" Parameters Param Description drvIndex Identifier for the instance to be initialized init Pointer to a data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example // This code snippet shows an example of initializing the NAND FLASH Driver  // with NAND FLASH device attached SYS_MODULE_OBJ objectHandle ;  const DRV_NAND_FLASH_PLIB_INTERFACE drvNandFlashPlibAPI =  {   DataAddressGet = SMC_DataAddressGet    CommandWrite = SMC_CommandWrite    CommandWrite16 = SMC_CommandWrite16    AddressWrite = SMC_AddressWrite    AddressWrite16 = SMC_AddressWrite16    DataWrite = SMC_DataWrite    DataWrite16 = SMC_DataWrite16    DataRead = SMC_DataRead    DataRead16 = SMC_DataRead16    DataPhaseStart = PMECC_DataPhaseStart    StatusIsBusy = PMECC_StatusIsBusy    ErrorGet = PMECC_ErrorGet    RemainderGet = PMECC_RemainderGet    ECCGet = PMECC_ECCGet    ErrorLocationGet = PMERRLOC_ErrorLocationGet    ErrorLocationDisable = PMERRLOC_ErrorLocationDisable    SigmaSet = PMERRLOC_SigmaSet    ErrorLocationFindNumOfRoots = PMERRLOC_ErrorLocationFindNumOfRoots } ;  const DRV_NAND_FLASH_INIT drvNandFlashInitData =  {   nandFlashPlib =   drvNandFlashPlibAPI   } ; objectHandle =  DRV_NAND_FLASH_Initialize ( ( SYS_MODULE_INDEX ) DRV_NAND_FLASH_INDEX   ( SYS_MODULE_INIT * )  drvNandFlashInitData ) ;  if  ( SYS_MODULE_OBJ_INVALID == objectHandle )  {  // Handle error  } ",
							" Remarks This routine must be called before any other NAND FLASH driver routine is called This routine should only be called once during system initialization ",
							" DRV_NAND_FLASH_Open Function ",
							" C DRV_HANDLE DRV_NAND_FLASH_Open (  const SYS_MODULE_INDEX drvIndex   const DRV_IO_INTENT ioIntent ) ",
							" Summary Opens the specified NAND FLASH driver instance and returns a handle to it ",
							" Description This routine opens the specified NAND FLASH driver instance and provides a handle This handle must be provided to all other client-level operations to identify the caller and the instance of the driver Reset NAND Flash Gets and stores NAND Flash Geometry to use in driver Initializes PMECC descriptor if PMECC is enabled ",
							" Preconditions Function DRV_NAND_FLASH_Initialize must have been called before calling this function Driver should be in ready state to accept the request Can be checked by calling DRV_NAND_FLASH_Status() ",
							" Parameters Param Description drvIndex Identifier for the instance to be opened ioIntent Zero or more of the values from the enumeration DRV_IO_INTENT \"ORed\" together to indicate the intended use of the driver ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) If an error occurs DRV_HANDLE_INVALID is returned Errors can occur under the following circumstances: If the driver hardware instance being opened is not initialized Fail to reset NAND Flash OR fail to read NAND Flash Geometry Invalid PMECC configurations for NAND Flash if PMECC is enabled ",
							" Example DRV_HANDLE handle ; handle =  DRV_NAND_FLASH_Open ( ( SYS_MODULE_INDEX ) DRV_NAND_FLASH_INDEX  DRV_IO_INTENT_READWRITE ) ;  if  ( DRV_HANDLE_INVALID == handle )  {  // Unable to open the driver  } ",
							" Remarks The handle returned is valid until the DRV_NAND_FLASH_Close routine is called If the driver has already been opened it should not be opened again This routine will block wait for hardware access ",
							" DRV_NAND_FLASH_Close Function ",
							" C void  DRV_NAND_FLASH_Close (  const DRV_HANDLE handle ) ",
							" Summary Closes an opened-instance of the NAND FLASH driver ",
							" Description This routine closes an opened-instance of the NAND FLASH driver invalidating the handle ",
							" Precondition DRV_NAND_FLASH_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns None ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open  DRV_NAND_FLASH_Close ( handle ) ; ",
							" Remarks After calling this routine the handle passed in \"handle\" must not be used with any of the remaining driver routines A new handle must be obtained by calling DRV_NAND_FLASH_Open before the caller may use the driver again Usually there is no need for the driver client to verify that the Close operation has completed ",
							" DRV_NAND_FLASH_Status Function ",
							" C SYS_STATUS DRV_NAND_FLASH_Status (  const SYS_MODULE_INDEX drvIndex ) ",
							" Summary Gets the current status of the NAND FLASH driver module ",
							" Description This routine provides the current status of the NAND FLASH driver module ",
							" Preconditions Function DRV_NAND_FLASH_Initialize should have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the instance used to initialize driver ",
							" Returns SYS_STATUS_READY - Indicates that the driver is ready and accept requests for new operations SYS_STATUS_UNINITIALIZED - Indicates the driver is not initialized SYS_STATUS_BUSY - Indicates the driver is in busy state ",
							" Example SYS_STATUS Status ; Status =  DRV_NAND_FLASH_Status ( DRV_NAND_FLASH_INDEX ) ; ",
							" Remarks This routine will NEVER block wait for hardware ",
							" DRV_NAND_FLASH_ResetFlash Function ",
							" C bool DRV_NAND_FLASH_ResetFlash ( const DRV_HANDLE handle ) ",
							" Summary Reset the flash device to standby mode ",
							" Description This function schedules a blocking operation for resetting the flash device to standby mode All the volatile bits and settings will be cleared then which makes the device return to the default status as power on ",
							" Precondition The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns true - Flash reset is completed successfully false - Flash reset is failed ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open  if ( true =  DRV_NAND_FLASH_ResetFlash ( handle ) )  {  // Error handling here  } ",
							" Remarks This routine will block wait for hardware access ",
							" DRV_NAND_FLASH_TransferStatusGet Function ",
							" C DRV_NAND_FLASH_TRANSFER_STATUS DRV_NAND_FLASH_TransferStatusGet ( const DRV_HANDLE handle ) ",
							" Summary Gets the current status of the transfer request ",
							" Description This routine gets the current status of the transfer request The application must use this routine where the status of a scheduled request needs to be polled on ",
							" Preconditions The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns DRV_NAND_FLASH_TRANSFER_ERROR_UNKNOWN - If invalid handle DRV_NAND_FLASH_TRANSFER_BUSY - If the current transfer request is still being processed DRV_NAND_FLASH_TRANSFER_COMPLETED - If the transfer request is completed DRV_NAND_FLASH_TRANSFER_FAIL - If the transfer is failed ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open  if  ( DRV_NAND_FLASH_TRANSFER_COMPLETED ==  DRV_NAND_FLASH_TransferStatusGet ( handle ) )  {  // Operation Done  } ",
							" Remarks This routine will block wait for hardware access ",
							" DRV_NAND_FLASH_IdRead Function ",
							" C bool DRV_NAND_FLASH_IdRead ( const DRV_HANDLE handle  uint32_t * readId  uint8_t address ) ",
							" Summary Gets identifier codes from NAND Flash ",
							" Description This routine read identifier codes from NAND Flash ",
							" Preconditions The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine readId Pointer to 32-bit unsigned int into which ID will be stored address Address to be send after command cycle Address 0x20 is used for ONFI compliant Flash ",
							" Returns true - If ID read successfully from the flash false - If invalid handle ",
							" Example # define NAND_FLASH_ADDR_ONFI_SIGNATURE 0x20 uint32_t readId =  0 ; DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open  if  ( DRV_NAND_FLASH_IdRead ( handle    readId  NAND_FLASH_ADDR_ONFI_SIGNATURE ) )  {  // ID read successfully  } ",
							" Remarks This routine will block for hardware access ",
							" DRV_NAND_FLASH_FeatureSet Function ",
							" C bool DRV_NAND_FLASH_FeatureSet ( const DRV_HANDLE handle  uint8_t * featureData  uint8_t featureDataSize  uint8_t featureAddress ) ",
							" Summary Enables or disables target specific features ",
							" Description This routine enables or disables target specific features to NAND Flash ",
							" Preconditions The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine featureData Pointer to source buffer containing subfeature data to be programmed into NAND Flash featureDataSize Total number of subfeature data bytes to be written featureAddress Specific feature address to be send after command cycle ",
							" Returns true - If specific feature is enabled or disabled successfully to the flash false - If invalid handle ",
							" Example i  e  Disable NAND Flash ECC controller if NAND Flash supports internal ECC controller # define NAND_FLASH_TARGET_DISABLE_INTERNAL_ECC 0x90 uint8_t featureData [ 4 ]  =  { 0   0   0   0 } ; DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open  if  ( DRV_NAND_FLASH_FeatureSet ( handle  featureData   sizeof ( featureData )  NAND_FLASH_TARGET_DISABLE_INTERNAL_ECC ) )  {  // Flash internal ECC controller is disabled  } ",
							" Remarks This routine will block for hardware access ",
							" DRV_NAND_FLASH_FeatureGet Function ",
							" C bool DRV_NAND_FLASH_FeatureGet ( const DRV_HANDLE handle  uint8_t * featureData  uint8_t featureDataSize  uint8_t featureAddress ) ",
							" Summary Read target specific features ",
							" Description This routine reads target specific features from NAND Flash ",
							" Preconditions The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine featureData Pointer to destination buffer into which subfeature data to be placed from NAND Flash featureDataSize Total number of subfeature data bytes to be read featureAddress Specific feature address to be send after command cycle ",
							" Returns true - If specific feature is read successfully from the flash false - If invalid handle ",
							" Example i  e  Read NAND Flash ECC controller if NAND Flash supports internal ECC controller # define NAND_FLASH_TARGET_DISABLE_INTERNAL_ECC 0x90 uint8_t featureData [ 4 ] ; DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open  if  ( DRV_NAND_FLASH_FeatureGet ( handle  featureData   sizeof ( featureData )  NAND_FLASH_TARGET_DISABLE_INTERNAL_ECC ) )  {  // Feature data read successfully  } ",
							" Remarks This routine will block for hardware access ",
							" DRV_NAND_FLASH_GeometryGet Function ",
							" C bool DRV_NAND_FLASH_GeometryGet (  const DRV_HANDLE handle  DRV_NAND_FLASH_GEOMETRY * geometry ) ; ",
							" Summary Returns the geometry of the NAND Flash device ",
							" Description This API gives the following geometrical details of the NAND Flash: deviceId (JEDEC Manufacturer ID) Bus Width Number of data bytes per page Number of spare bytes per page Block Size Device Size Number of logical units Number of bits of ECC correction ",
							" Precondition The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine geometry Pointer to destination geometry buffer into which geometry to be placed ",
							" Returns true - If geometry is successfully read from the NAND Flash false - If geometry read is failed ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open DRV_NAND_FLASH_GEOMETRY nandFlashFlashGeometry ;  if  ( DRV_NAND_FLASH_GeometryGet ( handle    nandFlashFlashGeometry ) )  {  // Geometry read successfully  } ",
							" Remarks This routine will block wait for hardware access ",
							" DRV_NAND_FLASH_ParameterPageRead Function ",
							" C bool DRV_NAND_FLASH_ParameterPageRead ( const DRV_HANDLE handle  uint8_t * parameterPage  uint32_t size ) ; ",
							" Summary Returns the Parameter page of the NAND Flash device ",
							" Description This routine reads the parameter page of the NAND Flash device It reads target's organization features timings and other behavioural parameters of NAND Flash device ",
							" Precondition The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine parameterPage Pointer to destination buffer into which parameter page to be placed from NAND Flash size Total number of parameter page data bytes to be read ",
							" Returns true - If parameter page is successfully read from the NAND Flash false - If parameter page read is failed ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open uint8_t parameterPage [ 116 ] ;  if  ( DRV_NAND_FLASH_ParameterPageRead ( handle  parameterPage   sizeof ( parameterPage ) ) )  {  // Parameter page read successfully  } ",
							" Remarks This routine will block wait for hardware access ",
							" DRV_NAND_FLASH_SkipBlock_BlockCheck Function ",
							" C bool DRV_NAND_FLASH_SkipBlock_BlockCheck ( const DRV_HANDLE handle  uint16_t blockNum ) ",
							" Summary Checks whether NAND Flash block is bad or good ",
							" Description This routine returns false if the given block of NAND Flash device is bad otherwise true ",
							" Preconditions The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine blockNum Block number to check ",
							" Returns true - If block is good false - If block is bad ",
							" Example uint16_t blockNum =  0 ; DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open  if  ( DRV_NAND_FLASH_SkipBlock_BlockCheck ( handle  blockNum ) )  // Block is good  } ",
							" Remarks This routine will block for hardware access ",
							" DRV_NAND_FLASH_SkipBlock_BlockTag Function ",
							" C bool DRV_NAND_FLASH_SkipBlock_BlockTag ( const DRV_HANDLE handle  uint16_t blockNum  bool badBlock ) ",
							" Summary Tag NAND Flash block to bad or good ",
							" Description This routine tags given block of NAND Flash device to bad or good ",
							" Preconditions The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine blockNum Block number to be tagged badBlock 1 - Block to be tagged as bad block 0 - If block to be tagged as good block ",
							" Returns true - If given block is tagged as bad or good false - If failed to tag a block ",
							" Example uint16_t blockNum =  0 ; DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open  if  ( DRV_NAND_FLASH_SkipBlock_BlockTag ( handle  blockNum   1 ) )  // Block is tagged as bad  } ",
							" Remarks This routine will block for hardware access ",
							" DRV_NAND_FLASH_SkipBlock_BlockErase Function ",
							" C bool DRV_NAND_FLASH_SkipBlock_BlockErase ( const DRV_HANDLE handle  uint16_t blockNum  bool disableBlockCheck ) ",
							" Summary Erase a block ",
							" Description This function schedules a blocking block erase operation of flash memory It erases a given block ",
							" Preconditions The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine blockNum Block number to be erased disableBlockCheck 0 - Block will be checked as good before erasing a given block 1 - Block will not check before erasing a given block ",
							" Returns true - If the block erase is successfully completed false - If block erase fails ",
							" Example uint16_t blockNum =  0 ; DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open  if ( DRV_NAND_FLASH_SkipBlock_BlockErase ( handle  blockNum   0 ) )  {  // Block erase is successfully completed  }  ",
							" Remarks This routine will block wait until erase request is completed successfully Client should wait until erase is complete to send next transfer request ",
							" DRV_NAND_FLASH_SkipBlock_BlockRead Function ",
							" C bool DRV_NAND_FLASH_SkipBlock_BlockRead ( const DRV_HANDLE handle  uint16_t blockNum  uint8_t * data  bool disableBlockCheck ) ",
							" Summary Reads the data of a whole block from NAND Flash ",
							" Description This function schedules a blocking operation for reading the data of a whole block from NAND Flash ",
							" Precondition The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine blockNum Block number to read data Pointer to destination data buffer disableBlockCheck 0 - Block will be checked as good before reading a given block 1 - Block will not check before reading a given block ",
							" Returns true - If Block read is successfully completed false - If Block read fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open uint16_t blockNum =  3 ;  static uint8_t blockBuffer [ 262144  +  14336 ] ;  if  ( DRV_NAND_FLASH_SkipBlock_BlockRead ( handle  blockNum  blockBuffer   0 ) )  {  // Block read successfully completed  }  ",
							" Remarks This routine will block waiting until read request is completed successfully ",
							" DRV_NAND_FLASH_SkipBlock_BlockWrite Function ",
							" C bool DRV_NAND_FLASH_SkipBlock_BlockWrite ( const DRV_HANDLE handle  uint16_t blockNum  uint8_t * data  bool disableBlockCheck ) ",
							" Summary Writes the data of a whole block to NAND Flash ",
							" Description This function schedules a blocking operation for writing the data of a whole block to NAND Flash ",
							" Precondition The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine blockNum Block number to write data Pointer to source data buffer disableBlockCheck 0 - Block will be checked as good before writing a given block 1 - Block will not check before writing a given block ",
							" Returns true - If Block write is successfully completed false - If Block write fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open uint16_t blockNum =  3 ;  static uint8_t blockBuffer [ 262144  +  14336 ] ;  memset ( blockBuffer   0x55   sizeof ( blockBuffer ) ) ;  if  ( DRV_NAND_FLASH_SkipBlock_BlockWrite ( handle  blockNum  blockBuffer   0 ) )  {  // Block write successfully completed  }  ",
							" Remarks This routine will block wait until write request is submitted successfully Client should wait until write is complete to send next transfer request ",
							" DRV_NAND_FLASH_SkipBlock_PageRead Function ",
							" C bool DRV_NAND_FLASH_SkipBlock_PageRead (  const DRV_HANDLE handle  uint16_t blockNum  uint16_t pageNum  uint8_t * data  uint8_t * spare  bool disableBlockCheck ) ; ",
							" Summary Reads the data and/or the spare area of a page of given block from NAND Flash ",
							" Description This function schedules a blocking operation for reading the data and/or the spare area of a page of given block from NAND Flash ",
							" Precondition The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine blockNum Block number to read page from pageNum Page number to read inside the given block data Pointer to destination data buffer spare Pointer to destination spare buffer disableBlockCheck 0 - Block will be checked as good before reading a page 1 - Block will not check before reading a page ",
							" Returns true - If Page read is successfully completed false - If Page read fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open uint16_t blockNum =  3 ; uint16_t pageNum =  0 ;  static uint8_t pageBuffer [ 4096  +  224 ] ;  if  ( DRV_NAND_FLASH_SkipBlock_PageRead ( handle  blockNum  pageNum  pageBuffer   0   0 ) )  {  // Page read successfully completed  }  ",
							" Remarks This routine will block waiting until read request is completed successfully ",
							" DRV_NAND_FLASH_SkipBlock_PageWrite Function ",
							" C bool DRV_NAND_FLASH_SkipBlock_PageWrite (  const DRV_HANDLE handle  uint16_t blockNum  uint16_t pageNum  uint8_t * data  uint8_t * spare  bool disableBlockCheck ) ; ",
							" Summary Writes the data and/or the spare area of a page of given block to NAND Flash ",
							" Description This function schedules a blocking operation for writing the data and/or the spare area of a page of given block to NAND Flash ",
							" Precondition The DRV_NAND_FLASH_Open() routine must have been called for the specified NAND FLASH driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine blockNum Block number to write page pageNum Page number to write inside the given block data Pointer to source data buffer spare Pointer to source spare buffer disableBlockCheck 0 - Block will be checked as good before writing a page 1 - Block will not check before writing a page ",
							" Returns true - If Page write is successfully completed false - If Page write fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_NAND_FLASH_Open uint16_t blockNum =  3 ; uint16_t pageNum =  0 ;  static uint8_t pageBuffer [ 4096  +  224 ] ;  memset ( pageBuffer   0x55   sizeof ( pageBuffer ) ) ;  if  ( DRV_NAND_FLASH_SkipBlock_PageWrite ( handle  blockNum  pageNum  pageBuffer   0   0 ) )  {  // Page write successfully completed  }  ",
							" Remarks This routine will block wait until write request is submitted successfully Client should wait until write is complete to send next transfer request ",
							" DRV_NAND_FLASH_TRANSFER_STATUS Enum ",
							" C typedef  enum  {  /* Transfer is being processed */ DRV_NAND_FLASH_TRANSFER_BUSY   /* Transfer is successfully completed */ DRV_NAND_FLASH_TRANSFER_COMPLETED   /* Transfer is failed from NAND Flash */ DRV_NAND_FLASH_TRANSFER_FAIL   /* Transfer had unknown error */ DRV_NAND_FLASH_TRANSFER_ERROR_UNKNOWN   } DRV_NAND_FLASH_TRANSFER_STATUS ;  ",
							" Summary NAND FLASH Driver Transfer Status ",
							" Description This data type will be used to indicate the current transfer status for NAND FLASH driver ",
							" Remarks None ",
							" DRV_NAND_FLASH_GEOMETRY Struct ",
							" C typedef  struct  {  /* Identifier for the device */ uint8_t deviceId ;  /* Data Bus Width (8/16) */ uint8_t dataBusWidth ;  /* Size of the device in bytes */ uint32_t deviceSize ;  /* Size of the data area of a page in bytes */ uint32_t pageSize ;  /* Size of the spare area of a page in bytes */ uint16_t spareSize ;  /* Size of one block in bytes */ uint32_t blockSize ;  /* Number of logical units */ uint8_t numberOfLogicalUnits ;  /* Number of bits of ECC correction */ uint8_t eccCorrectability ;  } DRV_NAND_FLASH_GEOMETRY ;  ",
							" Summary NAND FLASH Device geometry ",
							" Description This data type will be used to get the characteristics of the NAND FLASH Device ",
							" Remarks None ",
							" DRV_NAND_FLASH_DATA Struct ",
							" C typedef  struct  {  /* NAND Flash Geometry */ DRV_NAND_FLASH_GEOMETRY nandFlashGeometry ;  /* NAND Flash data address */ uint32_t dataAddress ;  /* NAND Flash spare/ecc buffer */ CACHE_ALIGN uint8_t spareBuffer [ 512 ] ;  } DRV_NAND_FLASH_DATA ;  ",
							" Summary NAND FLASH Device data ",
							" Description This data type will be used to store the data of the NAND FLASH Device ",
							" Remarks None ",
							" SDMMC Driver The SDMMC driver is a multi-client multi-instance buffer model based block driver interface which can be used to communicate with SD or eMMC cards Key Features of Memory Driver: Supports Asynchronous (non-blocking) mode of operation It works in both Bare Metal and RTOS environment ",
							" How the Library Works The SDMMC driver library is a multi-client multi-instance buffer queue model based block driver interface Abstraction Model The SDMMC driver provides abstraction to communicate with SD/eMMC card through the HSMCI or SDHC peripheral library interface drv_sdmmc_abstraction_model SDMMC Driver Features: Driver has a buffer queue which allows the capability of accepting multiple requests Driver can either have File-system as client or Application or USB as client Every transfer request expects data in blocks Block details (Size and number of blocks) can be retrieved by DRV_SDMMC_GeometryGet() Driver provides feature to register call back for transfer complete event which can used by clients to get notified Works in both Bare-Metal and RTOS environment in Asynchronous mode Bare-Metal: A dedicated task routine DRV_SDMMC_Tasks() is called from SYS_Tasks() to process the data from the instance queue RTOS: A dedicated thread is created for task routine DRV_SDMMC_Tasks() to process the data from the instance queue API's return with a valid handle which can be used to check whether transfer request is accepted or not A Client specific handler will be called to indicate the status of transfer ",
							" Using The Library The SDMMC driver can be used to communicate with SD/eMMC Cards Modes supported: Asynchronous mode : Supported in both Bare-metal and RTOS environment Usage Methods Application can directly use the SDMMC driver API's to perform Read/Write operations Application can use File System service layer and perform file operations on the SD/eMMC Card It can be interfaced with Middleware's like USB Example application to Write and Read SD Card in Asynchronous mode /* Write and Read 60KB of Data */  # define SDMMC_DATA_SIZE (61440U)  # define SDMMC_BUFFER_SIZE (SDMMC_DATA_SIZE / sizeof(uint32_t))  # define GEOMETRY_TABLE_READ_ENTRY (0)  # define GEOMETRY_TABLE_WRITE_ENTRY (1)  # define GEOMETRY_TABLE_ERASE_ENTRY (2)  # define BLOCK_START 0x2000 SYS_MEDIA_GEOMETRY * geometry =  NULL ; APP_DATA appData ;  /* Read Buffer */ uint32_t CACHE_ALIGN readBuffer [ SDMMC_BUFFER_SIZE ] ;  /* Write Buffer*/ uint32_t CACHE_ALIGN writeBuffer [ SDMMC_BUFFER_SIZE ] ;  void appTransferHandler ( DRV_SDMMC_EVENT event  DRV_SDMMC_COMMAND_HANDLE commandHandle  uintptr_t context )  { APP_DATA * app_data =  ( APP_DATA * ) context ;  switch ( event )  {  case DRV_SDMMC_EVENT_COMMAND_COMPLETE :  { app_data - xfer_done = true ;  break ;  }  case DRV_SDMMC_EVENT_COMMAND_ERROR :  { app_data - state = APP_STATE_ERROR ;  break ;  }  default :  {  break ;  }  }  }  void APP_Initialize (  void  )  { uint32_t i =  0 ;  /* Place the App state machine in its initial state */ appData  state = APP_STATE_OPEN_DRIVER ; appData  xfer_done = false ;  for  ( i =  0 ; i  SDMMC_BUFFER_SIZE ; i ++ )  { writeBuffer [ i ]  = i ;  }  }  void APP_Tasks (  void  )  {  /* Check the application's current state */  switch  ( appData  state )  {  case APP_STATE_OPEN_DRIVER :  { appData  sdmmcHandle =  DRV_SDMMC_Open ( DRV_SDMMC_INDEX_0  DRV_IO_INTENT_READWRITE ) ;  if  ( appData  sdmmcHandle = DRV_HANDLE_INVALID )  {  DRV_SDMMC_EventHandlerSet ( appData  sdmmcHandle   ( const  void * ) appTransferHandler   ( uintptr_t )  appData ) ; appData  state = APP_STATE_SDCARD_ATTACHED ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_SDCARD_ATTACHED :  {  if  ( DRV_SDMMC_IsAttached ( appData  sdmmcHandle )  == true )  { appData  state = APP_STATE_GEOMETRY_GET ;  }  break ;  }  case APP_STATE_GEOMETRY_GET :  { geometry =  DRV_SDMMC_GeometryGet ( appData  sdmmcHandle ) ;  if  ( geometry ==  NULL )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  numReadBlocks =  ( SDMMC_DATA_SIZE / geometry - geometryTable [ GEOMETRY_TABLE_READ_ENTRY ]  blockSize ) ; appData  numWriteBlocks =  ( SDMMC_DATA_SIZE / geometry - geometryTable [ GEOMETRY_TABLE_WRITE_ENTRY ]  blockSize ) ; appData  numEraseBlocks =  ( SDMMC_DATA_SIZE / geometry - geometryTable [ GEOMETRY_TABLE_ERASE_ENTRY ]  blockSize ) ; appData  state = APP_STATE_WRITE_MEMORY ;  }  break ;  }  case APP_STATE_WRITE_MEMORY :  {  DRV_SDMMC_AsyncWrite ( appData  sdmmcHandle    appData  writeHandle   ( void  * ) writeBuffer  BLOCK_START  appData  numWriteBlocks ) ;  if  ( appData  writeHandle == DRV_SDMMC_COMMAND_HANDLE_INVALID )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_READ_MEMORY ;  }  break ;  }  case APP_STATE_READ_MEMORY :  {  if  ( appData  xfer_done == true )  {  /* Write to the SD Card is complete */ appData  xfer_done = false ;  memset ( ( void  * ) readBuffer   0  SDMMC_DATA_SIZE ) ;  DRV_SDMMC_AsyncRead ( appData  sdmmcHandle    appData  readHandle   ( void  * ) readBuffer  BLOCK_START  appData  numReadBlocks ) ;  if  ( appData  readHandle == DRV_SDMMC_COMMAND_HANDLE_INVALID )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_VERIFY_DATA ;  }  }  break ;  }  case APP_STATE_VERIFY_DATA :  {  /* Wait until all the above queued transfer requests are done */  if ( appData  xfer_done == true )  { appData  xfer_done = false ;  if  (  memcmp ( writeBuffer  readBuffer  SDMMC_DATA_SIZE ) )  { appData  state = APP_STATE_SUCCESS ;  }  else  { appData  state = APP_STATE_ERROR ;  }  }  break ;  }  case APP_STATE_SUCCESS :  {  DRV_SDMMC_Close ( appData  sdmmcHandle ) ;  LED_ON ( ) ;  break ;  }  case APP_STATE_ERROR :  default :  {  DRV_SDMMC_Close ( appData  sdmmcHandle ) ;  break ;  }  }  }  ",
							" Configuring The Library SDMMC Driver Library should be configured via MHC The following figures show the MHC configuration window for SDMMC driver and brief description Common User Configuration for all Instances Driver Mode: Allows User to select the mode of driver(Asynchronous or Synchronous) This setting is common for all the instances Only Asycnhronous mode is supported for now Instance Specific User Configurations Asynchronous Mode with SD protocol and File-System drv_sdmmc_mhc_config_async_with_sd_fs Asynchronous Mode with SD protocol RTOS and without File-System drv_sdmmc_mhc_config_async_with_sd_rtos Asynchronous Mode with eMMC protocol and File-System drv_sdmmc_mhc_config_async_with_emmc_fs PLIB Used: Specifies the peripheral library used by the SDMMC driver This can either be the HSMCI PLIB or the SDHC PLIB Number of Clients: Specifies number of clients that can access the specific instance of the driver Transfer Queue Size: Specifies maximum number of requests that can be queued This Configuration is displayed only in Asynchronous mode Data Transfer Bus Width: Specifies the Bus width to be used for data transfer (1-Bit 4-Bit) Bus Speed: Specifies Bus Speed to be used for Communication with SD-card (DEFAULT_SPEED HIGH_SPEED) Standard SD-Cards only support Default Speed SD-Cards with High Capacity support Both Default and High Speed Protocol: Specifies whether SD or eMMC protocol is enabled in the SDMMC driver Sleep when idle This option is available only when eMMC protocol is enabled Enabling this option puts the eMMC card in sleep mode when no data transfers are pending When a data transfer is requested the SDMMC driver brings the eMMC card out of sleep mode Refer to the eMMC datasheet for the switching time from standby to sleep and vice-versa Card Detection Method: Specifies the card detection method used by the SDMMC driver Either SDCD pin or Polling method can be used to detect insertion/removal of SD Card Polling Interval (ms): If the Card Detection Method is selected as \"Use Polling\" then this option specifies the rate at which the SDMMC driver checks for SD Card insertion/removal File system for SDMMC Driver Enabled: Indicates whether SDMMC driver will register its services with the file system or not This option is automatically checked when the file system is connected to the SDMMC driver RTOS Settings: This configuration is displayed only in asynchronous mode Stack Size (in bytes): Specifies the number of bytes to be allocated on the stack for the SDMMC driver task of the instance Task Priority: Specifies priority for the SDMMC driver task thread The value can vary based on RTOS used Use Task Delay When enabled the SDMMC driver task will be scheduled out voluntarily after every run based on the delay configured Task Delay: Specifies the duration the task has to go to sleep after every run Should be configured carefully based on the application need and number of task running along in the system RTOS Settings For MicriumOS-III RTOS Below additional options are visible in drivers instance RTOS settings when the MicriumOS-III is added into project graph rtos_settings_micrium_os_iii Maximum Message Queue Size: This argument specifies the maximum number of messages that the task can receive through internal message queue A MicriumOS-III task contains an optional internal message queue (if OS_CFG_TASK_Q_EN is set to DEF_ENABLED in os_cfg h) The user may specify that the task is unable to receive messages by setting this argument to 0 Task Time Quanta: The amount of time (in clock ticks) for the time quanta when Round Robin is enabled If you specify 0 then the default time quanta will be used which is the tick rate divided by 10 Task Specific Options: Contains task-specific options Each option consists of one bit The option is selected when the bit is set The current version of MicriumOS-III supports the following options: Stack checking is allowed for the task: Specifies whether stack checking is allowed for the task Stack needs to be cleared: Specifies whether the stack needs to be cleared Floating-point registers needs to be saved: Specifies whether floating-point registers are saved This option is only valid if the processor has floating-point hardware and the processor-specific code saves the floating-point registers TLS (Thread Local Storage) support needed for the task: If the caller doesn�t want or need TLS (Thread Local Storage) support for the task being created If you do not include this option TLS will be supported by default TLS support was added in V3 03 00 ",
							" Library Interface SDMMC driver library provides the following interfaces: Functions Name Description DRV_SDMMC_Initialize Initializes the SD Card driver DRV_SDMMC_Status Provides the current status of the SD Card driver module DRV_SDMMC_Tasks Maintains the driver's state machine DRV_SDMMC_Open Opens the specified SD Card driver instance and returns a handle to it DRV_SDMMC_Close Closes an opened-instance of the SD Card driver DRV_SDMMC_AsyncRead Reads blocks of data from the specified block address of the SD Card DRV_SDMMC_AsyncWrite Writes blocks of data starting at the specified address of the SD Card DRV_SDMMC_CommandStatus Gets the current status of the command DRV_SDMMC_GeometryGet Returns the geometry of the device DRV_SDMMC_EventHandlerSet Allows a client to identify an event handling function for the driver to call back when queued operation has completed DRV_SDMMC_IsAttached Returns the physical attach status of the SD Card DRV_SDMMC_IsWriteProtected Returns the write protect status of the SDMMC Data types and constants Name Type Description DRV_SDMMC_COMMAND_HANDLE Typedef Handle identifying commands queued in the driver DRV_SDMMC_COMMAND_HANDLE_INVALID Macro SDMMC Driver's Invalid Command Handle DRV_SDMMC_COMMAND_STATUS Enum Identifies the possible events that can result from a request DRV_SDMMC_EVENT Enum Identifies the possible events that can result from a request DRV_SDMMC_EVENT_HANDLER Typedef Pointer to a SDMMCDriver Event handler function ",
							" DRV_SDMMC_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_SDMMC_Initialize (  const SYS_MODULE_INDEX index   const SYS_MODULE_INIT *  const init ) ; ",
							" Summary Initializes the SD Card driver ",
							" Description This routine initializes the SD Card driver making it ready for clients to open and use the driver ",
							" Precondition None ",
							" Parameters Param Description drvIndex Index for the driver instance to be initialized init Pointer to a data structure containing any data necessary to initialize the driver This pointer may be null if no data is required because static overrides have been provided ",
							" Returns If successful returns a valid handle to a driver object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example DRV_SDMMC_INIT init ; SYS_MODULE_OBJ objectHandle ;  // Populate the SD Card initialization structure objectHandle =  DRV_SDMMC_Initialize ( DRV_SDMMC_INDEX_0   ( SYS_MODULE_INIT * )  init ) ;  if  ( objectHandle == SYS_MODULE_OBJ_INVALID )  {  // Handle error  } ",
							" Remarks This routine must be called before any other SD Card routine is called This routine should only be called once during system initialization This routine will NEVER block for hardware access The system must use DRV_SDMMC_Status to find out when the driver is in the ready state ",
							" DRV_SDMMC_Status Function ",
							" C SYS_STATUS DRV_SDMMC_Status ( SYS_MODULE_OBJ object ) ; ",
							" Summary Provides the current status of the SD Card driver module ",
							" Description This routine provides the current status of the SD Card driver module ",
							" Precondition Function DRV_SDMMC_Initialize must have been called before calling this function ",
							" Parameters Param Description object Driver object handle returned from the DRV_SDMMC_Initialize routine ",
							" Returns SYS_STATUS_READY - Indicates that the driver is busy with a previous system level operation and cannot start another Note Any value greater than SYS_STATUS_READY is also a normal running state in which the driver is ready to accept new operations SYS_STATUS_UNINITIALIZED - Driver is not initialized ",
							" Example SYS_MODULE_OBJ object ;  // Returned from DRV_SDMMC_Initialize SYS_STATUS status ; status =  DRV_SDMMC_Status ( object ) ;  if  ( status == SYS_STATUS_READY )  {  // Driver is initialized and ready to accept requests  } ",
							" Remarks None ",
							" DRV_SDMMC_Tasks Function ",
							" C void DRV_SDMMC_Tasks ( SYS_MODULE_OBJ object ) ; ",
							" Summary Maintains the driver's state machine ",
							" Description This routine is used to maintain the driver's internal state machine ",
							" Precondition The DRV_SDMMC_Initialize routine must have been called for the specified SDMMC driver instance ",
							" Parameters Param Description object Object handle for the specified driver instance (returned from DRV_SDMMC_Initialize) ",
							" Returns None ",
							" Example SYS_MODULE_OBJ object ;  // Returned from DRV_SDMMC_Initialize  while  ( true )  { DRV_SDMMC_Tasks ( object ) ;  // Do other tasks  } ",
							" Remarks This routine is normally not called directly by an application It is called by the system's Tasks routine (SYS_Tasks) ",
							" DRV_SDMMC_Open Function ",
							" C DRV_HANDLE DRV_SDMMC_Open (  const SYS_MODULE_INDEX drvIndex   const DRV_IO_INTENT intent ) ; ",
							" Summary Opens the specified SD Card driver instance and returns a handle to it ",
							" Description This routine opens the specified SDMMC driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver ",
							" Precondition Function DRV_SDMMC_Initialize must have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the object instance to be opened intent Zero or more of the values from the enumeration DRV_IO_INTENT \"ORed\" together to indicate the intended use of the driver ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) If an error occurs the return value is DRV_HANDLE_INVALID ",
							" Example DRV_HANDLE handle ; handle = DRV_SDMMC_Open ( DRV_SDMMC_INDEX_0  DRV_IO_INTENT_EXCLUSIVE ) ;  if  ( handle == DRV_HANDLE_INVALID )  {  // Unable to open the driver  } ",
							" Remarks The handle returned is valid until the DRV_SDMMC_Close routine is called ",
							" DRV_SDMMC_Close Function ",
							" C void DRV_SDMMC_Close ( DRV_HANDLE handle ) ; ",
							" Summary Closes an opened-instance of the SD Card driver ",
							" Description This routine closes an opened-instance of the SD Card driver invalidating the handle ",
							" Precondition The DRV_SDMMC_Initialize routine must have been called for the specified SD Card driver instance DRV_SDMMC_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns None ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_SDMMC_Open DRV_SDMMC_Close ( handle ) ; ",
							" Remarks After calling this routine the handle passed in \"handle\" must not be used with any of the remaining driver routines A new handle must be obtained by calling DRV_SDMMC_Open before the caller may use the driver again If any requests were queued by the client the driver will remove those requests from the queue and issue a DRV_SDMMC_EVENT_COMMAND_ERROR event (if an event handler is registered by the client) before the client is closed ",
							" DRV_SDMMC_AsyncRead Function ",
							" C void DRV_SDMMC_AsyncRead (  const DRV_HANDLE handle  DRV_SDMMC_COMMAND_HANDLE * commandHandle   void * targetBuffer  uint32_t blockStart  uint32_t nBlock ) ; ",
							" Summary Reads blocks of data from the specified block address of the SD Card ",
							" Description This function schedules a non-blocking read operation for reading blocks of data from the SD Card The function returns with a valid buffer handle in the commandHandle argument if the read request was scheduled successfully The function adds the request to the hardware instance queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified The function returns DRV_SDMMC_COMMAND_HANDLE_INVALID in the commandHandle argument under the following circumstances: if the driver handle is invalid if the target buffer pointer is NULL if the number of blocks to be read is zero or more than the actual number of blocks available if a buffer object could not be allocated to the request If the requesting client registered an event callback with the driver the driver will issue a DRV_SDMMC_EVENT_COMMAND_COMPLETE event if the buffer was processed successfully or DRV_SDMMC_EVENT_COMMAND_ERROR event if the buffer was not processed successfully ",
							" Precondition The DRV_SDMMC_Initialize routine must have been called for the specified SDMMC driver instance DRV_SDMMC_Open must have been called and a valid handle must have been obtained ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return buffer handle targetBuffer Buffer into which the data read from the SD Card will be placed blockStart Start block address of the SD Card from where the read should begin nBlock Total number of blocks to be read ",
							" Returns The buffer handle is returned in the commandHandle argument It will be DRV_SDMMC_COMMAND_HANDLE_INVALID if the request was not successful ",
							" Example uint8_t CACHE_ALIGN myBuffer [ MY_BUFFER_SIZE ] ;  // address should be block aligned uint32_t blockStart =  0x00 ; uint32_t nBlock =  2 ; DRV_SDMMC_COMMAND_HANDLE commandHandle ; MY_APP_OBJ myAppObj ;  // mySDMMCHandle is the handle returned  // by the DRV_SDMMC_Open function  DRV_SDMMC_AsyncRead ( mySDMMCHandle    commandHandle    myBuffer [ 0 ]  blockStart  nBlock ) ;  if ( commandHandle == DRV_SDMMC_COMMAND_HANDLE_INVALID )  {  // Error handling here  }  else  {  // Read Successfully queued  }  ",
							" Remarks None ",
							" DRV_SDMMC_AsyncWrite Function ",
							" C void DRV_SDMMC_AsyncWrite (  const DRV_HANDLE handle  DRV_SDMMC_COMMAND_HANDLE * commandHandle   void * sourceBuffer  uint32_t blockStart  uint32_t nBlock ) ; ",
							" Summary Writes blocks of data starting at the specified address of the SD Card ",
							" Description This function schedules a non-blocking write operation for writing blocks of data to the SD Card The function returns with a valid buffer handle in the commandHandle argument if the write request was scheduled successfully The function adds the request to the hardware instance queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified The function returns DRV_SDMMC_COMMAND_HANDLE_INVALID in the commandHandle argument under the following circumstances: if the driver handle is invalid if the source buffer pointer is NULL if the number of blocks to write is zero or more than the actual number of blocks available if a buffer object could not be allocated to the request If the requesting client registered an event callback with the driver the driver will issue a DRV_SDMMC_EVENT_COMMAND_COMPLETE event if the buffer was processed successfully or DRV_SDMMC_EVENT_COMMAND_ERROR event if the buffer was not processed successfully ",
							" Precondition The DRV_SDMMC_Initialize routine must have been called for the specified SDMMC driver instance DRV_SDMMC_Open routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return buffer handle sourceBuffer The source buffer containing data to be programmed to the SD Card blockStart Start block address of SD Card where the writes should begin nBlock Total number of blocks to be written ",
							" Returns The buffer handle is returned in the commandHandle argument It will be DRV_SDMMC_COMMAND_HANDLE_INVALID if the request was not successful ",
							" Example uint8_t CACHE_ALIGN myBuffer [ MY_BUFFER_SIZE ] ;  // address should be block aligned uint32_t blockStart =  0x00 ; uint32_t nBlock =  2 ; DRV_SDMMC_COMMAND_HANDLE commandHandle ; MY_APP_OBJ myAppObj ;  // Event is received when the buffer is processed  void  APP_SDMMCEventHandler ( DRV_SDMMC_EVENT event  DRV_SDMMC_COMMAND_HANDLE commandHandle  uintptr_t contextHandle )  {  // contextHandle points to myAppObj  switch ( event )  {  case DRV_SDMMC_EVENT_COMMAND_COMPLETE :  {  // This means the data was transferred successfully  break ;  }  case DRV_SDMMC_EVENT_COMMAND_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  }  // mySDMMCHandle is the handle returned  // by the DRV_SDMMC_Open function  // Client registers an event handler with driver  DRV_SDMMC_EventHandlerSet ( mySDMMCHandle  APP_SDMMCEventHandler   ( uintptr_t )  myAppObj ) ;  DRV_SDMMC_AsyncWrite ( mySDMMCHandle    commandHandle    myBuffer [ 0 ]  blockStart  nBlock ) ;  if ( commandHandle == DRV_SDMMC_COMMAND_HANDLE_INVALID )  {  // Error handling here  }  ",
							" Remarks None ",
							" DRV_SDMMC_CommandStatus Function ",
							" C DRV_SDMMC_COMMAND_STATUS DRV_SDMMC_CommandStatus (  const DRV_HANDLE handle   const DRV_SDMMC_COMMAND_HANDLE commandHandle ) ; ",
							" Summary Gets the current status of the command ",
							" Description This routine gets the current status of the command The application must use this routine where the status of a scheduled command needs to be polled on The function may return DRV_SDMMC_COMMAND_ERROR_UNKNOWN in a case where the command handle has expired A command handle expires when the internal buffer object is re-assigned to another read or write request It is recommended that this function be called regularly in order to track the command status correctly The application can alternatively register an event handler to receive read or write operation completion events ",
							" Preconditions The DRV_SDMMC_Initialize routine must have been called The DRV_SDMMC_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns A DRV_SDMMC_COMMAND_STATUS value describing the current status of the command Returns DRV_SDMMC_COMMAND_ERROR_UNKNOWN if the client handle or the command handle is not valid ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_SDMMC_Open DRV_SDMMC_COMMAND_HANDLE commandHandle ; DRV_SDMMC_COMMAND_STATUS status ; status =  DRV_SDMMC_CommandStatus ( handle  commandHandle ) ;  if ( status == DRV_SDMMC_COMMAND_COMPLETED )  {  // Operation Done  } ",
							" Remarks This routine will not block for hardware access and will immediately return the current status ",
							" DRV_SDMMC_GeometryGet Function ",
							" C SYS_MEDIA_GEOMETRY * DRV_SDMMC_GeometryGet (  const DRV_HANDLE handle ) ; ",
							" Summary Returns the geometry of the device ",
							" Description This API gives the following geometrical details of the SD Card Media Property Number of Read/Write/Erase regions in the SD Card Number of Blocks and their size in each region of the device ",
							" Precondition The DRV_SDMMC_Initialize routine must have been called for the specified SDMMC driver instance The DRV_SDMMC_Open routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function ",
							" Returns SYS_MEDIA_GEOMETRY - Pointer to structure which holds the media geometry information ",
							" Example SYS_MEDIA_GEOMETRY * SDMMCGeometry ; uint32_t readBlockSize  writeBlockSize  eraseBlockSize ; uint32_t nReadBlocks  nReadRegions  totalSize ; SDMMCGeometry =  DRV_SDMMC_GeometryGet ( SDMMCOpenHandle1 ) ; readBlockSize = SDMMCGeometry - geometryTable - blockSize ; nReadBlocks = SDMMCGeometry - geometryTable - numBlocks ; nReadRegions = SDMMCGeometry - numReadRegions ; writeBlockSize =  ( SDMMCGeometry - geometryTable + 1 ) - blockSize ; eraseBlockSize =  ( SDMMCGeometry - geometryTable + 2 ) - blockSize ; totalSize = readBlockSize * nReadBlocks * nReadRegions ;  ",
							" Remarks Refer sys_media h for definition of SYS_MEDIA_GEOMETRY ",
							" DRV_SDMMC_EventHandlerSet Function ",
							" C void DRV_SDMMC_EventHandlerSet (  const DRV_HANDLE handle   const  void * eventHandler   const uintptr_t context ) ; ",
							" Summary Allows a client to identify an event handling function for the driver to call back when queued operation has completed ",
							" Description This function allows a client to identify an event handling function for the driver to call back when queued operation has completed When a client queues a request for a read or a write operation it is provided with a handle identifying the buffer that was added to the driver's buffer queue The driver will pass this handle back to the client by calling \"eventHandler\" function when the queued operation has completed The event handler should be set before the client performs any read or write operations that could generate events The event handler once set persists until the client closes the driver or sets another event handler (which could be a \"NULL\" pointer to indicate no callback) ",
							" Precondition The DRV_SDMMC_Initialize routine must have been called for the specified SDMMC driver instance The DRV_SDMMC_Open routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function eventHandler Pointer to the event handler function implemented by the user context The value of parameter will be passed back to the client unchanged when the eventHandler function is called It can be used to identify any client specific data object that identifies the instance of the client module (for example it may be a pointer to the client module's state structure) ",
							" Returns None ",
							" Example // myAppObj is an application specific state data object MY_APP_OBJ myAppObj ; uint8_t CACHE_ALIGN myBuffer [ MY_BUFFER_SIZE ] ; uint32_t blockStart  nBlock ; DRV_SDMMC_COMMAND_HANDLE commandHandle ;  // Event Processing Technique Event is received when operation is done  void  APP_SDMMCEventHandler ( DRV_SDMMC_EVENT event  DRV_SDMMC_COMMAND_HANDLE handle  uintptr_t context )  {  // The context handle was set to an application specific  // object It is now retrievable easily in the event handler MY_APP_OBJ myAppObj =  ( MY_APP_OBJ *  ) context ;  switch ( event )  {  case DRV_SDMMC_EVENT_COMMAND_COMPLETE :  {  // This means the data was transferred successfully  break ;  }  case DRV_SDMMC_EVENT_COMMAND_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  }  // drvSDMMCHandle is the handle returned  // by the DRV_SDMMC_Open function  // Client registers an event handler with driver This is done once  DRV_SDMMC_EventHandlerSet ( drvSDMMCHandle  APP_SDMMCEventHandler   ( uintptr_t )  myAppObj ) ;  DRV_SDMMC_AsyncRead ( drvSDMMCHandle    commandHandle    myBuffer [ 0 ]  blockStart  nBlock ) ;  if ( commandHandle == DRV_SDMMC_COMMAND_HANDLE_INVALID )  {  // Error handling here  }  ",
							" Remarks If the client does not want to be notified when the queued operation has completed it does not need to register a callback ",
							" DRV_SDMMC_IsAttached Function ",
							" C bool DRV_SDMMC_IsAttached (  const DRV_HANDLE handle ) ; ",
							" Summary Returns the physical attach status of the SD Card ",
							" Description This function returns the physical attach status of the SD Card ",
							" Precondition The DRV_SDMMC_Initialize routine must have been called for the specified SDMMC driver instance The DRV_SDMMC_Open routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function ",
							" Returns Returns false if the handle is invalid otherwise returns the attach status of the SD Card Returns true if the SD Card is attached and initialized by the SDMMC driver otherwise returns false ",
							" Example // drvSDMMCHandle is the handle returned  // by the DRV_SDMMC_Open function bool isSDMMCAttached ; isSDMMCAttached =  DRV_SDMMC_isAttached ( drvSDMMCHandle ) ;  ",
							" Remarks None ",
							" DRV_SDMMC_IsWriteProtected Function ",
							" C bool DRV_SDMMC_IsWriteProtected (  const DRV_HANDLE handle ) ; ",
							" Summary Returns the write protect status of the SDMMC ",
							" Description This function returns the physical write status of the SDMMC This function returns true if the SD Card is write protected otherwise it returns false ",
							" Precondition The DRV_SDMMC_Initialize routine must have been called for the specified SDMMC driver instance The DRV_SDMMC_Open routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function ",
							" Returns Returns true if the attached SD Card is write protected Returns false if the handle is not valid or if the SD Card is not write protected or if the write protection check is not enabled ",
							" Example bool isWriteProtected ; isWriteProtected =  DRV_SDMMC_IsWriteProtected ( drvSDMMCHandle ) ;  ",
							" Remarks None ",
							" DRV_SDMMC_COMMAND_HANDLE Typedef ",
							" C typedef SYS_MEDIA_BLOCK_COMMAND_HANDLE DRV_SDMMC_COMMAND_HANDLE ;  ",
							" Summary Handle identifying commands queued in the driver ",
							" Description A command handle is returned by a call to the Read or Write functions This handle allows the application to track the completion of the operation This command handle is also returned to the client along with the event that has occurred with respect to the command This allows the application to connect the event to a specific command in case where multiple commands are queued The command handle associated with the command request expires when the client has been notified of the completion of the command (after event handler function that notifies the client returns) or after the command has been retired by the driver if no event handler callback was set ",
							" Remarks Refer sys_media h for definition of SYS_MEDIA_BLOCK_COMMAND_HANDLE ",
							" DRV_SDMMC_COMMAND_HANDLE_INVALID Macro ",
							" C # define DRV_SDMMC_COMMAND_HANDLE_INVALID SYS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID  ",
							" Summary SDMMC Driver's Invalid Command Handle ",
							" Description This value defines the SDMMC Driver Invalid Command Handle This value is returned by read or write routines when the command request was not accepted ",
							" Remarks Refer sys_media h for definition of SYS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID ",
							" DRV_SDMMC_COMMAND_STATUS Enum ",
							" C typedef  enum  {  /* Done OK and ready */ DRV_SDMMC_COMMAND_COMPLETED = SYS_MEDIA_COMMAND_COMPLETED   /* Scheduled but not started */ DRV_SDMMC_COMMAND_QUEUED = SYS_MEDIA_COMMAND_QUEUED   /* Currently being in transfer */ DRV_SDMMC_COMMAND_IN_PROGRESS = SYS_MEDIA_COMMAND_IN_PROGRESS   /* Unknown Command */ DRV_SDMMC_COMMAND_ERROR_UNKNOWN = SYS_MEDIA_COMMAND_UNKNOWN   } DRV_SDMMC_COMMAND_STATUS ;  ",
							" Summary Identifies the possible events that can result from a request ",
							" Description This enumeration identifies the possible status values of a read or write buffer request submitted to the driver One of these values is returned by the DRV_SDMMC_CommandStatus routine ",
							" Remarks Refer sys_media h for SYS_MEDIA_XXX definitions ",
							" DRV_SDMMC_EVENT Enum ",
							" C typedef  enum  {  /* Operation has been completed successfully */ DRV_SDMMC_EVENT_COMMAND_COMPLETE = SYS_MEDIA_EVENT_BLOCK_COMMAND_COMPLETE   /* There was an error during the operation */ DRV_SDMMC_EVENT_COMMAND_ERROR = SYS_MEDIA_EVENT_BLOCK_COMMAND_ERROR } DRV_SDMMC_EVENT ;  ",
							" Summary Identifies the possible events that can result from a request ",
							" Description This enumeration identifies the possible events that can result from a read or a write request issued by the client One of these values is passed in the \"event\" parameter of the event handling callback function that client registered with the driver by calling the DRV_SDMMC_EventHandlerSet function when a request is completed ",
							" Remarks Refer sys_media h for SYS_MEDIA_XXX definitions ",
							" DRV_SDMMC_EVENT_HANDLER Typedef ",
							" C typedef SYS_MEDIA_EVENT_HANDLER DRV_SDMMC_EVENT_HANDLER ;  ",
							" Summary Pointer to a SDMMCDriver Event handler function ",
							" Description This data type defines the required function signature for the SDMMC event handling callback function A client must register a pointer to an event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive event calls back from the driver If the event is DRV_SDMMC_EVENT_COMMAND_COMPLETE it means that the write or a read operation was completed successfully If the event is DRV_SDMMC_EVENT_COMMAND_ERROR it means that the operation was not completed successfully The context parameter contains the handle to the client context provided at the time the event handling function was registered using the DRV_SDMMC_EventHandlerSet function This context handle value is passed back to the client as the \"context\" parameter It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the read/write request ",
							" Parameters Param Description event Identifies the type of event commandHandle Handle returned from the Read/Write requests context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Example void APP_MySDMMCEventHandler ( DRV_SDMMC_EVENT event  DRV_SDMMC_COMMAND_HANDLE commandHandle  uintptr_t context )  { MY_APP_DATA_STRUCT * pAppData =  ( MY_APP_DATA_STRUCT *  ) context ;  switch ( event )  {  case DRV_SDMMC_EVENT_COMMAND_COMPLETE :  {  // Handle the completed buffer  break ;  }  case DRV_SDMMC_EVENT_COMMAND_ERROR :  default :  {  // Handle error  break ;  }  }  } ",
							" Remarks Refer sys_media h for definition of SYS_MEDIA_EVENT_HANDLER ",
							" SDSPI Driver The SDSPI driver is a multi-client multi-instance buffer model based block driver interface which can be used to communicate with SD cards Key Features of Memory Driver: Supports asynchronous (non-blocking) and synchronous (blocking) mode of operation Supports both DMA and non-DMA modes The SDSPI driver is capable of interacting to the SD Card either via SPI PLIB interface or via SPI Driver interface selectable in MHC configuration of the SDSPI driver The driver API interface can be used directly by the application to read/write directly from the SD Card Or the SDSPI driver can be used with a file system ",
							" How the Library Works The SDSPI driver library is a multi-client multi-instance buffer queue model based block driver interface Abstraction Model The SDSPI driver provides abstraction to communicate with SD card through the SPI peripheral library or SPI driver interface drv_sdspi_abstraction_model SDSPI Driver Features: The SDSPI driver is built on top of SPI peripheral library or SPI driver The SDSPI driver Library registers an event handler with the underlying SPI peripheral library or the SPI Driver instance This event handler is called by the SPI PLIB or the SPI driver from the interrupt context to notify the SDSPI driver that the requested transfer is complete When DMA is enabled and SPI PLIB is used the SDSPI Driver registers an event handler with the DMA peripheral library This event handler is called by by the DMA PLIB from the interrupt context once the DMA transfer is complete When using SPI driver the DMA operations are handled internally by the SPI driver In this case the SDSPI registers a callback with the SPI driver which in turn registers a callback with the DMA peripheral library The SD Card driver state machine checks for SD Card attach/detach status using command-response mechanism Once a SD Card is detected The state machine initializes the SD Card making it ready for the client to submit read/write requests After the SD Card is initialized the state machine periodically checks if the SD Card is still connected using command/response mechanism The rate at which the SD card driver checks for the SD Card attach/detach event can be specified via an MHC configuration option In case RTOS is enabled the RTOS Task Delay value for the SDSPI Driver task also affects the rate at which the SD Card attach/detach is checked SDSPI driver is capable of working in both Asynchronous and Synchronous modes SDSPI driver in Asynchronous mode Asynchronous mode APIs are non-blocking in nature These APIs submit a request and return back to the application Typically if there are no on-going or pending requests in the driver's transfer queue then the transfer is started by the API and completed from the peripheral interrupt If there is an on-going transfer or one or more requests pending in the driver's transfer queue then the request is added to the queue and executed when all the pending requests are complete The size of the transfer queue is configurable using MCC based on application needs The SD card driver state machine checks the driver transfer queue and executes any pending requests The transfer APIs provide a transfer handle back to the application If the driver was unable to accept the request then the transfer handle will be set to NULL This usually happens if the transfer queue is full or if invalid argruments are passed to the API Application must check the value of the transfer handle to ensure the request was accepted successfully Transfer handle can be used to identify/track the request Application can either register a callback to get notified when the transfer is complete or poll the status of the request by calling the DRV_SDSPI_CommandStatusGet() API Asynchronous mode APIs are available in both bare-metal and RTOS mode SDSPI driver in Synchronous mode Synchronous mode APIs are blocking in nature These APIs block until the transfer/request is complete Synchronous mode APIs are only supported in RTOS mode These APIs initate the transfer and then block on a semaphore while the transfer is in progress thereby allowing other ready tasks to run Once the transfer is complete the semaphore is given (from the peripheral interrupt's context) thereby unblocking the calling task The return value usually provides the status of the transfer ",
							" Using The Library The SDSPI driver builds on top of the SPI PLIB or SPI Driver and provides direct access to the SD Card It also confirms to the media block layer interface which allows it to register its services with the file system's media block driver interface Modes supported: Asynchronous mode : Supported in both Bare-metal and RTOS environment Synchronous mode : Supported in RTOS environment Usage Methods Application can directly use the SDSPI driver API's to perform Read/Write operations Application can use File System service layer and perform file operations on the SD/eMMC Card It can be interfaced with Middleware's like USB Example application to Write and Read SD Card in Synchronous mode /* Write and Read 60KB of Data */  # define SDSPI_DATA_SIZE (10240U)  # define SDSPI_BUFFER_SIZE (SDSPI_DATA_SIZE / sizeof(uint32_t))  # define GEOMETRY_TABLE_READ_ENTRY (0)  # define GEOMETRY_TABLE_WRITE_ENTRY (1)  # define GEOMETRY_TABLE_ERASE_ENTRY (2)  # define BLOCK_START 0x2000 SYS_MEDIA_GEOMETRY * geometry =  NULL ; APP_DATA appData ;  /* Read Buffer */  static CACHE_ALIGN uint32_t readBuffer [ SDSPI_BUFFER_SIZE ] ;  /* Write Buffer*/  static CACHE_ALIGN uint32_t writeBuffer [ SDSPI_BUFFER_SIZE ] ;  void APP_Initialize (  void  )  { uint32_t i =  0 ;  /* Place the App state machine in its initial state */ appData  state = APP_STATE_OPEN_DRIVER ;  for  ( i =  0 ; i  SDSPI_BUFFER_SIZE ; i ++ )  { writeBuffer [ i ]  = i ;  }  }  void APP_Tasks (  void  )  {  /* Check the application's current state */  switch  ( appData  state )  {  case APP_STATE_OPEN_DRIVER :  { appData  sdspiHandle =  DRV_SDSPI_Open ( DRV_SDSPI_INDEX_0  DRV_IO_INTENT_READWRITE ) ;  if  ( appData  sdspiHandle = DRV_HANDLE_INVALID )  { appData  state = APP_STATE_WAIT_FOR_SDCARD_ATTACH ;  }  break ;  }  case APP_STATE_WAIT_FOR_SDCARD_ATTACH :  {  if  ( DRV_SDSPI_IsAttached ( appData  sdspiHandle )  == true )  { appData  state = APP_STATE_GEOMETRY_GET ;  }  break ;  }  case APP_STATE_GEOMETRY_GET :  { geometry =  DRV_SDSPI_GeometryGet ( appData  sdspiHandle ) ;  if  ( geometry =  NULL )  { appData  numReadBlocks =  ( SDSPI_DATA_SIZE / geometry - geometryTable [ GEOMETRY_TABLE_READ_ENTRY ]  blockSize ) ; appData  numWriteBlocks =  ( SDSPI_DATA_SIZE / geometry - geometryTable [ GEOMETRY_TABLE_WRITE_ENTRY ]  blockSize ) ; appData  numEraseBlocks =  ( SDSPI_DATA_SIZE / geometry - geometryTable [ GEOMETRY_TABLE_ERASE_ENTRY ]  blockSize ) ; appData  state = APP_STATE_WRITE_MEMORY ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WRITE_MEMORY :  {  if  ( DRV_SDSPI_SyncWrite ( appData  sdspiHandle   ( void  * ) writeBuffer  BLOCK_START  appData  numWriteBlocks )  == true )  { appData  state = APP_STATE_READ_MEMORY ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_READ_MEMORY :  {  memset ( ( void  * ) readBuffer   0  SDSPI_DATA_SIZE ) ;  if  ( DRV_SDSPI_SyncRead ( appData  sdspiHandle   ( void  * ) readBuffer  BLOCK_START  appData  numReadBlocks )  == true )  { appData  state = APP_STATE_VERIFY_DATA ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_VERIFY_DATA :  {  if  (  memcmp ( writeBuffer  readBuffer  SDSPI_DATA_SIZE ) )  { appData  state = APP_STATE_SUCCESS ;  }  else  { appData  state = APP_STATE_ERROR ;  }  DRV_SDSPI_Close ( appData  sdspiHandle ) ;  break ;  }  case APP_STATE_SUCCESS :  {  LED_ON ( ) ;  break ;  }  case APP_STATE_ERROR :  default :  {  LED_OFF ( ) ;  break ;  }  }  } ",
							" Configuring The Library SDSPI Driver Library should be configured via MHC The following figures show the MHC configuration window for SDSPI driver and brief description Common User Configuration for all Instances Driver Mode: Allows User to select the mode of driver(Asynchronous or Synchronous) This setting is common for all the instances When the SDSPI driver is used with SPI driver the SPI driver inherits the driver mode from the SDSPI driver That is if the SDSPI driver is configured for Asynchronous mode then the SPI driver is automatically configured for Asynchronous mode and vice-versa Instance Specific User Configurations Asynchronous Mode with SPI PLIB and File-System drv_sdspi_mhc_config_async_with_spi_fs Asynchronous Mode with SPI Driver and File-System drv_sdspi_mhc_config_async_with_spiDriver_fs Synchronous Mode with SPI PLIB RTOS and File-System drv_sdspi_mhc_config_sync_with_spi_rtos_fs Synchronous Mode with SPI Driver RTOS and File-System drv_sdspi_mhc_config_sync_with_spiDriver_rtos_fs PLIB Used: This option is displayed only when SDSPI driver is connected to SPI PLIB Indicates the SPI peripheral instance used by the SDSPI driver SPI Driver Instance Used: This option is displayed only when SDSPI driver is connected to SPI Driver Indicates the SPI driver instance used by the SDSPI driver Number of Clients: Specifies number of clients that can access the specific instance of the driver SD Card Speed (Hz): The maximum SPI speed at which the SDSPI driver interacts with the SD Card SDSPI driver overrides the SPI PLIB clock speed settings Transfer Queue Size: Specifies maximum number of requests that can be queued This Configuration is displayed only in Asynchronous mode Card Detection Method: Card detection method used For SDSPI driver command-response based polling method is used for card insertion/removal Polling Interval (ms): Rate at which the SDSPI driver checks for card insertion and removal File system for SDSPI Driver Enabled: Indicates whether SDSPI driver will register its services with the file system or not This option is automatically checked when the file system is connected to the SDSPI driver Chip Select Pin: The SD Card chip select pin Use Write Protect Pin (Active High) Enable write protection check Write Protect Pin (Active High): The selected write protect pin must be configured as GPIO input under the Pin Settings window Use DMA for Transmit and Receive : Enable/disable DMA usage by the SDSPI driver This option is available only when SDSPI driver is used with SPI PLIB When SDSPI is used with SPI driver the DMA must be configured in the SPI driver configuration DMA Channel For Transmit: Indicates the DMA channel the SDSPI driver will use for transmission DMA Channel For Receive: Indicates the DMA channel the SDSPI driver will use for reception RTOS Settings: Stack Size (in bytes): Specifies the number of bytes to be allocated on the stack for the SDSPI driver task of the instance Task Priority: Specifies priority for the SDSPI driver task thread The value can vary based on RTOS used Use Task Delay When enabled the SDSPI driver task will be scheduled out voluntarily after every run based on the delay configured Task Delay (ms): Indicates the amount of time for which the SDSPI RTOS thread is put in blocked state by the scheduler before it is run again This inturn controls the rate at which the SDSPI driver checks for the SD Card attach/detach status RTOS Settings For MicriumOS-III RTOS Below additional options are visible in drivers instance RTOS settings when the MicriumOS-III is added into project graph rtos_settings_micrium_os_iii Maximum Message Queue Size: This argument specifies the maximum number of messages that the task can receive through internal message queue A MicriumOS-III task contains an optional internal message queue (if OS_CFG_TASK_Q_EN is set to DEF_ENABLED in os_cfg h) The user may specify that the task is unable to receive messages by setting this argument to 0 Task Time Quanta: The amount of time (in clock ticks) for the time quanta when Round Robin is enabled If you specify 0 then the default time quanta will be used which is the tick rate divided by 10 Task Specific Options: Contains task-specific options Each option consists of one bit The option is selected when the bit is set The current version of MicriumOS-III supports the following options: Stack checking is allowed for the task: Specifies whether stack checking is allowed for the task Stack needs to be cleared: Specifies whether the stack needs to be cleared Floating-point registers needs to be saved: Specifies whether floating-point registers are saved This option is only valid if the processor has floating-point hardware and the processor-specific code saves the floating-point registers TLS (Thread Local Storage) support needed for the task: If the caller doesn�t want or need TLS (Thread Local Storage) support for the task being created If you do not include this option TLS will be supported by default TLS support was added in V3 03 00 ",
							" Library Interface SDSPI driver library provides the following interfaces: Functions Name Description DRV_SDSPI_Initialize Initializes the SD Card driver DRV_SDSPI_Status Provides the current status of the SDSPI driver module DRV_SDSPI_Open Opens the specified SD Card driver instance and returns a handle to it DRV_SDSPI_Close Closes an opened-instance of the SD Card driver DRV_SDSPI_Tasks Maintains the driver's state machine DRV_SDSPI_SyncRead Reads blocks of data from the specified block address of the SD Card DRV_SDSPI_AsyncRead Reads blocks of data from the specified block address of the SD Card DRV_SDSPI_SyncWrite Writes blocks of data starting at the specified address of the SD Card DRV_SDSPI_AsyncWrite Writes blocks of data starting at the specified address of the SD Card DRV_SDSPI_IsAttached Returns the physical attach status of the SD Card DRV_SDSPI_IsWriteProtected Returns the write protect status of the SD Card DRV_SDSPI_GeometryGet Returns the geometry of the device DRV_SDSPI_EventHandlerSet Allows a client to identify an event handling function for the driver to call back when queued operation has completed For the synchronous SDSPI driver the event handler is only used by the file system DRV_SDSPI_CommandStatusGet Gets the current status of the command For synchronous mode the command status is only used by the file system DRV_SDSPI_Read This routine provides interface to the file system to perform a media read operation in synchronous mode of the SDSPI driver DRV_SDSPI_Write This routine provides interface to the file system to perform a media write operation in synchronous mode of the SDSPI driver Data types and constants Name Type Description DRV_SDSPI_EVENT Enum Identifies the possible events that can result from a request DRV_SDSPI_COMMAND_STATUS Enum Identifies the possible events that can result from a request DRV_SDSPI_COMMAND_HANDLE Typedef Handle identifying commands queued in the driver DRV_SDSPI_COMMAND_HANDLE_INVALID Macro SDSPI Driver's Invalid Command Handle DRV_SDSPI_EVENT_HANDLER Typedef Pointer to a SDSPI Driver Event handler function ",
							" DRV_SDSPI_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_SDSPI_Initialize (  const SYS_MODULE_INDEX drvIndex   const SYS_MODULE_INIT *  const init ) ",
							" Summary Initializes the SD Card driver ",
							" Description This routine initializes the SD Card driver making it ready for clients to open and use the driver ",
							" Precondition None ",
							" Parameters Param Description drvIndex Index for the driver instance to be initialized init Pointer to a data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example DRV_SDSPI_INIT drvSDSPI0InitData ; SYS_MODULE_OBJ objectHandle ; DRV_SDSPI_PLIB_INTERFACE drvSDSPI0PlibAPI =  {  // SPI PLIB WriteRead function   writeRead =  ( DRV_SDSPI_WRITEREAD ) SPI0_WriteRead   // SPI PLIB Write function   write =  ( DRV_SDSPI_WRITE ) SPI0_Write   // SPI PLIB Read function   read =  ( DRV_SDSPI_READ ) SPI0_Read   // SPI PLIB Transfer Status function   isBusy =  ( DRV_SDSPI_IS_BUSY ) SPI0_IsBusy   // SPI PLIB Transfer Setup function   transferSetup =  ( DRV_SDSPI_SETUP ) SPI0_TransferSetup   // SPI PLIB Callback Register   callbackRegister =  ( DRV_SDSPI_CALLBACK_REGISTER ) SPI0_CallbackRegister   } ; DRV_SDSPI_INIT drvSDSPI0InitData =  {  // SD Card SPI PLIB API interface   spiPlib =   drvSDSPI0PlibAPI    remapDataBits = drvSDSPI0remapDataBits    remapClockPolarity = drvSDSPI0remapClockPolarity    remapClockPhase = drvSDSPI0remapClockPhase   // SDSPI Number of clients   numClients = DRV_SDSPI_CLIENTS_NUMBER_IDX0   // SDSPI Client Objects Pool   clientObjPool =  ( uintptr_t )  drvSDSPI0ClientObjPool [ 0 ]    chipSelectPin = DRV_SDSPI_CHIP_SELECT_PIN_IDX0    SDSPISpeedHz = DRV_SDSPI_SPEED_HZ_IDX0    writeProtectPin = SYS_PORT_PIN_NONE    isFsEnabled = DRV_SDSPI_REGISTER_WITH_FS_IDX0   // DMA Channel for Transmit   txDMAChannel = DRV_SDSPI_XMIT_DMA_CH_IDX0   // DMA Channel for Receive   rxDMAChannel = DRV_SDSPI_RCV_DMA_CH_IDX0   // SPI Transmit Register   txAddress =  ( void  * )  ( SPI0_REGS - SPI_TDR )   // SPI Receive Register   rxAddress =  ( void  * )  ( SPI0_REGS - SPI_RDR )   } ; objectHandle =  DRV_SDSPI_Initialize ( DRV_SDSPI_INDEX_0   ( SYS_MODULE_INIT * )  drvSDSPI0InitData ) ;  if  ( objectHandle == SYS_MODULE_OBJ_INVALID )  {  // Handle error  } ",
							" Remarks This routine must be called before any other SD Card routine is called This routine should only be called once during system initialization The system must use DRV_SDSPI_Status to find out when the driver is in the ready state ",
							" DRV_SDSPI_Status Function ",
							" C SYS_STATUS DRV_SDSPI_Status ( SYS_MODULE_OBJ object ) ",
							" Summary Provides the current status of the SDSPI driver module ",
							" Description This routine provides the current status of the SDSPI driver module ",
							" Precondition Function DRV_SDSPI_Initialize must have been called before calling this function ",
							" Parameters Param Description object Driver object handle returned from the DRV_SDSPI_Initialize routine ",
							" Returns SYS_STATUS_READY - Indicates that the driver has been initialized and is ready to accept requests from the client SYS_STATUS_UNINITIALIZED - Indicates that the driver has not been initialized ",
							" Example SYS_MODULE_OBJ object ;  // Returned from DRV_SDSPI_Initialize SYS_STATUS status ; status =  DRV_SDSPI_Status ( object ) ;  if  ( status == SYS_STATUS_READY )  {  // Driver is initialized and ready  } ",
							" Remarks This operation can be used to determine if the driver is initialized or not ",
							" DRV_SDSPI_Open Function ",
							" C DRV_HANDLE DRV_SDSPI_Open (  const SYS_MODULE_INDEX drvIndex   const DRV_IO_INTENT ioIntent ) ",
							" Summary Opens the specified SD Card driver instance and returns a handle to it ",
							" Description This routine opens the specified SD Card driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver ",
							" Precondition Function DRV_SDSPI_Initialize must have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the object instance to be opened ioIntent Zero or more of the values from the enumeration DRV_IO_INTENT \"ORed\" together to indicate the intended use of the driver Supports only DRV_IO_INTENT_EXCLUSIVE ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) If an error occurs the return value is DRV_HANDLE_INVALID ",
							" Example DRV_HANDLE handle ; handle = DRV_SDSPI_Open ( DRV_SDSPI_INDEX_0  DRV_IO_INTENT_EXCLUSIVE ) ;  if  ( handle == DRV_HANDLE_INVALID )  {  // Unable to open the driver  } ",
							" Remarks The handle returned is valid until the DRV_SDSPI_Close routine is called This routine may block for other client-level operations to complete ",
							" DRV_SDSPI_Close Function ",
							" C void DRV_SDSPI_Close (  const DRV_HANDLE handle ) ",
							" Summary Closes an opened-instance of the SD Card driver ",
							" Description This routine closes an opened-instance of the SD Card driver invalidating the handle ",
							" Precondition The DRV_SDSPI_Initialize routine must have been called for the specified SD Card driver instance DRV_SDSPI_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns None ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_SDSPI_Open DRV_SDSPI_Close ( handle ) ; ",
							" Remarks After calling this routine the handle passed in \"handle\" must not be used with any of the remaining driver routines A new handle must be obtained by calling DRV_SDSPI_Open before the caller may use the driver again This routine may block for other client-level operations to complete Note: Usually there is no need for the driver client to verify that the Close operation has completed ",
							" DRV_SDSPI_Tasks Function ",
							" C void DRV_SDSPI_Tasks ( SYS_MODULE_OBJ object ) ",
							" Summary Maintains the driver's state machine ",
							" Description This routine is used to maintain the driver's internal state machine For synchronous driver the task routine periodically checks for SD card attach/detach event and initializes the SD card ",
							" Precondition The DRV_SDSPI_Initialize routine must have been called for the specified SDSPI driver instance ",
							" Parameters Param Description object Object handle for the specified driver instance (returned from DRV_SDSPI_Initialize) ",
							" Returns None ",
							" Example //sysObj drvSDSPI0 is returned by the driver initialization routine  //For synchronous driver  while ( 1 )  {  DRV_SDSPI_Tasks ( sysObj  drvSDSPI0 ) ;  // Yield and allow other threads to run  vTaskDelay ( 100  / portTICK_PERIOD_MS ) ;  } ",
							" Remarks This routine is normally not called directly by an application For synchronous driver with RTOS this routine is called from a separate RTOS thread ",
							" DRV_SDSPI_SyncRead Function ",
							" C bool DRV_SDSPI_SyncRead (  const DRV_HANDLE handle   void * targetBuffer  uint32_t blockStart  uint32_t nBlock ) ",
							" Summary Reads blocks of data from the specified block address of the SD Card ",
							" Description This function performs a blocking read operation to read blocks of data from the SD Card The function returns true if the request was successfully executed; returns false otherwise The function returns false under following conditions: if the driver handle is invalid if the target buffer pointer is NULL if the number of blocks to be read is zero or more than the actual number of blocks available Error during the read operation ",
							" Precondition The DRV_SDSPI_Initialize routine must have been called for the specified SDSPI driver instance DRV_SDSPI_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function targetBuffer Buffer into which the data read from the SD Card will be placed blockStart Starting block address of the SD Card from where the read should begin nBlock Total number of blocks to be read ",
							" Returns true - If the request was executed successfully false - If there was an error executing the request ",
							" Example # define MY_BUFFER_SIZE 1024 uint8_t CACHE_ALIGN myBuffer [ MY_BUFFER_SIZE ] ;  // Address must be block aligned uint32_t blockStart =  0x00 ; uint32_t nBlock =  2 ;  // mySDSPIHandle is the handle returned by the DRV_SDSPI_Open function  if  ( DRV_SDSPI_SyncRead ( mySDSPIHandle  myBuffer  blockStart  nBlock )  == true )  {  // Read successful  }  else  {  // Error handling here  }  ",
							" Remarks None ",
							" DRV_SDSPI_AsyncRead Function ",
							" C void DRV_SDSPI_AsyncRead (  const DRV_HANDLE handle  DRV_SDSPI_COMMAND_HANDLE * commandHandle   void * targetBuffer  uint32_t blockStart  uint32_t nBlocks ) ",
							" Summary Reads blocks of data from the specified block address of the SD Card ",
							" Description This function schedules a non-blocking read operation for reading blocks of data from the SD Card The function returns with a valid buffer handle in the commandHandle argument if the read request was scheduled successfully The function adds the request to the hardware instance queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified The function returns DRV_SDSPI_COMMAND_HANDLE_INVALID in the commandHandle argument under the following circumstances: if the driver handle is invalid if the target buffer pointer is NULL if the number of blocks to be read is zero or more than the actual number of blocks available Error during the read operation ",
							" Precondition The DRV_SDSPI_Initialize routine must have been called for the specified SDSPI driver instance DRV_SDSPI_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return buffer handle targetBuffer Buffer into which the data read from the SD Card will be placed blockStart Starting block address of the SD Card from where the read should begin nBlock Total number of blocks to be read ",
							" Returns The buffer handle is returned in the commandHandle argument It will be DRV_SDSPI_COMMAND_HANDLE_INVALID if the request was not successful ",
							" Example uint8_t CACHE_ALIGN myBuffer [ MY_BUFFER_SIZE ] ;  // address should be block aligned uint32_t blockStart =  0x00 ; uint32_t nBlock =  2 ; DRV_SDSPI_COMMAND_HANDLE commandHandle ; MY_APP_OBJ myAppObj ;  // Event is received when  // the buffer is processed  void  APP_SDSPIEventHandler ( DRV_SDSPI_EVENT event  DRV_SDSPI_COMMAND_HANDLE commandHandle  uintptr_t contextHandle )  {  // contextHandle points to myAppObj  switch ( event )  {  case DRV_SDSPI_EVENT_COMMAND_COMPLETE :  {  // This means the data was transferred successfully  break ;  }  case DRV_SDSPI_EVENT_COMMAND_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  }  // mySDSPIHandle is the handle returned  // by the DRV_SDSPI_Open function  // Client registers an event handler with driver  DRV_SDSPI_EventHandlerSet ( mySDSPIHandle  APP_SDSPIEventHandler   ( uintptr_t )  myAppObj ) ;  DRV_SDSPI_AsyncRead ( mySDSPIHandle    commandHandle    myBuffer [ 0 ]  blockStart  nBlock ) ;  if ( commandHandle == DRV_SDMMC_COMMAND_HANDLE_INVALID )  {  // Error handling here  }  else  {  // Read Successfully queued  } ",
							" Remarks None ",
							" DRV_SDSPI_SyncWrite Function ",
							" C bool DRV_SDSPI_SyncWrite (  const DRV_HANDLE handle   void * sourceBuffer  uint32_t blockStart  uint32_t nBlock ) ",
							" Summary Writes blocks of data starting at the specified address of the SD Card ",
							" Description This function performs a blocking write operation to write blocks of data to the SD Card The function returns true if the request was successfully executed The function returns false under the following circumstances: if the driver handle is invalid if the source buffer pointer is NULL if the number of blocks to be written is either zero or more than the number of blocks actually available if the SD card is write-protected if there was an error during the SD card write operation ",
							" Precondition The DRV_SDSPI_Initialize routine must have been called for the specified SDSPI driver instance DRV_SDSPI_Open routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function sourceBuffer The source buffer containing data to be written to the SD Card blockStart Starting block address of SD Card where the writes should begin nBlock Total number of blocks to be written ",
							" Returns true - If the request was executed successfully false - If there was an error executing the request ",
							" Example # define MY_BUFFER_SIZE 1024 uint8_t CACHE_ALIGN myBuffer [ MY_BUFFER_SIZE ] ;  // Address must be block aligned uint32_t blockStart =  0x00 ; uint32_t nBlock =  2 ;  // mySDSPIHandle is the handle returned by the DRV_SDSPI_Open function  if  ( DRV_SDSPI_SyncWrite ( mySDSPIHandle  myBuffer  blockStart  nBlock )  == true )  {  // Write is successful  }  else  {  // Error handling here  } ",
							" Remarks None ",
							" DRV_SDSPI_AsyncWrite Function ",
							" C void  DRV_SDSPI_AsyncWrite (  const DRV_HANDLE handle  DRV_SDSPI_COMMAND_HANDLE * commandHandle   void * sourceBuffer  uint32_t blockStart  uint32_t nBlocks ) ",
							" Summary Writes blocks of data starting at the specified address of the SD Card ",
							" Description This function performs a non-blocking write operation to write blocks of data to the SD Card The function returns with a valid buffer handle in the commandHandle argument if the write request was scheduled successfully The function adds the request to the hardware instance queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified The function returns DRV_SDSPI_COMMAND_HANDLE_INVALID in the commandHandle argument under the following circumstances: if the driver handle is invalid if the source buffer pointer is NULL if the number of blocks to be written is either zero or more than the number of blocks actually available if the SD card is write-protected if there was an error during the SD card write operation If the requesting client registered an event callback with the driver the driver will issue a DRV_SDSPI_EVENT_COMMAND_COMPLETE event if the buffer was processed successfully or DRV_SDSPI_EVENT_COMMAND_ERROR event if the buffer was not processed successfully ",
							" Precondition The DRV_SDSPI_Initialize routine must have been called for the specified SDSPI driver instance DRV_SDSPI_Open routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return buffer handle sourceBuffer The source buffer containing data to be written to the SD Card blockStart Starting block address of SD Card where the writes should begin nBlock Total number of blocks to be written ",
							" Returns The buffer handle is returned in the commandHandle argument It will be DRV_SDSPI_COMMAND_HANDLE_INVALID if the request was not queued successfully ",
							" Example uint8_t CACHE_ALIGN myBuffer [ MY_BUFFER_SIZE ] ;  // address should be block aligned uint32_t blockStart =  0x00 ; uint32_t nBlock =  2 ; DRV_SDSPI_COMMAND_HANDLE commandHandle ; MY_APP_OBJ myAppObj ;  // Event is received when  // the buffer is processed  void  APP_SDSPIEventHandler ( DRV_SDSPI_EVENT event  DRV_SDSPI_COMMAND_HANDLE commandHandle  uintptr_t contextHandle )  {  // contextHandle points to myAppObj  switch ( event )  {  case DRV_SDSPI_EVENT_COMMAND_COMPLETE :  {  // This means the data was transferred successfully  break ;  }  case DRV_SDSPI_EVENT_COMMAND_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  }  // mySDSPIHandle is the handle returned  // by the DRV_SDSPI_Open function  // Client registers an event handler with driver  DRV_SDSPI_EventHandlerSet ( mySDSPIHandle  APP_SDSPIEventHandler   ( uintptr_t )  myAppObj ) ;  DRV_SDSPI_AsyncWrite ( mySDSPIHandle    commandHandle    myBuffer [ 0 ]  blockStart  nBlock ) ;  if ( commandHandle == DRV_SDSPI_COMMAND_HANDLE_INVALID )  {  // Error handling here  } ",
							" Remarks None ",
							" DRV_SDSPI_IsAttached Function ",
							" C bool DRV_SDSPI_IsAttached (  const DRV_HANDLE handle ) ",
							" Summary Returns the physical attach status of the SD Card ",
							" Description This function returns the physical attach status of the SD Card ",
							" Precondition The DRV_SDSPI_Initialize routine must have been called for the specified SDSPI driver instance The DRV_SDSPI_Open routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function ",
							" Returns true - If the SD Card is attached and initialized by the SDSPI driver false - If the handle is invalid ",
							" Example bool isSDSPIAttached ;  // mySDSPIHandle is the handle returned by the DRV_SDSPI_Open function isSDSPIAttached =  DRV_SDSPI_IsAttached ( mySDSPIHandle ) ;  if  ( isSDSPIAttached == true )  {  // SD Card is attached and initialized by the SDSPI driver  }  ",
							" Remarks None ",
							" DRV_SDSPI_IsWriteProtected Function ",
							" C bool DRV_SDSPI_IsWriteProtected (  const DRV_HANDLE handle ) ",
							" Summary Returns the write protect status of the SD Card ",
							" Description This function returns true if the SD Card is write protected otherwise it returns false ",
							" Precondition The DRV_SDSPI_Initialize routine must have been called for the specified SDSPI driver instance The DRV_SDSPI_Open routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function ",
							" Returns true - If the attached SD Card is write protected If the configured write protect GPIO pin is read High by the driver then the card is write protected The status of the write protect GPIO pin is read by the driver during the media (SD Card) initialization false - If the handle is not valid or if the SD Card is not write protected ",
							" Example bool isWriteProtected ;  // mySDSPIHandle is the handle returned by the DRV_SDSPI_Open function isWriteProtected =  DRV_SDSPI_IsWriteProtected ( mySDSPIHandle ) ;  if  ( isWriteProtected == true )  {  //SD Card is write protected  }  ",
							" Remarks None ",
							" DRV_SDSPI_GeometryGet Function ",
							" C SYS_MEDIA_GEOMETRY * DRV_SDSPI_GeometryGet (  const DRV_HANDLE handle ) ",
							" Summary Returns the geometry of the device ",
							" Description This API gives the following geometrical details of the SD Card Media Property Number of Read/Write/Erase regions in the SD Card Number of Blocks and their size in each region of the device ",
							" Precondition The DRV_SDSPI_Initialize routine must have been called for the specified SDSPI driver instance The DRV_SDSPI_Open routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function ",
							" Returns SYS_MEDIA_GEOMETRY - Pointer to structure which holds the media geometry information ",
							" Example SYS_MEDIA_GEOMETRY * SDSPIGeometry ; uint32_t readBlockSize  writeBlockSize  eraseBlockSize ; uint32_t nReadBlocks  nReadRegions  totalSize ;  // mySDSPIHandle is the handle returned by the DRV_SDSPI_Open function SDSPIGeometry =  DRV_SDSPI_GeometryGet ( mySDSPIHandle ) ; readBlockSize = SDSPIGeometry - geometryTable - blockSize ; nReadBlocks = SDSPIGeometry - geometryTable - numBlocks ; nReadRegions = SDSPIGeometry - numReadRegions ; writeBlockSize =  ( SDSPIGeometry - geometryTable + 1 ) - blockSize ; eraseBlockSize =  ( SDSPIGeometry - geometryTable + 2 ) - blockSize ; totalSize = readBlockSize * nReadBlocks * nReadRegions ;  ",
							" Remarks Refer sys_media h for definition of SYS_MEDIA_GEOMETRY ",
							" DRV_SDSPI_EventHandlerSet Function ",
							" C void DRV_SDSPI_EventHandlerSet (  const DRV_HANDLE handle   const  void  * eventHandler   const uintptr_t context ) ",
							" Summary Allows a client to identify an event handling function for the driver to call back when queued operation has completed For the synchronous SDSPI driver the event handler is only used by the file system ",
							" Description This function allows a client to identify an event handling function for the driver to call back when queued operation has completed When a client queues a request for a read or a write operation it is provided with a handle identifying the buffer that was added to the driver's buffer queue The driver will pass this handle back to the client by calling \"eventHandler\" function when the queued operation has completed The event handler should be set before the client performs any read or write operations that could generate events The event handler once set persists until the client closes the driver or sets another event handler (which could be a \"NULL\" pointer to indicate no callback) ",
							" Precondition The DRV_SDSPI_Initialize routine must have been called for the specified SDSPI driver instance The DRV_SDSPI_Open routine must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function eventHandler Pointer to the event handler function implemented by the user context The value of parameter will be passed back to the client unchanged when the eventHandler function is called It can be used to identify any client specific data object that identifies the instance of the client module (for example it may be a pointer to the client module's state structure) ",
							" Returns None ",
							" Example // Event is received when // the buffer is processed void APP_SDSPIEventHandler( DRV_SDSPI_EVENT event DRV_SDSPI_COMMAND_HANDLE commandHandle uintptr_t contextHandle ) { // contextHandle points to myAppObj switch(event) { case DRV_SDSPI_EVENT_COMMAND_COMPLETE: { // This means the data was transferred successfully break; } case DRV_SDSPI_EVENT_COMMAND_ERROR: { // Error handling here break; } default: { break; } } } // mySDSPIHandle is the handle returned // by the DRV_SDSPI_Open function // Client registers an event handler with driver DRV_SDSPI_EventHandlerSet(mySDSPIHandle APP_SDSPIEventHandler (uintptr_t) myAppObj); ",
							" Remarks If the client does not want to be notified when the queued operation has completed it does not need to register a callback This API may not be used in applications using the SDSPI Driver in synchronous mode ",
							" DRV_SDSPI_CommandStatusGet Function ",
							" C DRV_SDSPI_COMMAND_STATUS DRV_SDSPI_CommandStatusGet (  const DRV_HANDLE handle   const DRV_SDSPI_COMMAND_HANDLE commandHandle ) ",
							" Summary Gets the current status of the command For synchronous mode the command status is only used by the file system ",
							" Description This routine gets the current status of the command The application must use this routine where the status of a scheduled command needs to be polled on The function may return DRV_SDSPI_COMMAND_HANDLE_INVALID in a case where the command handle has expired A command handle expires when the internal buffer object is re-assigned to another read or write request It is recommended that this function be called regularly in order to track the command status correctly The application can alternatively register an event handler to receive read or write operation completion events ",
							" Preconditions The DRV_SDSPI_Initialize routine must have been called The DRV_SDSPI_Open must have been called to obtain a valid opened device handle A read or write request must have been submitted to the SDSPI driver ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine commandHandle Handle to the command whose status is to be known ",
							" Returns A DRV_SDSPI_COMMAND_STATUS value describing the current status of the command DRV_SDSPI_COMMAND_ERROR_UNKNOWN if the client handle or the command handle is not valid ",
							" Example None ",
							" Remarks This API may not be used in applications using the SDSPI Driver in synchronous mode ",
							" DRV_SDSPI_Read Function ",
							" C void DRV_SDSPI_Read (  const DRV_HANDLE handle  DRV_SDSPI_COMMAND_HANDLE * commandHandle   void * targetBuffer  uint32_t blockStart  uint32_t nBlock ) ",
							" Summary This routine provides interface to the file system to perform a media read operation in synchronous mode of the SDSPI driver ",
							" Description This function is internally used by the file system ",
							" Preconditions The DRV_SDSPI_Initialize routine must have been called The DRV_SDSPI_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return buffer handle targetBuffer Buffer into which the data read from the SD Card will be placed blockStart Start block address of the SD Card from where the read should begin nBlock Total number of blocks to be read ",
							" Returns The buffer handle is returned in the commandHandle argument It will be DRV_SDSPI_COMMAND_HANDLE_INVALID if the request was not successful ",
							" Example None ",
							" Remarks This function is internally used by the file system ",
							" DRV_SDSPI_Write Function ",
							" C void DRV_SDSPI_Write (  const DRV_HANDLE handle  DRV_SDSPI_COMMAND_HANDLE * commandHandle   void * sourceBuffer  uint32_t blockStart  uint32_t nBlock ) ",
							" Summary This routine provides interface to the file system to perform a media write operation in synchronous mode of the SDSPI driver ",
							" Description This function is internally used by the file system ",
							" Preconditions The DRV_SDSPI_Initialize routine must have been called The DRV_SDSPI_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open function commandHandle Pointer to an argument that will contain the return buffer handle sourceBuffer The source buffer containing data to be programmed to the SD Card blockStart Start block address of SD Card where the writes should begin nBlock Total number of blocks to be written ",
							" Returns The buffer handle is returned in the commandHandle argument It will be DRV_SDSPI_COMMAND_HANDLE_INVALID if the request was not successful ",
							" Example None ",
							" Remarks This function is internally used by the file system ",
							" DRV_SDSPI_COMMAND_HANDLE Typedef ",
							" C typedef SYS_MEDIA_BLOCK_COMMAND_HANDLE DRV_SDSPI_COMMAND_HANDLE ;  ",
							" Summary Handle identifying commands queued in the driver ",
							" Description A command handle is returned by a call to the Read or Write functions This handle allows the application to track the completion of the operation This command handle is also returned to the client along with the event that has occurred with respect to the command This allows the application to connect the event to a specific command in case where multiple commands are queued The command handle associated with the command request expires when the client has been notified of the completion of the command (after event handler function that notifies the client returns) or after the command has been retired by the driver if no event handler callback was set ",
							" Remarks Refer sys_media h for definition of SYS_MEDIA_BLOCK_COMMAND_HANDLE ",
							" DRV_SDSPI_COMMAND_HANDLE_INVALID Macro ",
							" C # define DRV_SDSPI_COMMAND_HANDLE_INVALID SYS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID  ",
							" Summary SDSPI Driver's Invalid Command Handle ",
							" Description This value defines the SDSPI Driver Invalid Command Handle This value is returned by read or write routines when the command request was not accepted ",
							" Remarks Refer sys_media h for definition of SYS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID ",
							" DRV_SDSPI_COMMAND_STATUS Enum ",
							" C typedef  enum  {  /*Done OK and ready */ DRV_SDSPI_COMMAND_COMPLETED = SYS_MEDIA_COMMAND_COMPLETED   /*Scheduled but not started */ DRV_SDSPI_COMMAND_QUEUED = SYS_MEDIA_COMMAND_QUEUED   /*Currently being in transfer */ DRV_SDSPI_COMMAND_IN_PROGRESS = SYS_MEDIA_COMMAND_IN_PROGRESS   /*Unknown Command */ DRV_SDSPI_COMMAND_ERROR_UNKNOWN = SYS_MEDIA_COMMAND_UNKNOWN   } DRV_SDSPI_COMMAND_STATUS ;  ",
							" Summary Identifies the possible events that can result from a request ",
							" Description This enumeration identifies the possible status values of a read or write buffer request submitted to the driver One of these values is returned by the DRV_SDSPI_CommandStatusGet routine ",
							" Remarks Refer sys_media h for SYS_MEDIA_XXX definitions ",
							" DRV_SDSPI_EVENT Enum ",
							" C typedef  enum  {  /* Operation has been completed successfully */ DRV_SDSPI_EVENT_COMMAND_COMPLETE = SYS_MEDIA_EVENT_BLOCK_COMMAND_COMPLETE   /* There was an error during the operation */ DRV_SDSPI_EVENT_COMMAND_ERROR = SYS_MEDIA_EVENT_BLOCK_COMMAND_ERROR } DRV_SDSPI_EVENT ;  ",
							" Summary Identifies the possible events that can result from a request ",
							" Description This enumeration identifies the possible events that can result from a read or a write request issued by the client ",
							" Remarks One of these values is passed in the \"event\" parameter of the event handling callback function that client registered with the driver by calling the DRV_SDSPI_EventHandlerSet function when a request is completed ",
							" Remarks Refer sys_media h for definition of SYS_MEDIA_XXX ",
							" DRV_SDSPI_EVENT_HANDLER Typedef ",
							" C typedef SYS_MEDIA_EVENT_HANDLER DRV_SDSPI_EVENT_HANDLER ;  ",
							" Summary Pointer to a SDSPI Driver Event handler function ",
							" Description This data type defines the required function signature for the SDSPI event handling callback function A client must register a pointer to an event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive event calls back from the driver If the event is DRV_SDSPI_EVENT_COMMAND_COMPLETE it means that the write or a erase operation was completed successfully If the event is DRV_SDSPI_EVENT_COMMAND_ERROR it means that the scheduled operation was not completed successfully The context parameter contains the handle to the client context provided at the time the event handling function was registered using the DRV_SDSPI_EventHandlerSet function This context handle value is passed back to the client as the \"context\" parameter It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the read/write/erase request ",
							" Parameters Param Description event Identifies the type of event commandHandle Handle returned from the Read/Write requests context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Example void  APP_SDSPIEventHandler ( DRV_SDSPI_EVENT event  DRV_SDSPI_COMMAND_HANDLE commandHandle  uintptr_t contextHandle )  {  // contextHandle points to myAppObj  switch ( event )  {  case DRV_SDSPI_EVENT_COMMAND_COMPLETE :  {  // This means the data was transferred successfully  break ;  }  case DRV_SDSPI_EVENT_COMMAND_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  } ",
							" Remarks Refer sys_media h for definition of SYS_MEDIA_EVENT_HANDLER ",
							" SPI Driver The SPI Driver is a multi-client multi-instance buffer model based driver interface which can be used to communicate with various slave devices like EEPROM ADC etc Key Features of SPI Driver: Multi Client: Each instance of SPI driver can have multiple clients This means the SPI driver supports multiple slaves connected to the same SPI bus Multi Instance: Provides interface to manage multiple instances of SPI peripheral Supports Asynchronous and Synchronous modes of operation Supports Bare Metal and RTOS environments Supports DMA ",
							" How the Library Works The SPI driver library is a multi-client multi-instance buffer queue model based driver interface Abstraction Model The SPI driver provides interface to use multiple SPI Peripherals (via SPI PLIB instances) connected with one or multiple slave devices Note: Queue is not present in Synchronous mode of the driver drv_spi_abstraction_model Working Flow The SPI driver is built on top of the SPI peripheral library The SPI driver is capable of supporting multiple instances of the SPI peripheral The SPI driver supports multiple clients to a driver instance This is used when there are more than one SPI slaves on the same bus The driver configures the SPI communication parameters such as SPI clock speed SPI clock phase and polarity Data width and chip select automatically based on the SPI slave being talked to you (that is based on which client submitted the request) The SPI driver can be configured to use DMA for data Transfer/Receive SPI driver is capable of working in both Asynchronous and Synchronous modes SPI driver in Asynchronous mode Asynchronous mode APIs are non-blocking in nature These APIs submit a request and return back to the application Typically if there are no on-going or pending requests in the driver's transfer queue then the transfer is started by the API and completed from the peripheral interrupt If there is an on-going transfer or one or more requests pending in the driver's transfer queue then the request is added to the queue and executed when all the pending requests are complete The size of the transfer queue is configurable using MCC based on application needs The transfer APIs provide a transfer handle back to the application If the driver was unable to accept the request then the transfer handle will be set to NULL This usually happens if the transfer queue is full or if invalid argruments are passed to the API Application must check the value of the transfer handle to ensure the request was accepted successfully Transfer handle can be used to identify/track the request Application can either register a callback to get notified when the transfer is complete or poll the status of the request by calling the DRV_SPI_TransferStatusGet() API Asynchronous mode APIs are available in both bare-metal and RTOS mode SPI driver in Synchronous mode Synchronous mode APIs are blocking in nature These APIs block until the transfer/request is complete Synchronous mode APIs are only supported in RTOS mode These APIs initate the transfer and then block on a semaphore while the transfer is in progress thereby allowing other ready tasks to run Once the transfer is complete the semaphore is given (from the peripheral interrupt's context) thereby unblocking the calling task The return value usually provides the status of the transfer ",
							" Using The Library The SPI driver builds on top of the SPI peripheral library (PLIB) and provides write read and write-read API's in blocking and non-blocking mode Provides Write Read and Write followed by Read API's Supports multiple slaves connected to the same SPI peripheral instance (multi-client mode) In asynchronous (non-blocking) mode application can either register a callback to get notified once the data transfer is complete or can poll the status of the data transfer using the status APIs In asynchronous mode application can queue more than one transmit/receive requests without waiting for the previous request to be completed The number of transmit/receive requests that can be queued depends on the depth of the transfer queue configured using the MHC The asynchronous mode is supported in both bare-metal and RTOS environment The synchronous (blocking) mode of the driver is supported only in an RTOS environment The synchronous mode of the driver does not support callback or queuing multiple requests This is because the implementation is blocking in nature Supports DMA for Transfer/Receive in both asynchronous and synchronous mode Example application to Read and Write from SPI EEPROM in Asynchronous mode /* EEPROM Commands */  # define EEPROM_CMD_WREN 0x06  # define EEPROM_CMD_WRITE 0x02  # define EEPROM_CMD_RDSR 0x05  # define EEPROM_CMD_READ 0x03  # define EEPROM_START_ADDRESS 0x000000  # define EEPROM_STATUS_BUSY_BIT 0x01  static APP_EEPROM_DATA app_eepromData ;  static  const uint8_t EEPROM_MSG_STR [ ]  =  \"WRITING AND READING DATA ON EEPROM SLAVE\" ;  /* On devices with cache the array size has to be of multiple of cache line size and aligned to * cache line boundary */  static uint8_t CACHE_ALIGN eepromTxData [ 64 ] ;  static uint8_t CACHE_ALIGN eepromRxData [ 64 ] ;  static  void  SPI_EEEPROM_EventHandler ( DRV_SPI_TRANSFER_EVENT event  DRV_SPI_TRANSFER_HANDLE transferHandle  uintptr_t context )  {  if  ( event == DRV_SPI_TRANSFER_EVENT_COMPLETE )  { app_eepromData  isTransferComplete = true ;  }  else  { app_eepromData  isTransferComplete = false ; app_eepromData  state = APP_EEPROM_STATE_ERROR ;  }  }  void APP_EEPROM_Initialize (  void  )  {  /* Place the App state machine in its initial state */ app_eepromData  state = APP_EEPROM_STATE_DATA_INIT ; app_eepromData  drvSPIHandle = DRV_HANDLE_INVALID ; app_eepromData  transferStatus = APP_ERROR ; app_eepromData  isTransferComplete = false ;  memset ( eepromTxData   0   sizeof ( eepromTxData ) ) ;  memset ( eepromRxData   0   sizeof ( eepromRxData ) ) ;  APP_EEPROM_CS_Set ( ) ;  /* As EEPROM WP and HOLD pins are already latched high from * Pin Configuration no need to set both pins high again */  }  void APP_EEPROM_Tasks (  void  )  { uint32_t eepromAddr = EEPROM_START_ADDRESS ;  /* Check the application's current state */  switch  ( app_eepromData  state )  {  /* Application's initial state */  case APP_EEPROM_STATE_DATA_INIT :  /* Setup SPI for client 1 which is EEPROM 1 */ app_eepromData  setup  baudRateInHz =  600000 ; app_eepromData  setup  clockPhase = DRV_SPI_CLOCK_PHASE_VALID_LEADING_EDGE ; app_eepromData  setup  clockPolarity = DRV_SPI_CLOCK_POLARITY_IDLE_LOW ; app_eepromData  setup  dataBits = DRV_SPI_DATA_BITS_8 ; app_eepromData  setup  chipSelect =  ( SYS_PORT_PIN ) APP_EEPROM_CS_PIN ; app_eepromData  setup  csPolarity = DRV_SPI_CS_POLARITY_ACTIVE_LOW ; app_eepromData  state = APP_EEPROM_STATE_DRIVER_SETUP ;  break ;  case APP_EEPROM_STATE_DRIVER_SETUP :  /* Open the SPI Driver for client 1 */ app_eepromData  drvSPIHandle =  DRV_SPI_Open ( DRV_SPI_INDEX_0  DRV_IO_INTENT_READWRITE ) ;  if ( app_eepromData  drvSPIHandle = DRV_HANDLE_INVALID )  {  if ( DRV_SPI_TransferSetup ( app_eepromData  drvSPIHandle    app_eepromData  setup )  == true )  {  DRV_SPI_TransferEventHandlerSet ( app_eepromData  drvSPIHandle  SPI_EEEPROM_EventHandler   ( uintptr_t ) 0 ) ; app_eepromData  state = APP_EEPROM_STATE_WRITE_ENABLE ;  }  else  { app_eepromData  state = APP_EEPROM_STATE_ERROR ;  }  }  else  { app_eepromData  state = APP_EEPROM_STATE_ERROR ;  }  break ;  case APP_EEPROM_STATE_WRITE_ENABLE :  /* Set the next state first as callback may be fired before the state * is changed; potentially over-writing error state set from the callback */ app_eepromData  state = APP_EEPROM_STATE_WRITE ; eepromTxData [ 0 ]  = EEPROM_CMD_WREN ;  DRV_SPI_WriteTransferAdd ( app_eepromData  drvSPIHandle  eepromTxData   1    app_eepromData  transferHandle ) ;  if ( app_eepromData  transferHandle == DRV_SPI_TRANSFER_HANDLE_INVALID )  { app_eepromData  state = APP_EEPROM_STATE_ERROR ;  }  break ;  case APP_EEPROM_STATE_WRITE :  if  ( app_eepromData  isTransferComplete == true )  { app_eepromData  isTransferComplete = false ;  // Write to EEPROM eepromTxData [ 0 ]  = EEPROM_CMD_WRITE ; eepromTxData [ 1 ]  =  ( uint8_t ) ( eepromAddr  16 ) ; eepromTxData [ 2 ]  =  ( uint8_t ) ( eepromAddr  8 ) ; eepromTxData [ 3 ]  =  ( uint8_t ) ( eepromAddr ) ;  memcpy (  eepromTxData [ 4 ]  EEPROM_MSG_STR   strlen ( ( const  char * ) EEPROM_MSG_STR ) ) ; app_eepromData  state = APP_EEPROM_STATE_WAIT_FOR_WRITE_COMPLETE ;  DRV_SPI_WriteTransferAdd ( app_eepromData  drvSPIHandle  eepromTxData   ( 4  +  strlen ( ( const  char * ) EEPROM_MSG_STR ) )    app_eepromData  transferHandle ) ;  if ( app_eepromData  transferHandle == DRV_SPI_TRANSFER_HANDLE_INVALID )  { app_eepromData  state = APP_EEPROM_STATE_ERROR ;  }  }  break ;  case APP_EEPROM_STATE_WAIT_FOR_WRITE_COMPLETE :  if  ( app_eepromData  isTransferComplete == true )  { app_eepromData  isTransferComplete = false ; eepromTxData [ 0 ]  = EEPROM_CMD_RDSR ; app_eepromData  state = APP_EEPROM_STATE_CHECK_STATUS ;  DRV_SPI_WriteReadTransferAdd ( app_eepromData  drvSPIHandle  eepromTxData   1  eepromRxData   2    app_eepromData  transferHandle ) ;  if ( app_eepromData  transferHandle == DRV_SPI_TRANSFER_HANDLE_INVALID )  { app_eepromData  state = APP_EEPROM_STATE_ERROR ;  }  }  break ;  case APP_EEPROM_STATE_CHECK_STATUS :  if  ( app_eepromData  isTransferComplete == true )  { app_eepromData  isTransferComplete = false ;  if ( ( eepromRxData [ 1 ]   EEPROM_STATUS_BUSY_BIT )  ==  0x00 )  { app_eepromData  state = APP_EEPROM_STATE_READ ;  }  else  {  /* EEPROM is still busy Keep checking the status */  DRV_SPI_WriteReadTransferAdd ( app_eepromData  drvSPIHandle  eepromTxData   1  eepromRxData   2    app_eepromData  transferHandle ) ;  if ( app_eepromData  transferHandle == DRV_SPI_TRANSFER_HANDLE_INVALID )  { app_eepromData  state = APP_EEPROM_STATE_ERROR ;  }  }  }  break ;  case APP_EEPROM_STATE_READ :  // Read from EEPROM eepromTxData [ 0 ]  = EEPROM_CMD_READ ; eepromTxData [ 1 ]  =  ( uint8_t ) ( eepromAddr  16 ) ; eepromTxData [ 2 ]  =  ( uint8_t ) ( eepromAddr  8 ) ; eepromTxData [ 3 ]  =  ( uint8_t ) ( eepromAddr ) ; app_eepromData  state = APP_EEPROM_STATE_DATA_COMPARISON ;  DRV_SPI_WriteReadTransferAdd ( app_eepromData  drvSPIHandle  eepromTxData   4  eepromRxData   ( 4  +  strlen ( ( const  char * ) EEPROM_MSG_STR ) )    app_eepromData  transferHandle ) ;  if ( app_eepromData  transferHandle == DRV_SPI_TRANSFER_HANDLE_INVALID )  { app_eepromData  state = APP_EEPROM_STATE_ERROR ;  }  break ;  case APP_EEPROM_STATE_DATA_COMPARISON :  if  ( app_eepromData  isTransferComplete == true )  { app_eepromData  isTransferComplete = false ;  if  ( memcmp (  eepromRxData [ 4 ]  EEPROM_MSG_STR   strlen ( ( const  char * ) EEPROM_MSG_STR ) )  ==  0 )  { app_eepromData  state = APP_EEPROM_STATE_SUCCESS ;  }  else  { app_eepromData  state = APP_EEPROM_STATE_ERROR ;  }  }  break ;  case APP_EEPROM_STATE_SUCCESS : app_eepromData  transferStatus = APP_SUCCESS ; app_eepromData  state = APP_EEPROM_STATE_IDLE ;  break ;  case APP_EEPROM_STATE_ERROR : app_eepromData  transferStatus = APP_ERROR ; app_eepromData  state = APP_EEPROM_STATE_IDLE ;  break ;  case APP_EEPROM_STATE_IDLE :  default :  break ;  }  } ",
							" Configuring The Library SPI Driver Library should be configured via MHC The following figures show the MHC configuration window for SPI driver and brief description Common User Configuration for all Instances Driver Mode: Allows User to select the mode of driver(Asynchronous or Synchronous) This setting is common for all the instances Instance Specific User Configurations SPI Driver Configuration in Asynchronous Mode drv_spi_mhc_config_async PLIB Used: Indicates the underlying SPI PLIB used by the driver The SPI driver only supports connecting to the SPI PLIB in master mode Number Of Clients: The total number of clients that can open the given SPI driver instance Transfer Queue Size: Indicates the size of the transfer queue for the given SPI driver instance Available only in Asynchronous mode of Operations Use DMA for Transmit and Receive Enables DMA For transmitting and receiving the data for that instance DMA Channel For Transmit: DMA Channel for transmission is automatically allocated in DMA configurations DMA Channel For Receive: DMA Channel for Receiving is automatically allocated in DMA configurations ",
							" Library Interface SPI driver library provides the following interfaces: Functions Name Description Asynchronous Mode Synchronous Mode DRV_SPI_Initialize Initializes the SPI instance for the specified driver index Yes Yes DRV_SPI_Status Gets the current status of the SPI driver module Yes Yes DRV_SPI_Open Opens the specified SPI driver instance and returns a handle to it Yes Yes DRV_SPI_Close Closes an opened-instance of the SPI driver Yes Yes DRV_SPI_TransferSetup Sets the dynamic configuration of the driver including chip select pin Yes Yes DRV_SPI_Lock Use this API to lock the SPI driver for exclusive use by a client Yes Yes DRV_SPI_WriteReadTransferAdd Queues a write-read transfer operation Yes No DRV_SPI_WriteTransferAdd Queues a write operation Yes No DRV_SPI_ReadTransferAdd Queues a read operation Yes No DRV_SPI_TransferEventHandlerSet Allows a client to set a transfer event handling function for the driver to call back when queued transfer has finished Yes No DRV_SPI_TransferStatusGet Returns transfer add request status Yes No DRV_SPI_WriteTransfer This is a blocking function that transmits data over SPI No Yes DRV_SPI_ReadTransfer This is a blocking function that receives data over SPI No Yes DRV_SPI_WriteReadTransfer This is a blocking function that transmits and receives data over SPI No Yes Data types and constants Name Type Description DRV_SPI_TRANSFER_HANDLE Typedef Handle identifying the transfer request queued DRV_SPI_TRANSFER_HANDLE_INVALID Macro Definition of an invalid transfer handle DRV_SPI_TRANSFER_EVENT Enum Identifies the possible events that can result from a transfer add request DRV_SPI_TRANSFER_EVENT_HANDLER Typedef Pointer to a SPI Driver Transfer Event handler function DRV_SPI_CLOCK_PHASE Enum Identifies SPI Clock Phase Options DRV_SPI_CLOCK_POLARITY Enum Identifies SPI Clock Polarity Options DRV_SPI_DATA_BITS Enum Identifies SPI bits per transfer DRV_SPI_CS_POLARITY Enum Identifies SPI Chip Select Polarity Options ",
							" DRV_SPI_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_SPI_Initialize (  const SYS_MODULE_INDEX index   const SYS_MODULE_INIT *  const init ) ",
							" Summary Initializes the SPI instance for the specified driver index ",
							" Description This routine initializes the SPI driver instance for the specified driver index making it ready for clients to open and use it The initialization data is specified by the init parameter The initialization may fail if the number of driver objects allocated are insufficient or if the specified driver instance is already initialized The driver instance index is independent of the SPI module ID For example driver instance 0 can be assigned to SPI2 ",
							" Precondition None ",
							" Parameters Param Description index Identifier for the instance to be initialized init Pointer to the init data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise returns SYS_MODULE_OBJ_INVALID ",
							" Example // The following code snippet shows an example SPI driver initialization SYS_MODULE_OBJ objectHandle ;  const DRV_SPI_PLIB_INTERFACE drvSPI0PlibAPI =  {  // SPI PLIB Setup   setup =  ( DRV_SPI_PLIB_SETUP ) SPI0_TransferSetup   // SPI PLIB WriteRead function   writeRead =  ( DRV_SPI_PLIB_WRITE_READ ) SPI0_WriteRead   // SPI PLIB Transfer Status function   isBusy =  ( DRV_SPI_PLIB_IS_BUSY ) SPI0_IsBusy   // SPI PLIB Callback Register   callbackRegister =  ( DRV_SPI_PLIB_CALLBACK_REGISTER ) SPI0_CallbackRegister   } ;  const DRV_SPI_INIT drvSPI0InitData =  {  // SPI PLIB API   spiPlib =   drvSPI0PlibAPI    remapDataBits = drvSPI0remapDataBits    remapClockPolarity = drvSPI0remapClockPolarity    remapClockPhase = drvSPI0remapClockPhase   /// SPI Number of clients   numClients = DRV_SPI_CLIENTS_NUMBER_IDX0   // SPI Client Objects Pool   clientObjPool =  ( uintptr_t )  drvSPI0ClientObjPool [ 0 ]   // DMA Channel for Transmit   dmaChannelTransmit = DRV_SPI_XMIT_DMA_CH_IDX0   // DMA Channel for Receive   dmaChannelReceive = DRV_SPI_RCV_DMA_CH_IDX0   // SPI Transmit Register   spiTransmitAddress =  ( void  * )  ( SPI0_REGS - SPI_TDR )   // SPI Receive Register   spiReceiveAddress =  ( void  * )  ( SPI0_REGS - SPI_RDR )   // Interrupt source is DMA   interruptSource = XDMAC_IRQn   // SPI Queue Size   queueSize = DRV_SPI_QUEUE_SIZE_IDX0   // SPI Transfer Objects Pool   transferObjPool =  ( uintptr_t )  drvSPI0TransferObjPool [ 0 ]   } ; objectHandle =  DRV_SPI_Initialize ( DRV_SPI_INDEX_0  ( SYS_MODULE_INIT * )  drvSPI0InitData ) ;  if  ( objectHandle == SYS_MODULE_OBJ_INVALID )  {  // Handle error  } ",
							" Remarks This routine must be called before any other SPI routine is called This routine must only be called once during system initialization This routine will NEVER block for hardware access ",
							" DRV_SPI_Status Function ",
							" C SYS_STATUS DRV_SPI_Status ( SYS_MODULE_OBJ object ) ",
							" Summary Gets the current status of the SPI driver module ",
							" Description This routine provides the current status of the SPI driver module ",
							" Precondition Function DRV_SPI_Initialize should have been called before calling this function ",
							" Parameters Param Description object Driver object handle returned from the DRV_SPI_Initialize routine ",
							" Returns SYS_STATUS_READY - Initialization have succeeded and the SPI is ready for additional operations SYS_STATUS_DEINITIALIZED - Indicates that the driver has been deinitialized ",
							" Example SYS_MODULE_OBJ object ;  // Returned from DRV_SPI_Initialize SYS_STATUS spiStatus ; spiStatus =  DRV_SPI_Status ( object ) ;  if  ( spiStatus == SYS_STATUS_READY )  {  // This means now the driver can be opened using the  // DRV_SPI_Open() function  } ",
							" Remarks A driver can be opened only when its status is SYS_STATUS_READY ",
							" DRV_SPI_Open Function ",
							" C DRV_HANDLE DRV_SPI_Open (  const SYS_MODULE_INDEX index   const DRV_IO_INTENT ioIntent ) ",
							" Summary Opens the specified SPI driver instance and returns a handle to it ",
							" Description This routine opens the specified SPI driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver The ioIntent parameter defines how the client interacts with this driver instance Specifying a DRV_IO_INTENT_EXCLUSIVE will cause the driver to provide exclusive access to this client The driver cannot be opened by any other client ",
							" Precondition Function DRV_SPI_Initialize must have been called before calling this function ",
							" Parameters Param Description index Identifier for the object instance to be opened intent Zero or more of the values from the enumeration DRV_IO_INTENT \"ORed\" together to indicate the intended use of the driver See function description for details ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) If an error occurs the return value is DRV_HANDLE_INVALID Error can occur if the number of client objects allocated via DRV_SPI_CLIENTS_NUMBER is insufficient if the client is trying to open the driver but driver has been opened exclusively by another client if the driver peripheral instance being opened is not initialized or is invalid if the client is trying to open the driver exclusively but has already been opened in a non exclusive mode by another client if the driver is not ready to be opened typically when the initialize routine has not completed execution ",
							" Example DRV_HANDLE handle ; handle =  DRV_SPI_Open ( DRV_SPI_INDEX_0  DRV_IO_INTENT_EXCLUSIVE ) ;  if  ( handle == DRV_HANDLE_INVALID )  {  // Unable to open the driver  // May be the driver is not initialized or the initialization  // is not complete  } ",
							" Remarks The handle returned is valid until the DRV_SPI_Close routine is called This routine will NEVER block waiting for hardware ",
							" DRV_SPI_Close Function ",
							" C void  DRV_SPI_Close ( DRV_Handle handle ) ",
							" Summary Closes an opened-instance of the SPI driver ",
							" Description This routine closes an opened-instance of the SPI driver invalidating the handle User should make sure that there is no transfer request pending before calling this API A new handle must be obtained by calling DRV_SPI_Open before the caller may use the driver again ",
							" Precondition DRV_SPI_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns None ",
							" Example // 'handle' returned from the DRV_SPI_Open  DRV_SPI_Close ( handle ) ;  ",
							" Remarks None ",
							" DRV_SPI_TransferSetup Function ",
							" C bool DRV_SPI_TransferSetup ( DRV_HANDLE handle  DRV_SPI_TRANSFER_SETUP * setup ) ",
							" Summary Sets the dynamic configuration of the driver including chip select pin ",
							" Description This function is used to update any of the DRV_SPI_TRANSFER_SETUP parameters for the selected client of the driver dynamically For single client scenario if GPIO has to be used for chip select then calling this API with appropriate GPIO pin information becomes mandatory For multi client scenario where different clients need different setup like baud rate clock settings chip select etc then also calling this API is mandatory Note that all the elements of setup structure must be filled appropriately before using this API ",
							" Preconditions DRV_SPI_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine *setup A structure containing the new configuration settings ",
							" Returns None ",
							" Example // mySPIHandle is the handle returned by the DRV_SPI_Open function DRV_SPI_TRANSFER_SETUP setup ; setup  baudRateInHz =  10000000 ; setup  clockPhase = DRV_SPI_CLOCK_PHASE_TRAILING_EDGE ; setup  clockPolarity = DRV_SPI_CLOCK_POLARITY_IDLE_LOW ; setup  dataBits = DRV_SPI_DATA_BITS_16 ; setup  chipSelect = SYS_PORT_PIN_PC5 ; setup  csPolarity = DRV_SPI_CS_POLARITY_ACTIVE_LOW ; DRV_SPI_TransferSetup ( mySPIHandle    setup ) ; ",
							" Remarks None ",
							" DRV_SPI_Lock Function ",
							" C bool DRV_SPI_Lock (  const DRV_HANDLE handle  bool lock ) ",
							" Summary Use this API to lock the SPI driver for exclusive use by a client ",
							" Description This function provides exclusive access to the calling SPI driver client Once a client acquires exclusive access SPI read/write requests from other clients are not accepted by the driver until the client gives up the exclusive use of the SPI driver ",
							" Precondition DRV_SPI_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle Handle of the communication channel as returned by the DRV_SPI_Open function lock true : lock the spi driver false : unlock the spi driver ",
							" Returns true - driver instance successfully acquired for exclusive access false - failed to acquire driver instance in exclusive mode ",
							" Example // mySPIHandle is the handle returned by the DRV_SPI_Open function bool DRV_SPI_Lock ( mySPIHandle  true ) ;  ",
							" Remarks When a client successfully acquires the lock for the first time the lock count is set to one Every time a client relocks this driver instance the lock count is incremented by one Each time the client unlocks the driver instance the lock count is decremented by one When the lock count reaches zero the driver instance becomes available for other clients If a client attempts to unlock the driver instance that it has not locked then the lock count is not decremented This API must not be called from an interrupt handler as it may block on a RTOS mutex ",
							" DRV_SPI_WriteReadTransferAdd Function ",
							" C void DRV_SPI_WriteReadTransferAdd (  const DRV_HANDLE handle   void * pTransmitData  size_t txSize   void * pReceiveData  size_t rxSize  DRV_SPI_TRANSFER_HANDLE *  const transferHandle ) ; ",
							" Summary Queues a write-read transfer operation ",
							" Description This function schedules a non-blocking write-read operation The function returns with a valid transfer handle in the transferHandle argument if the request was scheduled successfully The function adds the request to the instance specific software queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified This API will write txSize and at the same time counting of rxSize to be read will start If user wants 'n' bytes to be read after txSize has been written then he should keep rxSize value as 'txSize + n' The function returns DRV_SPI_TRANSFER_HANDLE_INVALID in the transferHandle argument: if neither of the transmit or receive arguments are valid if the transfer handle is NULL if the queue size is full or queue depth is insufficient if the driver handle is invalid If the requesting client registered an event callback with the driver the driver will issue a DRV_SPI_TRANSFER_EVENT_COMPLETE event if the transfer was processed successfully or DRV_SPI_TRANSFER_EVENT_ERROR event if the transfer was not processed successfully ",
							" Precondition DRV_SPI_Open must have been called to obtain a valid opened device handle DRV_SPI_TransferSetup must have been called if GPIO pin has to be used for chip select or any of the setup parameters has to be changed dynamically ",
							" Parameters Param Description handle Handle of the communication channel as returned by the DRV_SPI_Open function *pTransmitData Pointer to the data which has to be transmitted If it is NULL that means only data receiving is expected txSize Number of bytes to be transmitted The size must be specified in terms of the SPI data width For example if the data width is 8-bits and if 10 bytes are being transmitted then the txSize must be set to 10 If the data width is 16-bits then transmitting 10 bytes requires specifying the txSize as 10 (meaning 10 16-bit words) *pReceiveData Pointer to the location where received data has to be stored It is user's responsibility to ensure pointed location has sufficient memory to store the read data if it is NULL that means only data transmission is expected rxSize Number of bytes to be received The size must be specified in terms of the SPI data width For example if the data width is 8-bits and if 10 bytes are being received then the rxSize must be set to 10 If the data width is 16-bits then receiving 10 bytes requires specifying the rxSize as 10 (meaning 10 16-bit words) If \"n\" number of bytes has to be received AFTER transmitting \"m\" number of bytes then \"txSize\" should be set as \"m\" and \"rxSize\" should be set as \"m+n\" transferHandle Handle which is returned by transfer add function ",
							" Returns None ",
							" Example MY_APP_OBJ myAppObj ; uint8_t myTxBuffer [ MY_TX_BUFFER_SIZE ] ; uint8_t myRxBuffer [ MY_RX_BUFFER_SIZE ] ; DRV_SPI_TRANSFER_HANDLE transferHandle ;  // mySPIHandle is the handle returned by the DRV_SPI_Open function  DRV_SPI_WriteReadTransferAdd ( mySPIhandle  myTxBuffer  MY_TX_BUFFER_SIZE  myRxBuffer  MY_RX_BUFFER_SIZE    transferHandle ) ;  if ( transferHandle == DRV_SPI_TRANSFER_HANDLE_INVALID )  {  // Error handling here  }  // Event is received when the transfer is processed ",
							" Remarks This function can be called from within the SPI Driver Transfer Event Handler that is registered by the client It should not be called in the event handler associated with another SPI driver instance or event handler of any other peripheral It should not be called directly in any ISR ",
							" DRV_SPI_WriteTransferAdd Function ",
							" C void DRV_SPI_WriteTransferAdd (  const DRV_HANDLE handle   void * pTransmitData  size_t txSize  DRV_SPI_TRANSFER_HANDLE *  const transferHandle ) ; ",
							" Summary Queues a write operation ",
							" Description This function schedules a non-blocking write operation The function returns with a valid transfer handle in the transferHandle argument if the request was scheduled successfully The function adds the request to the instance specific software queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified This API will write txSize bytes of data and the dummy data received will be ignored The function returns DRV_SPI_TRANSFER_HANDLE_INVALID in the transferHandle argument: if pTransmitData is NULL if txSize is zero if the transfer handle is NULL if the queue size is full or queue depth is insufficient if the driver handle is invalid If the requesting client registered an event callback with the driver the driver will issue a DRV_SPI_TRANSFER_EVENT_COMPLETE event if the transfer was processed successfully or DRV_SPI_TRANSFER_EVENT_ERROR event if the transfer was not processed successfully ",
							" Precondition DRV_SPI_Open must have been called to obtain a valid opened device handle DRV_SPI_TransferSetup must have been called if GPIO pin has to be used for chip select or any of the setup parameters has to be changed dynamically ",
							" Parameters Param Description handle Handle of the communication channel as returned by the DRV_SPI_Open function *pTransmitData- Pointer to the data which has to be transmitted txSize Number of bytes to be transmitted The size must be specified in terms of the SPI data width For example if the data width is 8-bits and if 10 bytes are being transmitted then the txSize must be set to 10 If the data width is 16-bits then transmitting 10 bytes requires specifying the txSize as 10 (meaning 10 16-bit words) transferHandle Handle which is returned by transfer add function ",
							" Returns None ",
							" Example MY_APP_OBJ myAppObj ; uint8_t myTxBuffer [ MY_TX_BUFFER_SIZE ] ; DRV_SPI_TRANSFER_HANDLE transferHandle ;  // mySPIHandle is the handle returned by the DRV_SPI_Open function  DRV_SPI_WriteTransferAdd ( mySPIhandle  myTxBuffer  MY_TX_BUFFER_SIZE    transferHandle ) ;  if ( transferHandle == DRV_SPI_TRANSFER_HANDLE_INVALID )  {  // Error handling here  }  // Event is received when the transfer is processed ",
							" Remarks This function can be called from within the SPI Driver Transfer Event Handler that is registered by the client It should NOT be called in the event handler associated with another SPI driver instance or event handler of any other peripheral It should not be called directly in any ISR ",
							" DRV_SPI_ReadTransferAdd Function ",
							" C void DRV_SPI_ReadTransferAdd (  const DRV_HANDLE handle   void * pReceiveData  size_t rxSize  DRV_SPI_TRANSFER_HANDLE *  const transferHandle ) ; ",
							" Summary Queues a read operation ",
							" Description This function schedules a non-blocking read operation The function returns with a valid transfer handle in the transferHandle argument if the request was scheduled successfully The function adds the request to the instance specific software queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified This API will write rxSize bytes of dummy data and will read rxSize bytes of data in the memory location pointed by pReceiveData The function returns DRV_SPI_TRANSFER_HANDLE_INVALID in the transferHandle argument: if pReceiveData is NULL if rxSize is zero if the transfer handle is NULL if the queue size is full or queue depth is insufficient if the driver handle is invalid If the requesting client registered an event callback with the driver the driver will issue a DRV_SPI_TRANSFER_EVENT_COMPLETE event if the transfer was processed successfully or DRV_SPI_TRANSFER_EVENT_ERROR event if the transfer was not processed successfully ",
							" Precondition DRV_SPI_Open must have been called to obtain a valid opened device handle DRV_SPI_TransferSetup must have been called if GPIO pin has to be used for chip select or any of the setup parameters has to be changed dynamically ",
							" Parameters Param Description handle Handle of the communication channel as returned by the DRV_SPI_Open function *pReceiveData Pointer to the location where received data has to be stored It is user's responsibility to ensure pointed location has sufficient memory to store the read data rxSize Number of bytes to be received The size must be specified in terms of the SPI data width For example if the data width is 8-bits and if 10 bytes are being received then the rxSize must be set to 10 If the data width is 16-bits then receiving 10 bytes requires specifying the rxSize as 10 (meaning 10 16-bit words) transferHandle Handle which is returned by transfer add function ",
							" Returns None ",
							" Example MY_APP_OBJ myAppObj ; uint8_t myRxBuffer [ MY_RX_BUFFER_SIZE ] ; DRV_SPI_TRANSFER_HANDLE transferHandle ;  // mySPIHandle is the handle returned by the DRV_SPI_Open function  DRV_SPI_ReadTransferAdd ( mySPIhandle  myRxBuffer  MY_RX_BUFFER_SIZE    transferHandle ) ;  if ( transferHandle == DRV_SPI_TRANSFER_HANDLE_INVALID )  {  // Error handling here  }  // Event is received when the transfer is processed ",
							" Remarks This function can be called from within the SPI Driver Transfer Event Handler that is registered by the client It should not be called in the event handler associated with another SPI driver instance or event handler of any other peripheral It should not be called directly in any ISR ",
							" DRV_SPI_TransferEventHandlerSet Function ",
							" C void DRV_SPI_TransferEventHandlerSet (  const DRV_HANDLE handle   const DRV_SPI_TRANSFER_EVENT_HANDLER eventHandler   const uintptr_t context ) ",
							" Summary Allows a client to set a transfer event handling function for the driver to call back when queued transfer has finished ",
							" Description This function allows a client to register a transfer event handling function with the driver to call back when queued transfer has finished When a client calls either the DRV_SPI_ReadTransferAdd or DRV_SPI_WriteTransferAdd or DRV_SPI_WriteReadTransferAdd function it is provided with a handle identifying the transfer request that was added to the driver's queue The driver will pass this handle back to the client by calling \"eventHandler\" function when the transfer has completed The event handler should be set before the client performs any \"transfer add\" operations that could generate events The event handler once set persists until the client closes the driver or sets another event handler (which could be a \"NULL\" pointer to indicate no callback) ",
							" Precondition DRV_SPI_Open must have been called to obtain a valid open instance handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine eventHandler Pointer to the event handler function context The value of parameter will be passed back to the client unchanged when the eventHandler function is called It can be used to identify any client specific data object that identifies the instance of the client module (for example it may be a pointer to the client module's state structure) ",
							" Returns None ",
							" Example // myAppObj is an application specific state data object MY_APP_OBJ myAppObj ; uint8_t myTxBuffer [ MY_TX_BUFFER_SIZE ] ; uint8_t myRxBuffer [ MY_RX_BUFFER_SIZE ] ; DRV_SPI_TRANSFER_HANDLE transferHandle ;  // Event is received when the transfer is completed  void  APP_SPITransferEventHandler ( DRV_SPI_TRANSFER_EVENT event  DRV_SPI_TRANSFER_HANDLE handle  uintptr_t context )  {  // The context handle was set to an application specific  // object It is now retrievable easily in the event handler MY_APP_OBJ myAppObj =  ( MY_APP_OBJ * ) context ;  switch ( event )  {  case DRV_SPI_TRANSFER_EVENT_COMPLETE :  {  // This means the data was transferred  break ;  }  case DRV_SPI_TRANSFER_EVENT_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  }  // mySPIHandle is the handle returned by the DRV_SPI_Open function  // Client registers an event handler with driver This is done once  DRV_SPI_TransferEventHandlerSet ( mySPIHandle  APP_SPITransferEventHandler   ( uintptr_t )  myAppObj ) ;  DRV_SPI_WriteReadTransferAdd ( mySPIhandle  myTxBuffer  MY_TX_BUFFER_SIZE  myRxBuffer  MY_RX_BUFFER_SIZE    transferHandle ) ;  if ( transferHandle == DRV_SPI_TRANSFER_HANDLE_INVALID )  {  // Error handling here  } ",
							" Remarks If the client does not want to be notified when the queued transfer request has completed it does not need to register a callback ",
							" DRV_SPI_TransferStatusGet Function ",
							" C DRV_SPI_TRANSFER_EVENT DRV_SPI_TransferStatusGet ( const DRV_SPI_TRANSFER_HANDLE transferHandle ) ",
							" Summary Returns transfer add request status ",
							" Description This function can be used to poll the status of the queued transfer request if the application doesn't prefer to use the event handler (callback) function to get notified ",
							" Precondition Either DRV_SPI_ReadTransferAdd or DRV_SPI_WriteTransferAdd or DRV_SPI_WriteReadTransferAdd function must have been called and a valid transfer handle must have been returned ",
							" Parameters Param Description transferHandle Handle of the transfer request of which status has to be obtained ",
							" Returns One of the elements of the enum \"DRV_SPI_TRANSFER_EVENT\" ",
							" Example // myAppObj is an application specific object MY_APP_OBJ myAppObj ; uint8_t mybuffer [ MY_BUFFER_SIZE ] ; DRV_SPI_TRANSFER_HANDLE transferHandle ; DRV_SPI_TRANSFER_EVENT event ;  // mySPIHandle is the handle returned by the DRV_SPI_Open function  DRV_SPI_ReadTransferAdd ( mySPIhandle  myBuffer  MY_RECEIVE_SIZE    transferHandle ) ;  if ( transferHandle == DRV_SPI_TRANSFER_HANDLE_INVALID )  {  // Error handling here  }  //Check the status of the transfer request  //This call can be used to wait until the transfer is completed event =  DRV_SPI_TransferStatusGet ( transferHandle ) ; ",
							" Remarks None ",
							" DRV_SPI_WriteTransfer Function ",
							" C void DRV_SPI_WriteTransfer (  const DRV_HANDLE handle   void * pTransmitData  size_t txSize ) ; ",
							" Summary This is a blocking function that transmits data over SPI ",
							" Description This function does a blocking write operation The function blocks till the data transmit is complete Function will return true if the transmit is successful or false in case of an error The failure will occur for the following reasons: if the handle is invalid if the pointer to the transmit buffer is NULL if the transmit size is 0 ",
							" Precondition DRV_SPI_Open must have been called to obtain a valid opened device handle DRV_SPI_TransferSetup must have been called if GPIO pin has to be used for chip select or any of the setup parameters has to be changed dynamically ",
							" Parameters Param Description handle Handle of the communication channel as returned by the DRV_SPI_Open function *pTransmitData Pointer to the data which has to be transmitted txSize Number of bytes to be transmitted The size must be specified in terms of the SPI data width For example if the data width is 8-bits and if 10 bytes are being transmitted then the txSize must be set to 10 If the data width is 16-bits then transmitting 10 bytes requires specifying the txSize as 10 (meaning 10 16-bit words) ",
							" Returns true - transfer is successful false - error has occurred ",
							" Example MY_APP_OBJ myAppObj ; uint8_t myTxBuffer [ MY_TX_BUFFER_SIZE ] ;  // mySPIHandle is the handle returned by the DRV_SPI_Open function  if  ( DRV_SPI_WriteTransfer ( mySPIhandle  myTxBuffer  MY_TX_BUFFER_SIZE )  == false )  {  // Handle error here  } ",
							" Remarks This function is thread safe in a RTOS application This function should not be called from an interrupt context ",
							" DRV_SPI_ReadTransfer Function ",
							" C void DRV_SPI_ReadTransfer (  const DRV_HANDLE handle   void * pReceiveData  size_t rxSize ) ; ",
							" Summary This is a blocking function that receives data over SPI ",
							" Description This function does a blocking read operation The function blocks till the data receive is complete Function will return true if the receive is successful or false in case of an error The failure will occur for the following reasons: if the handle is invalid if the pointer to the receive buffer is NULL if the receive size is 0 ",
							" Precondition DRV_SPI_Open must have been called to obtain a valid opened device handle DRV_SPI_TransferSetup must have been called if GPIO pin has to be used for chip select or any of the setup parameters has to be changed dynamically ",
							" Parameters Param Description handle Handle of the communication channel as returned by the DRV_SPI_Open function *pReceiveData Pointer to the buffer where the data is to be received rxSize Number of bytes to be received The size must be specified in terms of the SPI data width For example if the data width is 8-bits and if 10 bytes are being received then the rxSize must be set to 10 If the data width is 16-bits then receiving 10 bytes requires specifying the rxSize as 10 (meaning 10 16-bit words) ",
							" Returns true - receive is successful false - error has occurred ",
							" Example MY_APP_OBJ myAppObj ; uint8_t myRxBuffer [ MY_RX_BUFFER_SIZE ] ;  // mySPIHandle is the handle returned by the DRV_SPI_Open function  if  ( DRV_SPI_ReadTransfer ( mySPIhandle  myRxBuffer  MY_RX_BUFFER_SIZE )  == false )  {  // Handle error here  } ",
							" Remarks This function is thread safe in a RTOS application This function should not be called from an interrupt context ",
							" DRV_SPI_WriteReadTransfer Function ",
							" C void DRV_SPI_WriteReadTransfer (  const DRV_HANDLE handle   void * pTransmitData  size_t txSize   void * pReceiveData  size_t rxSize ) ; ",
							" Summary This is a blocking function that transmits and receives data over SPI ",
							" Description This function does a blocking write-read operation The function blocks till the data receive is complete Function will return true if the receive is successful or false in case of an error The failure will occur for the following reasons: if the handle is invalid if the transmit size is non-zero and pointer to the transmit buffer is NULL if the receive size is non-zero and pointer to the receive buffer is NULL ",
							" Precondition DRV_SPI_Open must have been called to obtain a valid opened device handle DRV_SPI_TransferSetup must have been called if GPIO pin has to be used for chip select or any of the setup parameters has to be changed dynamically ",
							" Parameters Param Description handle Handle of the communication channel as returned by the DRV_SPI_Open function *pTransmitData Pointer to the data which has to be transmitted If it is NULL that means only data receiving is expected txSize Number of bytes to be transmitted The size must be specified in terms of the SPI data width For example if the data width is 8-bits and if 10 bytes are being transmitted then the txSize must be set to 10 If the data width is 16-bits then transmitting 10 bytes requires specifying the txSize as 10 (meaning 10 16-bit words) *pReceiveData Pointer to the buffer where the data is to be received If it is NULL that means only data transmission is expected rxSize Number of bytes to be received The size must be specified in terms of the SPI data width For example if the data width is 8-bits and if 10 bytes are being received then the rxSize must be set to 10 If the data width is 16-bits then receiving 10 bytes requires specifying the rxSize as 10 (meaning 10 16-bit words) If \"n\" number of bytes has to be received AFTER transmitting \"m\" number of bytes then \"txSize\" should be set as \"m\" and \"rxSize\" should be set as \"m+n\" ",
							" Returns true - write-read is successful false - error has occurred ",
							" Example MY_APP_OBJ myAppObj ; uint8_t myTxBuffer [ MY_TX_BUFFER_SIZE ] ; uint8_t myRxBuffer [ MY_RX_BUFFER_SIZE ] ;  // mySPIHandle is the handle returned by the DRV_SPI_Open function  if  ( DRV_SPI_WriteReadTransfer ( mySPIhandle  myTxBuffer  MY_TX_BUFFER_SIZE  myRxBuffer  MY_RX_BUFFER_SIZE )  == false )  {  // Handle error here  }  ",
							" Remarks This function is thread safe in a RTOS application This function should not be called from an interrupt context ",
							" DRV_SPI_TRANSFER_HANDLE Typedef ",
							" C typedef uintptr_t DRV_SPI_TRANSFER_HANDLE ;  ",
							" Summary Handle identifying the transfer request queued ",
							" Description A transfer handle value is returned by a call to the DRV_SPI_ReadTransferAdd or DRV_SPI_WriteTransferAdd or DRV_SPI_WriteReadTransferAdd functions This handle is associated with the transfer request passed into the function and it allows the application to track the completion of the transfer request The transfer handle value returned from the \"transfer add\" function is returned back to the client by the \"event handler callback\" function registered with the driver This handle can also be used to poll the transfer completion status using DRV_SPI_TransferStatusGet API The transfer handle assigned to a client request expires when a new transfer request is made after the completion of the current request ",
							" Remarks None ",
							" DRV_SPI_TRANSFER_HANDLE_INVALID Macro ",
							" C # define DRV_SPI_TRANSFER_HANDLE_INVALID ((DRV_SPI_TRANSFER_HANDLE)(-1))  ",
							" Summary Definition of an invalid transfer handle ",
							" Description This is the definition of an invalid transfer handle An invalid transfer handle is returned by DRV_SPI_WriteReadTransferAdd or DRV_SPI_WriteTransferAdd or DRV_SPI_ReadTransferAdd function if the buffer add request was not successful It can happen due to invalid arguments or lack of space in the queue ",
							" Remarks None ",
							" DRV_SPI_TRANSFER_EVENT Enum ",
							" C typedef  enum  {  /* Transfer request is pending */ DRV_SPI_TRANSFER_EVENT_PENDING   /* All data were transfered successfully */ DRV_SPI_TRANSFER_EVENT_COMPLETE   /* Transfer Handle given is expired It means transfer is completed but with or without error is not known In case of Non-DMA transfer since there is no possibility of error it can be assumed same as DRV_SPI_TRANSFER_EVENT_COMPLETE */ DRV_SPI_TRANSFER_EVENT_HANDLE_EXPIRED   /* There was an error while processing transfer request */ DRV_SPI_TRANSFER_EVENT_ERROR   /* Transfer Handle given is invalid */ DRV_SPI_TRANSFER_EVENT_HANDLE_INVALID } DRV_SPI_TRANSFER_EVENT ;  ",
							" Summary Identifies the possible events that can result from a transfer add request ",
							" Description This enumeration identifies the possible events that can result from a transfer add request caused by the client calling either DRV_SPI_ReadTransferAdd or DRV_SPI_WriteTransferAdd or DRV_SPI_WriteReadTransferAdd functions ",
							" Remarks Either DRV_SPI_TRANSFER_EVENT_COMPLETE or DRV_SPI_TRANSFER_EVENT_ERROR is passed in the \"event\" parameter of the event handling callback function that the client registered with the driver by calling the DRV_SPI_TransferEventHandlerSet function when a transfer request is completed When status polling is used any one of these events is returned by DRV_SPI_TransferStatusGet function ",
							" DRV_SPI_TRANSFER_EVENT_HANDLER Typedef ",
							" C typedef  void  ( * DRV_SPI_TRANSFER_EVENT_HANDLER ) ( DRV_SPI_TRANSFER_EVENT event  DRV_SPI_TRANSFER_HANDLE transferHandle  uintptr_t context ) ;  ",
							" Summary Pointer to a SPI Driver Transfer Event handler function ",
							" Description This data type defines the required function signature for the SPI driver transfer event handling callback function A client must register a pointer using the transfer event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver The parameters and return values are described here and a partial example implementation is provided ",
							" Parameters Param Description event Identifies the type of event transferHandle Handle identifying the transfer to which the event relates context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Example void  APP_MyTransferEventHandler ( DRV_SPI_TRANSFER_EVENT event  DRV_SPI_TRANSFER_HANDLE transferHandle  uintptr_t context )  { MY_APP_DATA_STRUCT pAppData =  ( MY_APP_DATA_STRUCT ) context ;  switch ( event )  {  case DRV_SPI_TRANSFER_EVENT_COMPLETE :  {  // Handle the completed transfer  break ;  }  case DRV_SPI_TRANSFER_EVENT_ERROR :  default :  {  // Handle error  break ;  }  }  } ",
							" Remarks If the event is DRV_SPI_TRANSFER_EVENT_COMPLETE it means that the data was transferred successfully If the event is DRV_SPI_TRANSFER_EVENT_ERROR it means that the data was not transferred successfully The transferHandle parameter contains the transfer handle of the transfer request that is associated with the event The context parameter contains the a handle to the client context provided at the time the event handling function was registered using the DRV_SPI_TransferEventHandlerSet function This context handle value is passed back to the client as the \"context\" parameter It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) of the client that made the transfer add request The event handler function executes in interrupt context of the peripheral Hence it is recommended of the application to not perform process intensive or blocking operations with in this function The DRV_SPI_ReadTransferAdd DRV_SPI_WriteTransferAdd and DRV_SPI_WriteReadTransferAdd functions can be called in the event handler to add a transfer request to the driver queue These functions can only be called to add transfers to the driver instance whose event handler is running For example SPI2 driver transfer requests cannot be added in SPI1 driver event handler Similarly SPIx transfer requests should not be added in event handler of any other peripheral ",
							" DRV_SPI_CLOCK_PHASE Enum ",
							" C typedef  enum  {  /* Input data is valid on clock trailing edge and output data is ready on leading edge */ DRV_SPI_CLOCK_PHASE_VALID_TRAILING_EDGE   /* Input data is valid on clock leading edge and output data is ready on trailing edge */ DRV_SPI_CLOCK_PHASE_VALID_LEADING_EDGE } DRV_SPI_CLOCK_PHASE ;  ",
							" Summary Identifies SPI Clock Phase Options ",
							" Description This enumeration identifies possible SPI Clock Phase Options ",
							" Remarks None ",
							" DRV_SPI_CLOCK_POLARITY Enum ",
							" C typedef  enum  { DRV_SPI_CLOCK_POLARITY_IDLE_LOW  DRV_SPI_CLOCK_POLARITY_IDLE_HIGH } DRV_SPI_CLOCK_POLARITY ;  ",
							" Summary Identifies SPI Clock Polarity Options ",
							" Description This enumeration identifies possible SPI Clock Polarity Options ",
							" Remarks None ",
							" DRV_SPI_DATA_BITS Enum ",
							" C typedef  enum  { DRV_SPI_DATA_BITS_8  DRV_SPI_DATA_BITS_9  DRV_SPI_DATA_BITS_10  DRV_SPI_DATA_BITS_11  DRV_SPI_DATA_BITS_12  DRV_SPI_DATA_BITS_13  DRV_SPI_DATA_BITS_14  DRV_SPI_DATA_BITS_15  DRV_SPI_DATA_BITS_16 } DRV_SPI_DATA_BITS ;  ",
							" Summary Identifies SPI bits per transfer ",
							" Description This enumeration identifies number of bits per SPI transfer ",
							" Remarks For 9 to 15bit modes data should be right aligned in the 16 bit memory location ",
							" DRV_SPI_CS_POLARITY Enum ",
							" C typedef  enum  { DRV_SPI_CS_POLARITY_ACTIVE_LOW  DRV_SPI_CS_POLARITY_ACTIVE_HIGH } DRV_SPI_CS_POLARITY ;  ",
							" Summary Identifies SPI Chip Select Polarity Options ",
							" Description This enumeration identifies possible SPI Chip Select Polarity Options ",
							" Remarks None ",
							" Summary Defines the data required to setup the SPI transfer ",
							" Description This data type defines the data required to setup the SPI transfer The data is passed to the DRV_SPI_TransferSetup API to setup the SPI peripheral settings dynamically ",
							" Remarks None ",
							" USART Driver The USART driver provides application ready routines to read and write data from/to the USART peripheral Key Features of USART Driver: Supports multi-instance and multi-client mode Provides data transfer events It works in both Asynchronous and Synchronous modes of operation Features thread-safe functions for use in RTOS applications Supports DMA transfers ",
							" How the Library Works The USART driver library is a multi-client multi-instance buffer queue model based driver interface Abstraction Model The following diagram illustrates the model used by the USART Driver Note: Queue is not present in Synchronous mode of the driver drv_usart_abstraction_model Working Flow The USART driver is built on top of the USART/UART peripheral library The peripheral library must be configured to run in non-blocking (interrupts enabled) mode The USART driver can be used with DMA for data Transfer/Receive The USART driver is capable of supporting multiple instances of the USART/UART peripheral Also there can be multiple clients to a USART driver instance USART driver is capable of working in both Asynchronous and Synchronous modes USART driver in Asynchronous mode Asynchronous mode APIs are non-blocking in nature These APIs submit a request and return back to the application Typically if there are no on-going or pending requests in the driver's transfer queue then the transfer is started by the API and completed from the peripheral interrupt If there is an on-going transfer or one or more requests pending in the driver's transfer queue then the request is added to the queue and executed when all the pending requests are complete The size of the transfer queue is configurable using MCC based on application needs The transfer APIs provide a transfer handle back to the application If the driver was unable to accept the request then the transfer handle will be set to NULL This usually happens if the transfer queue is full or if invalid argruments are passed to the API Application must check the value of the transfer handle to ensure the request was accepted successfully Transfer handle can be used to identify/track the request Application can either register a callback to get notified when the transfer is complete or poll the status of the request by calling the DRV_USART_BufferStatusGet() API Asynchronous mode APIs are available in both bare-metal and RTOS mode USART driver in Synchronous mode Synchronous mode APIs are blocking in nature These APIs block until the transfer/request is complete Synchronous mode APIs are only supported in RTOS mode These APIs initate the transfer and then block on a semaphore while the transfer is in progress thereby allowing other ready tasks to run Once the transfer is complete the semaphore is given (from the peripheral interrupt's context) thereby unblocking the calling task The return value usually provides the status of the transfer ",
							" Using The Library The USART driver builds on top of the USART or UART peripheral library (PLIB) and provides write read APIs in blocking and non-blocking modes In asynchronous (non-blocking) mode application can either register a callback to get notified once the data transfer is complete or can poll the status of the data transfer using the status APIs In asynchronous mode application can queue more than one transmit/receive requests without waiting for the previous request to be completed The number of transmit/receive requests that can be queued depends on the depth of the transfer queue configured using the MHC The asynchronous mode is supported in both bare-metal and RTOS environment The synchronous (blocking) mode of the driver is supported only in an RTOS environment The synchronous mode of the driver does not support callback or queuing multiple requests This is because the implementation is blocking in nature Supports DMA for Transfer/Receive in both asynchronous and synchronous mode Example application to Read and Write from UART console in Asynchronous mode # define APP_DATA_SIZE 1 APP_DATA appData ;  static  const  char messageBuffer [ ]  =  \"*** USART Driver Echo Demo Application *** r n\"  \"*** Type a character and observe it echo back *** r n\" ;  static  void  APP_USARTBufferEventHandler ( DRV_USART_BUFFER_EVENT bufferEvent  DRV_USART_BUFFER_HANDLE bufferHandle  uintptr_t context )  {  switch ( bufferEvent )  {  case DRV_USART_BUFFER_EVENT_COMPLETE :  { appData  transferStatus = true ;  break ;  }  case DRV_USART_BUFFER_EVENT_ERROR :  { appData  state = APP_STATE_ERROR ;  break ;  }  default :  {  break ;  }  }  }  void APP_Initialize (  void  )  {  /* Place the App state machine in its initial state */ appData  state = APP_STATE_INIT ; appData  transferStatus = false ; appData  usartHandle = DRV_HANDLE_INVALID ; appData  bufferHandle = DRV_USART_BUFFER_HANDLE_INVALID ;  }  void APP_Tasks (  void  )  {  /* Check the application's current state */  switch  ( appData  state )  {  /* Application's initial state */  case APP_STATE_INIT :  { appData  usartHandle =  DRV_USART_Open ( DRV_USART_INDEX_0  DRV_IO_INTENT_READWRITE ) ;  if  ( appData  usartHandle = DRV_HANDLE_INVALID )  {  DRV_USART_BufferEventHandlerSet ( appData  usartHandle  APP_USARTBufferEventHandler   0 ) ; appData  state = APP_STATE_TRANSMIT_MESSAGE ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_TRANSMIT_MESSAGE :  {  DRV_USART_WriteBufferAdd ( appData  usartHandle   ( void * ) messageBuffer   strlen ( messageBuffer )    appData  bufferHandle ) ;  if  ( appData  bufferHandle = DRV_USART_BUFFER_HANDLE_INVALID )  { appData  state = APP_STATE_WAIT_MESSAGE_TRANSFER_COMPLETE ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WAIT_MESSAGE_TRANSFER_COMPLETE :  {  if ( appData  transferStatus == true )  { appData  transferStatus = false ; appData  state = APP_STATE_RECEIVE_DATA ;  }  break ;  }  case APP_STATE_RECEIVE_DATA :  {  DRV_USART_ReadBufferAdd ( appData  usartHandle  appData  readBuffer  APP_DATA_SIZE    appData  bufferHandle ) ;  if  ( appData  bufferHandle = DRV_USART_BUFFER_HANDLE_INVALID )  { appData  state = APP_STATE_WAIT_RECEIVE_COMPLETE ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WAIT_RECEIVE_COMPLETE :  {  if ( appData  transferStatus == true )  { appData  transferStatus = false ; appData  state = APP_STATE_TRANSMIT_DATA ;  }  break ;  }  case APP_STATE_TRANSMIT_DATA :  {  /* Echo the received data back on the terminal */  DRV_USART_WriteBufferAdd ( appData  usartHandle  appData  readBuffer  APP_DATA_SIZE    appData  bufferHandle ) ;  if  ( appData  bufferHandle = DRV_USART_BUFFER_HANDLE_INVALID )  { appData  state = APP_STATE_WAIT_TRANSMIT_COMPLETE ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WAIT_TRANSMIT_COMPLETE :  {  if ( appData  transferStatus == true )  { appData  transferStatus = false ;  LED_TOGGLE ( ) ; appData  state = APP_STATE_RECEIVE_DATA ;  }  break ;  }  case APP_STATE_ERROR :  {  LED_OFF ( ) ; appData  state = APP_STATE_IDLE ;  break ;  }  case APP_STATE_IDLE :  default :  {  break ;  }  }  } ",
							" Configuring The Library USART Driver Library should be configured via MHC The following figures show the MHC configuration window for USART driver and brief description Common User Configuration for all Instances Driver Mode: Allows User to select the mode of driver(Asynchronous or Synchronous) This setting is common for all the instances Instance Specific User Configurations USART Driver Configuration in Asynchronous Mode drv_usart_mhc_config_async USART Driver Configuration in Synchronous Mode drv_usart_mhc_config_sync PLIB Used: Indicates the underlying USART/UART PLIB used by the driver Number Of Clients: The total number of clients that can open the given USART driver instance Transfer Queue Size: Indicates the size of the transmit/receive queue for the given USART/UART driver instance Available only in Asynchronous mode of Operations Use DMA for Transmit Enables DMA For transmitting the data DMA Channel For Transmit: DMA Channel for transmission is automatically allocated in DMA configurations Use DMA for Receive Enables DMA For Receiving the data DMA Channel For Receive: DMA Channel for Receiving is automatically allocated in DMA configurations ",
							" Library Interface USART driver library provides the following interfaces: Functions Name Description Asynchronous Mode Synchronous Mode DRV_USART_Initialize Initializes the USART instance for the specified driver index Yes Yes DRV_USART_Status Gets the current status of the USART driver module Yes Yes DRV_USART_Open Opens the specified USART driver instance and returns a handle to it Yes Yes DRV_USART_Close Closes an opened-instance of the USART driver Yes Yes DRV_USART_ErrorGet Gets the USART hardware errors associated with the transfer request Yes Yes DRV_USART_SerialSetup Sets the USART serial communication settings dynamically Yes Yes DRV_USART_BufferEventHandlerSet Allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished Yes No DRV_USART_WriteBufferAdd Queues a write operation Yes No DRV_USART_ReadBufferAdd Queues a read operation Yes No DRV_USART_BufferCompletedBytesGet Returns the number of bytes that have been processed for the specified buffer request Yes No DRV_USART_BufferStatusGet Returns the transmit/receive request status Yes No DRV_USART_WriteQueuePurge Removes all write requests from the queue for the given client This API does not abort the on-going write transfer Yes No DRV_USART_ReadQueuePurge Removes all buffer requests from the queue for the given client and also aborts the on-going read request Yes No DRV_USART_ReadAbort Aborts an on-going read request Yes No DRV_USART_WriteBuffer This is a blocking function that writes data over USART No Yes DRV_USART_ReadBuffer This is a blocking function that reads data over USART No Yes Data types and constants Name Type Description DRV_USART_BUFFER_HANDLE Typedef Handle identifying a read or write buffer passed to the driver DRV_USART_BUFFER_HANDLE_INVALID Macro Definition of an invalid buffer handle DRV_USART_BUFFER_EVENT Enum Identifies the possible events that can result from a buffer add request DRV_USART_BUFFER_EVENT_HANDLER Typedef Pointer to a USART Driver Buffer Event handler function DRV_USART_ERROR Enum Defines the different types of errors for USART driver DRV_USART_INIT Struct Defines the data required to initialize the USART driver DRV_USART_SERIAL_SETUP Struct Defines the data required to dynamically set the serial settings ",
							" DRV_USART_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_USART_Initialize (  const SYS_MODULE_INDEX index   const SYS_MODULE_INIT *  const init ) ",
							" Summary Initializes the USART instance for the specified driver index ",
							" Description This routine initializes the USART driver instance for the specified driver index making it ready for clients to open and use it The initialization data is specified by the init parameter The initialization may fail if the number of driver objects allocated are insufficient or if the specified driver instance is already initialized The driver instance index is independent of the USART module ID For example driver instance 0 can be assigned to USART2 ",
							" Precondition None ",
							" Parameters Param Description index Identifier for the instance to be initialized init Pointer to the init data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise returns SYS_MODULE_OBJ_INVALID ",
							" Example // The following code snippet shows an example USART driver initialization SYS_MODULE_OBJ objectHandle ;  const DRV_USART_PLIB_INTERFACE drvUsart0PlibAPI =  {   readCallbackRegister =  ( DRV_USART_PLIB_READ_CALLBACK_REG ) USART1_ReadCallbackRegister    read =  ( DRV_USART_PLIB_READ ) USART1_Read    readIsBusy =  ( DRV_USART_PLIB_READ_IS_BUSY ) USART1_ReadIsBusy    readCountGet =  ( DRV_USART_PLIB_READ_COUNT_GET ) USART1_ReadCountGet    writeCallbackRegister =  ( DRV_USART_PLIB_WRITE_CALLBACK_REG ) USART1_WriteCallbackRegister    write =  ( DRV_USART_PLIB_WRITE ) USART1_Write    writeIsBusy =  ( DRV_USART_PLIB_WRITE_IS_BUSY ) USART1_WriteIsBusy    writeCountGet =  ( DRV_USART_PLIB_WRITE_COUNT_GET ) USART1_WriteCountGet    errorGet =  ( DRV_USART_PLIB_ERROR_GET ) USART1_ErrorGet    serialSetup =  ( DRV_USART_PLIB_SERIAL_SETUP ) USART1_SerialSetup } ;  const DRV_USART_INIT drvUsart0InitData =  {   usartPlib =   drvUsart0PlibAPI    numClients = DRV_USART_CLIENTS_NUMBER_IDX0    clientObjPool =  ( uintptr_t )  drvUSART0ClientObjPool [ 0 ]    dmaChannelTransmit = DRV_USART_XMIT_DMA_CH_IDX0    usartTransmitAddress =  ( void  * )  ( USART1_REGS - US_THR )    dmaChannelReceive = DRV_USART_RCV_DMA_CH_IDX0    usartReceiveAddress =  ( void  * )  ( USART1_REGS - US_RHR )    bufferObjPoolSize = DRV_USART_QUEUE_SIZE_IDX0    bufferObjPool =  ( uintptr_t )  drvUSART0BufferObjPool [ 0 ]    interruptUSART = USART1_IRQn    interruptDMA = XDMAC_IRQn    remapDataWidth = drvUsart0remapDataWidth    remapParity = drvUsart0remapParity    remapStopBits = drvUsart0remapStopBits    remapError = drvUsart0remapError   } ; objectHandle =  DRV_USART_Initialize ( DRV_USART_INDEX_1   ( SYS_MODULE_INIT * )  drvUsart0InitData ) ;  if  ( objectHandle == SYS_MODULE_OBJ_INVALID )  {  // Handle error  } ",
							" Remarks This routine must be called before any other USART routine is called This routine should only be called once during system initialization This routine will NEVER block for hardware access ",
							" DRV_USART_Status Function ",
							" C SYS_STATUS DRV_USART_Status ( SYS_MODULE_OBJ object ) ",
							" Summary Gets the current status of the USART driver module ",
							" Description This routine provides the current status of the USART driver module ",
							" Precondition Function DRV_USART_Initialize should have been called before calling this function ",
							" Parameters Param Description object Driver object handle returned from the DRV_USART_Initialize routine ",
							" Returns SYS_STATUS_READY - Initialization have succeeded and the USART is ready for additional operations SYS_STATUS_UNINITIALIZED - Indicates that the driver has not been initialized ",
							" Example SYS_MODULE_OBJ object ;  // Returned from DRV_USART_Initialize SYS_STATUS usartStatus ; usartStatus = DRV_USART _Status ( object ) ;  if  ( usartStatus == SYS_STATUS_READY )  {  // This means the driver can be opened using the  // DRV_USART_Open() function  } ",
							" Remarks A driver can opened only when its status is SYS_STATUS_READY ",
							" DRV_USART_Open Function ",
							" C DRV_HANDLE DRV_USART_Open (  const SYS_MODULE_INDEX index   const DRV_IO_INTENT ioIntent ) ",
							" Summary Opens the specified USART driver instance and returns a handle to it ",
							" Description This routine opens the specified USART driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver The ioIntent parameter defines how the client interacts with this driver instance Specifying a DRV_IO_INTENT_EXCLUSIVE will cause the driver to provide exclusive access to this client The driver cannot be opened by any other client ",
							" Precondition Function DRV_USART_Initialize must have been called before calling this function ",
							" Parameters Param Description index Identifier for the object instance to be opened intent Zero or more of the values from the enumeration DRV_IO_INTENT \"ORed\" together to indicate the intended use of the driver See function description for details ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) If an error occurs the return value is DRV_HANDLE_INVALID Error can occur if the number of client objects allocated via DRV_USART_CLIENTS_NUMBER is insufficient if the client is trying to open the driver but driver has been opened exclusively by another client if the driver peripheral instance being opened is not initialized or is invalid if the client is trying to open the driver exclusively but has already been opened in a non exclusive mode by another client if the driver is not ready to be opened typically when the initialize routine has not completed execution ",
							" Example DRV_HANDLE handle ; handle =  DRV_USART_Open ( DRV_USART_INDEX_0  DRV_IO_INTENT_EXCLUSIVE ) ;  if  ( handle == DRV_HANDLE_INVALID )  {  // Unable to open the driver  // May be the driver is not initialized or the initialization  // is not complete  } ",
							" Remarks The handle returned is valid until the DRV_USART_Close routine is called This routine will NEVER block waiting for hardware If the requested intent flags are not supported the routine will return DRV_HANDLE_INVALID This function is thread safe in a RTOS application ",
							" DRV_USART_Close Function ",
							" C void  DRV_USART_Close ( DRV_Handle handle ) ",
							" Summary Closes an opened-instance of the USART driver ",
							" Description This routine closes an opened-instance of the USART driver invalidating the handle Any buffers in the driver queue that were submitted by this client will be removed A new handle must be obtained by calling DRV_USART_Open before the caller may use the driver again ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns None ",
							" Example // 'handle' returned from the DRV_USART_Open  DRV_USART_Close ( handle ) ;  ",
							" Remarks None ",
							" DRV_USART_ErrorGet Function ",
							" C DRV_USART_ERROR DRV_USART_ErrorGet (  const DRV_USART_BUFFER_HANDLE bufferHandle ) ",
							" Summary Gets the USART hardware errors associated with the transfer request ",
							" Description This function returns the errors associated with the given bufferHandle The call to this function also clears all the associated error flags This function can be used for non-DMA buffer transfers only It cannot be used when the USART driver is configured to use DMA ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description bufferHandle A valid handle to the transfer request ",
							" Returns Errors occurred as listed by DRV_USART_ERROR This function reports multiple USART errors if occurred ",
							" Example // 'bufferHandle' returned from the DRV_USART_ReadBufferAdd  if  ( DRV_USART_ErrorGet ( bufferHandle )   DRV_USART_ERROR_OVERRUN )  {  //Errors are cleared by the driver take respective action  //for the overrun error case  } ",
							" Remarks USART errors are normally associated with the receiver Once the DRV_USART_ErrorGet API is called by the application the errors are cleared (set to DRV_USART_ERROR_NONE) by the driver The errors remain valid only until the buffer object associated with the bufferHandle is not assigned to another transfer request; in which case the API returns the error status as DRV_USART_ERROR_NONE Hence application may want to call this routine from the callback routine itself in case where an error is reported by the driver in the callback This function is expected to work in non-DMA mode only ",
							" DRV_USART_SerialSetup Function ",
							" C bool DRV_USART_SerialSetup (  const DRV_HANDLE handle  DRV_USART_SERIAL_SETUP * setup ) ",
							" Summary Sets the USART serial communication settings dynamically ",
							" Description This function sets the USART serial communication settings dynamically ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle The USART transmit or receive transfer status should not be busy ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine setup Pointer to the structure containing the serial setup ",
							" Returns true - Serial setup was updated successfully false - Failure while updating serial setup ",
							" Example // 'handle' returned from the DRV_USART_Open DRV_USART_SERIAL_SETUP setup =  {  115200  DRV_USART_PARITY_ODD  DRV_USART_DATA_8_BIT  DRV_USART_STOP_1_BIT } ;  DRV_USART_SerialSetup ( handle    setup ) ; ",
							" Remarks This routine must not be called from the interrupt context ",
							" DRV_USART_BufferEventHandlerSet Function ",
							" C void DRV_USART_BufferEventHandlerSet (  const DRV_HANDLE handle   const DRV_USART_BUFFER_EVENT_HANDLER eventHandler   const uintptr_t context ) ",
							" Summary Allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished ",
							" Description This function allows a client to register a buffer event handling function with the driver to call back when queued buffer transfers have finished When a client calls either the DRV_USART_ReadBufferAdd or DRV_USART_WriteBufferAdd function it is provided with a handle identifying the buffer that was added to the driver's buffer queue The driver will pass this handle back to the client by calling \"eventHandler\" function when the buffer transfer has completed The event handler should be set before the client performs any \"buffer add\" operations that could generate events The event handler once set persists until the client closes the driver or sets another event handler (which could be a \"NULL\" pointer to indicate no callback) ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine eventHandler Pointer to the event handler function context The value of parameter will be passed back to the client unchanged when the eventHandler function is called It can be used to identify any client specific data object that identifies the instance of the client module (for example it may be a pointer to the client module's state structure) ",
							" Returns None ",
							" Example // myAppObj is an application specific state data object MY_APP_OBJ myAppObj ; uint8_t mybuffer [ MY_BUFFER_SIZE ] ; DRV_USART_BUFFER_HANDLE bufferHandle ;  // Event is received when the buffer is processed  void  APP_USARTBufferEventHandler ( DRV_USART_BUFFER_EVENT event  DRV_USART_BUFFER_HANDLE handle  uintptr_t context )  {  // The context handle was set to an application specific  // object It is now retrievable easily in the event handler MY_APP_OBJ * myAppObj =  ( MY_APP_OBJ * ) context ;  switch ( event )  {  case DRV_USART_BUFFER_EVENT_COMPLETE :  {  // This means the data was transferred  break ;  }  case DRV_USART_BUFFER_EVENT_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  }  // myUSARTHandle is the handle returned  // by the DRV_USART_Open function  // Client registers an event handler with driver This is done once  DRV_USART_BufferEventHandlerSet ( myUSARTHandle  APP_USARTBufferEventHandler   ( uintptr_t )  myAppObj ) ;  DRV_USART_ReadBufferAdd ( myUSARThandle  myBuffer  MY_BUFFER_SIZE    bufferHandle ) ;  if ( bufferHandle == DRV_USART_BUFFER_HANDLE_INVALID )  {  // Error handling here  }  ",
							" Remarks If the client does not want to be notified when the queued buffer transfer has completed it does not need to register a callback This function is thread safe when called in a RTOS application ",
							" DRV_USART_WriteBufferAdd Function ",
							" C void DRV_USART_WriteBufferAdd (  const DRV_HANDLE handle   void * buffer  size_t size  DRV_USART_BUFFER_HANDLE * bufferHandle ) ; ",
							" Summary Queues a write operation ",
							" Description This function schedules a non-blocking write operation The function returns with a valid buffer handle in the bufferHandle argument if the write request was scheduled successfully The function adds the request to the driver instance queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified On returning the bufferHandle parameter may be DRV_USART_BUFFER_HANDLE_INVALID for the following reasons: if a buffer could not be allocated to the request because the queue is full if the input buffer handle is NULL if the input buffer pointer is NULL if the buffer size (number of bytes to write) is 0 if the driver handle is invalid If the requesting client registered an event callback with the driver the driver will issue a DRV_USART_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully or a DRV_USART_BUFFER_EVENT_ERROR event if the buffer was not processed successfully ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle Handle of the communication channel as return by the DRV_USART_Open function buffer Data to be transmitted size Buffer size in bytes bufferHandle Pointer to an argument that will contain the return buffer handle ",
							" Returns The bufferHandle parameter will contain the return buffer handle This will be DRV_USART_BUFFER_HANDLE_INVALID if the function was not successful ",
							" Example MY_APP_OBJ myAppObj ; uint8_t mybuffer [ MY_BUFFER_SIZE ] ; DRV_USART_BUFFER_HANDLE bufferHandle ;  // myUSARTHandle is the handle returned  // by the DRV_USART_Open function  DRV_USART_WriteBufferAdd ( myUSARThandle  myBuffer  MY_BUFFER_SIZE    bufferHandle ) ;  if ( bufferHandle == DRV_USART_BUFFER_HANDLE_INVALID )  {  // Error handling here  }  // Event is received when  // the buffer is processed ",
							" Remarks This function is thread safe in a RTOS application It can be called from within the USART Driver Buffer Event Handler that is registered by this client It should not be called in the event handler associated with another USART driver instance It should not otherwise be called directly in an ISR ",
							" DRV_USART_ReadBufferAdd Function ",
							" C void DRV_USART_ReadBufferAdd (  const DRV_HANDLE handle   void * buffer   const size_t size  DRV_USART_BUFFER_HANDLE * bufferHandle ) ",
							" Summary Queues a read operation ",
							" Description This function schedules a non-blocking read operation The function returns with a valid buffer handle in the bufferHandle argument if the read request was scheduled successfully The function adds the request to the hardware instance receive queue and returns immediately While the request is in the queue the application buffer is owned by the driver and should not be modified The function returns DRV_USART_BUFFER_HANDLE_INVALID in the bufferHandle argument: if a buffer could not be allocated to the request because the queue is full if the input buffer handle is NULL if the input buffer pointer is NULL if the buffer size (number of bytes to read) is 0 if the driver handle is invalid If the requesting client registered an event callback with the driver the driver will issue a DRV_USART_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_USART_BUFFER_EVENT_ERROR event if the buffer was not processed successfully ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle Handle of the communication channel as returned by the DRV_USART_Open function buffer Buffer where the received data will be stored size Buffer size in bytes bufferHandle Pointer to an argument that will contain the return buffer handle ",
							" Returns The buffer handle is returned in the bufferHandle argument This is DRV_USART_BUFFER_HANDLE_INVALID if the request was not successful ",
							" Example MY_APP_OBJ myAppObj ; uint8_t mybuffer [ MY_BUFFER_SIZE ] ; DRV_USART_BUFFER_HANDLE bufferHandle ;  // myUSARTHandle is the handle returned  // by the DRV_USART_Open function  DRV_USART_ReadBufferAdd ( myUSARThandle  myBuffer  MY_BUFFER_SIZE    bufferHandle ) ;  if ( bufferHandle == DRV_USART_BUFFER_HANDLE_INVALID )  {  // Error handling here  }  // Event is received when the buffer is processed ",
							" Remarks This function is thread safe in a RTOS application It can be called from within the USART Driver Buffer Event Handler that is registered by the client It should not be called in the event handler associated with another USART driver instance It should not be called directly in an ISR ",
							" DRV_USART_BufferCompletedBytesGet Function ",
							" C size_t DRV_USART_BufferCompletedBytesGet ( DRV_USART_BUFFER_HANDLE bufferHandle ) ; ",
							" Summary Returns the number of bytes that have been processed for the specified buffer request ",
							" Description The client can use this function in a case where the buffer is terminated due to an error to obtain the number of bytes that have been processed Or in any other use case This function can be used for non-DMA buffer transfers only It cannot be used when the USART driver is configured to use DMA ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle Either the DRV_USART_ReadBufferAdd or DRV_USART_WriteBufferAdd function must have been called and a valid buffer handle returned ",
							" Parameters Param Description bufferhandle Handle for the buffer of which the processed number of bytes to be obtained ",
							" Returns Returns the number of bytes that have been processed for this buffer Returns DRV_USART_BUFFER_HANDLE_INVALID for an invalid or an expired buffer handle ",
							" Example // myAppObj is an application specific object MY_APP_OBJ myAppObj ; uint8_t mybuffer [ MY_BUFFER_SIZE ] ; DRV_USART_BUFFER_HANDLE bufferHandle ;  // Event Processing Technique Event is received when  // the buffer is processed  void  APP_USARTBufferEventHandler ( DRV_USART_BUFFER_EVENT event  DRV_USART_BUFFER_HANDLE bufferHandle  uintptr_t context )  {  // The context handle was set to an application specific  // object It is now retrievable easily in the event handler MY_APP_OBJ * myAppObj =  ( MY_APP_OBJ * ) context ; size_t processedBytes ;  switch ( event )  {  case DRV_USART_BUFFER_EVENT_COMPLETE :  {  // This means the data was transferred  break ;  }  case DRV_USART_BUFFER_EVENT_ERROR :  {  // Error handling here  // We can find out how many bytes have been processed in this  // buffer request prior to the error processedBytes =  DRV_USART_BufferCompletedBytesGet ( bufferHandle ) ;  break ;  }  default :  {  break ;  }  }  }  // myUSARTHandle is the handle returned  // by the DRV_USART_Open function  // Client registers an event handler with driver This is done once  DRV_USART_BufferEventHandlerSet ( myUSARTHandle  APP_USARTBufferEventHandler   ( uintptr_t )  myAppObj ) ;  DRV_USART_ReadBufferAdd ( myUSARThandle  myBuffer  MY_BUFFER_SIZE  bufferHandle ) ;  if ( bufferHandle == DRV_USART_BUFFER_HANDLE_INVALID )  {  // Error handling here  }  ",
							" Remarks This function is expected to work in non-DMA mode only This function is thread safe when used in a RTOS application ",
							" DRV_USART_BufferStatusGet Function ",
							" C DRV_USART_BUFFER_EVENT DRV_USART_BufferStatusGet (  const DRV_USART_BUFFER_HANDLE bufferHandle ) ",
							" Summary Returns the transmit/receive request status ",
							" Description This function can be used to poll the status of the queued buffer request if the application doesn't prefer to use the event handler (callback) function to get notified ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle Either the DRV_USART_ReadBufferAdd or DRV_USART_WriteBufferAdd function must have been called and a valid buffer handle returned ",
							" Parameters Param Description bufferhandle Handle for the buffer of which the processed number of bytes to be obtained ",
							" Returns Returns either pending success or error event for the buffer Pending means the buffer is queued but not serviced yet ",
							" Example // myAppObj is an application specific object MY_APP_OBJ myAppObj ; uint8_t mybuffer [ MY_BUFFER_SIZE ] ; DRV_USART_BUFFER_HANDLE bufferHandle ; DRV_USART_BUFFER_EVENT event ;  // myUSARTHandle is the handle returned  // by the DRV_USART_Open function  DRV_USART_ReadBufferAdd ( myUSARThandle  myBuffer  MY_BUFFER_SIZE  bufferHandle ) ;  if ( bufferHandle == DRV_USART_BUFFER_HANDLE_INVALID )  {  // Error handling here  }  //Check the status of the buffer  //This call can be used to wait until the buffer is processed  while  ( ( event =  DRV_USART_BufferStatusGet ( bufferHandle ) )  == DRV_USART_BUFFER_EVENT_PENDING ) ;  //Buffer is processed check the event variable to determine if the buffer request  //is executed successfully or not ",
							" Remarks This function returns error event if the buffer handle is invalid ",
							" DRV_USART_WriteQueuePurge Function ",
							" C bool DRV_USART_WriteQueuePurge (  const DRV_HANDLE handle ) ",
							" Summary Removes all write requests from the queue for the given client This API does not abort the on-going write transfer ",
							" Description This function removes all the buffer requests from the queue The client can use this function to purge the queue on timeout or to remove unwanted stalled buffer requests or in any other use case ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle Handle of the communication channel as returned by the DRV_USART_Open function ",
							" Returns true - Write queue purge is successful false - Write queue purge has failed ",
							" Example // myUSARTHandle is the handle returned by the DRV_USART_Open function  // Use DRV_USART_WriteBufferAdd to queue write requests  // Application timeout function where remove queued buffers  void  APP_TimeOut ( void )  {  if ( DRV_USART_WriteQueuePurge ( myUSARThandle )  == false )  {  //Couldn't purge the write queue try again  }  else  {  //Queue purge successful  }  } ",
							" Remarks This function is thread safe when used in an RTOS environment Avoid this function call from within the callback This function does not abort the on-going write transfer ",
							" DRV_USART_ReadQueuePurge Function ",
							" C bool DRV_USART_ReadQueuePurge (  const DRV_HANDLE handle ) ",
							" Summary Removes all buffer requests from the queue for the given client and also aborts the on-going read request ",
							" Description This function removes all the buffer requests from the queue and aborts the on-going read request that is submitted to the PLIB The client can use this function to purge the queue on timeout or to remove unwanted stalled buffer requests or in any other use case ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle Handle of the communication channel as returned by the DRV_USART_Open function ",
							" Returns true - Read queue purge is successful false - Read queue purge has failed ",
							" Example // myUSARTHandle is the handle returned by the DRV_USART_Open function  // Use DRV_USART_ReadBufferAdd to queue read requests  // Application timeout function where remove queued buffers  void  APP_TimeOut ( void )  {  if ( DRV_USART_ReadQueuePurge ( myUSARThandle )  == false )  {  //Couldn't purge the read queue try again  }  else  {  //Queue purge successful  }  } ",
							" Remarks This function is thread safe when used in an RTOS environment Avoid this function call from within the callback ",
							" DRV_USART_ReadAbort Function ",
							" C bool DRV_USART_ReadAbort ( const DRV_HANDLE handle ) ",
							" Summary Aborts an on-going read request ",
							" Description This function aborts an on-going read transfer No callback is given for the on-going request being aborted When USART is configured for non-dma transfers application may call the DRV_USART_BufferCompletedBytesGet() API (before calling the DRV_USART_ReadAbort API)to find out how many bytes have been received for the on-going read request ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle Handle of the communication channel as return by the DRV_USART_Open function ",
							" Returns true - operation was successful false - error in running the API ",
							" Example // myUSARTHandle is the handle returned  // by the DRV_USART_Open function  // For non-DMA based transfers DRV_USART_BufferCompletedBytesGet() can be  // called to find out the number of bytes received before aborting the  // request uint32_t processedBytes ; processedBytes =  DRV_USART_BufferCompletedBytesGet ( bufferHandle ) ;  DRV_USART_ReadAbort ( myUSARTHandle ) ; ",
							" Remarks This function is thread safe in a RTOS application Calling this function does not have any impact on the read/write requests that may be pending in the transfer queue To purge the read/write request queues call the DRV_USART_ReadQueuePurge() and DRV_USART_WriteQueuePurge() APIs ",
							" DRV_USART_WriteBuffer Function ",
							" C bool DRV_USART_WriteBuffer (  const DRV_HANDLE handle   void * buffer   const size_t size ) ; ",
							" Summary This is a blocking function that writes data over USART ",
							" Description This function does a blocking write operation The function blocks till the data write is complete Function will return false to report failure The failure will occur for the following reasons: if the handle is invalid if the input buffer pointer is NULL if the buffer size is 0 ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle Handle of the communication channel as return by the DRV_USART_Open function buffer Pointer to the data to be transmitted size Buffer size in bytes ",
							" Returns true - write is successful false - error has occurred ",
							" Example MY_APP_OBJ myAppObj ; uint8_t myBuffer [ MY_BUFFER_SIZE ] ;  // myUSARTHandle is the handle returned  // by the DRV_USART_Open function  if  ( DRV_USART_WriteBuffer ( myUSARTHandle  myBuffer  MY_BUFFER_SIZE )  == false )  {  // Error handling here  } ",
							" Remarks This function is thread safe in a RTOS application This function should not be called from an interrupt context ",
							" DRV_USART_ReadBuffer Function ",
							" C bool DRV_USART_ReadBuffer (  const DRV_HANDLE handle   void * buffer   const size_t size ) ; ",
							" Summary This is a blocking function that reads data over USART ",
							" Description This function does a blocking read operation The function blocks till the data read is complete or error has occurred during read Function will return false to report failure The failure will occur for the following reasons: if the handle is invalid if the input buffer pointer is NULL if the buffer size is 0 Hardware errors ",
							" Precondition DRV_USART_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle Handle of the communication channel as return by the DRV_USART_Open function buffer Pointer to the receive buffer size Buffer size in bytes ",
							" Returns true - read is successful false - error has occurred ",
							" Example MY_APP_OBJ myAppObj ; uint8_t myBuffer [ MY_BUFFER_SIZE ] ;  // myUSARTHandle is the handle returned  // by the DRV_USART_Open function  if  ( DRV_USART_ReadBuffer ( myUSARTHandle  myBuffer  MY_BUFFER_SIZE )  == false )  {  // Error handling here  } ",
							" Remarks This function is thread safe in a RTOS application This function should not be called from an interrupt context ",
							" DRV_USART_BUFFER_HANDLE Typedef ",
							" C typedef uintptr_t DRV_USART_BUFFER_HANDLE ;  ",
							" Summary Handle identifying a read or write buffer passed to the driver ",
							" Description A buffer handle value is returned by a call to the DRV_USART_ReadBufferAdd or DRV_USART_WriteBufferAdd functions This handle is associated with the buffer passed into the function and it allows the application to track the completion of the data from (or into) that buffer The buffer handle value returned from the \"buffer add\" function is returned back to the client by the \"event handler callback\" function registered with the driver The buffer handle assigned to a client request expires when the client has been notified of the completion of the buffer transfer (after event handler function that notifies the client returns) or after the buffer has been retired by the driver if no event handler callback was set ",
							" Remarks None ",
							" DRV_USART_BUFFER_HANDLE_INVALID Macro ",
							" C # define DRV_USART_BUFFER_HANDLE_INVALID ((DRV_USART_BUFFER_HANDLE)(-1))  ",
							" Summary Definition of an invalid buffer handle ",
							" Description This is the definition of an invalid buffer handle An invalid buffer handle is returned by DRV_USART_ReadBufferAdd and DRV_USART_WriteBufferAdd functions if the buffer add request was not successful ",
							" Remarks None ",
							" DRV_USART_BUFFER_EVENT Enum ",
							" C typedef  enum  {  /* The buffer is pending to be serviced */ DRV_USART_BUFFER_EVENT_PENDING =  0   /* All data from or to the buffer was transferred successfully */ DRV_USART_BUFFER_EVENT_COMPLETE =  1   /* Transfer Handle given is expired It means transfer is completed but with or without error is not known */ DRV_USART_BUFFER_EVENT_HANDLE_EXPIRED =  2   /* There was an error while processing the buffer transfer request */ DRV_USART_BUFFER_EVENT_ERROR =  - 1   /* Transfer Handle given is invalid */ DRV_USART_BUFFER_EVENT_HANDLE_INVALID =  - 2  } DRV_USART_BUFFER_EVENT ;  ",
							" Summary Identifies the possible events that can result from a buffer add request ",
							" Description This enumeration identifies the possible events that can result from a buffer add request caused by the client calling either the DRV_USART_ReadBufferAdd or DRV_USART_WriteBufferAdd functions ",
							" Remarks One of these values is passed in the \"event\" parameter of the event handling callback function that the client registered with the driver by calling the DRV_USART_BufferEventHandlerSet function when a buffer transfer request is completed ",
							" DRV_USART_BUFFER_EVENT_HANDLER Typedef ",
							" C typedef  void  ( * DRV_USART_BUFFER_EVENT_HANDLER ) ( DRV_USART_BUFFER_EVENT event  DRV_USART_BUFFER_HANDLE bufferHandle  uintptr_t context ) ;  ",
							" Summary Pointer to a USART Driver Buffer Event handler function ",
							" Description This data type defines the required function signature for the USART driver buffer event handling callback function A client must register a pointer using the buffer event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive buffer related event calls back from the driver The parameters and return values are described here and a partial example implementation is provided ",
							" Parameters Param Description event Identifies the type of event bufferHandle Handle identifying the buffer to which the vent relates context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Example void  APP_USARTBufferEventHandler ( DRV_USART_BUFFER_EVENT event  DRV_USART_BUFFER_HANDLE handle  uintptr_t context )  {  // The context handle was set to an application specific  // object It is now retrievable easily in the event handler MY_APP_OBJ * myAppObj =  ( MY_APP_OBJ * ) context ;  switch ( event )  {  case DRV_USART_BUFFER_EVENT_COMPLETE :  {  // This means the data was transferred  break ;  }  case DRV_USART_BUFFER_EVENT_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  } ",
							" Remarks If the event is DRV_USART_BUFFER_EVENT_COMPLETE it means that the data was transferred successfully If the event is DRV_USART_BUFFER_EVENT_ERROR it means that the data was not transferred successfully The DRV_USART_BufferCompletedBytesGet function can be called to find out how many bytes were processed The bufferHandle parameter contains the buffer handle of the buffer that associated with the event And bufferHandle will be valid while the buffer request is in the queue and during callback unless an error occurred After callback returns the driver will retire the buffer handle The context parameter contains the a handle to the client context provided at the time the event handling function was registered using the DRV_USART_BufferEventHandlerSet function This context handle value is passed back to the client as the \"context\" parameter It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request The event handler function executes in the peripheral's interrupt context It is recommended of the application to not perform process intensive or blocking operations within this function The DRV_USART_ReadBufferAdd and DRV_USART_WriteBufferAdd functions can be called in the event handler to add a buffer to the driver queue These functions can only be called to add buffers to the driver whose event handler is running For example USART2 driver buffers cannot be added in USART1 driver event handler ",
							" DRV_USART_ERROR Enum ",
							" C This structure is implementation specific It is fully defined in drv_usart_definitions h ",
							" Summary Defines the different types of errors for USART driver ",
							" Description This data type defines the different types of errors for USART driver DRV_USART_ERROR_NONE : No errors DRV_USART_ERROR_OVERRUN : Receive Overflow error DRV_USART_ERROR_PARITY : Parity error DRV_USART_ERROR_FRAMING : Framing error ",
							" Remarks None ",
							" DRV_USART_INIT Struct ",
							" C This structure is implementation specific It is fully defined in drv_usart_definitions h ",
							" Summary Defines the data required to initialize the USART driver ",
							" Description This data type defines the data required to initialize the USART driver ",
							" Remarks None ",
							" DRV_USART_SERIAL_SETUP Struct ",
							" C This structure is implementation specific It is fully defined in drv_usart_definitions h ",
							" Summary Defines the data required to dynamically set the serial settings ",
							" Description This data type defines the data required to dynamically set the serial settings for the specific USART driver instance ",
							" Remarks None ",
							" I2C EEPROM Drivers This section provides the I2C EEPROM based driver libraries help ",
							" AT24 Driver This driver provides a non-blocking interface to read and write to external AT24 EEPROM The library uses the I2C peripheral library (PLIB) to interface with the AT24 Key Features: Supports a single instance of the AT24 EEPROM and a single client to the driver Supports page writes Supports writes to random memory address within page boundaries The library interface is compliant to the block media interface expected by the Memory Driver This allows running a file system on the AT24 EEPROM using the Memory Driver and the File System Service The library can be used in both Bare-Metal and RTOS environments ",
							" How the Library Works The AT24 driver library is a single-client single-instance based driver interface Abstraction Model The AT24 driver interface provides read and write functions that abstract out the internal workings of the AT24 driver and the underlying SPI protocol The client can be: Application - Directly access the AT24 EEPROM using the APIs provided by the AT24 Driver library Memory Driver - Application can run a file system on the AT24 EEPROM by connecting it to the Memory Driver which can further be connected to the File System Service drv_at24_abstraction_model Working flow The AT24 Driver Library registers an event handler with the underlying SPI peripheral library (PLIB) This event handler is called by the PLIB from the interrupt context to notify the AT24 driver that the requested transfer is complete The library's state machine is driven from the interrupt context Once a transfer is complete a callback (if registered by the application) is given to the application from the interrupt context The library does not support queuing of more than one requests The application must check and ensure that any previous request is completed before submitting a new one This can be done either by polling the status of the data transfer or by registering a callback ",
							" Using The Library The AT24 driver provides non-blocking API's to read write AT24 EEPROM The AT24 driver can be used in following ways: To perform reads and writes from/to any EEPROM memory address with number of bytes spanning multiple pages To perform page write to AT24 EEPROM Here the memory start address must be aligned to the page boundary To interface with the Memory driver to perform block operations on the AT24 EEPROM Application can either register a callback to get notified once the data transfer is complete or can poll the status of the data transfer Example application to Write and Read AT24 EEPROM # define BUFFER_SIZE 512  # define MEM_ADDRESS 0x0 APP_DATA CACHE_ALIGN appData ;  static uint32_t erase_index =  0 ;  static uint32_t write_index =  0 ;  static  void  APP_EEPROM_EventHandler ( DRV_AT24_TRANSFER_STATUS event  uintptr_t context )  {  switch ( event )  {  case DRV_AT24_TRANSFER_STATUS_COMPLETED :  { appData  isTransferDone = true ;  break ;  }  case DRV_AT24_TRANSFER_STATUS_ERROR :  default :  { appData  isTransferDone = false ; appData  state = APP_STATE_ERROR ;  break ;  }  }  }  void APP_Initialize (  void  )  { uint32_t i =  0 ;  /* Place the App state machine in its initial state */ appData  state = APP_STATE_INIT ;  for  ( i =  0 ; i  BUFFER_SIZE ; i ++ )  { appData  writeBuffer [ i ]  = i ;  } appData  isTransferDone = false ;  }  void APP_Tasks (  void  )  { uint32_t i ;  /* Check the application's current state */  switch  ( appData  state )  {  /* Application's initial state */  case APP_STATE_INIT :  { appData  drvHandle =  DRV_AT24_Open ( DRV_AT24_INDEX  DRV_IO_INTENT_READWRITE ) ;  if  ( appData  drvHandle = DRV_HANDLE_INVALID )  {  DRV_AT24_EventHandlerSet ( appData  drvHandle  APP_EEPROM_EventHandler   0 ) ; appData  state = APP_STATE_WRITE ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WRITE :  {  /* Set the next state first as callback may be fired before the state * is changed; potentially over-writing error state set from the callback */ appData  state = APP_STATE_WAIT_WRITE_COMPLETE ;  if  ( DRV_AT24_Write ( appData  drvHandle  appData  writeBuffer  BUFFER_SIZE  AT24_EEPROM_MEM_ADDR )  == false )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WAIT_WRITE_COMPLETE :  {  if  ( appData  isTransferDone == true )  { appData  isTransferDone = false ; appData  state = APP_STATE_READ ;  }  break ;  }  case APP_STATE_READ :  { appData  state = APP_STATE_WAIT_READ_COMPLETE ;  if  ( DRV_AT24_Read ( appData  drvHandle  appData  readBuffer  BUFFER_SIZE  AT24_EEPROM_MEM_ADDR )  == false )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WAIT_READ_COMPLETE :  {  if  ( appData  isTransferDone == true )  { appData  isTransferDone = false ; appData  state = APP_STATE_VERIFY ;  }  break ;  }  case APP_STATE_VERIFY :  {  if  ( memcmp ( appData  writeBuffer  appData  readBuffer  BUFFER_SIZE )  ==  0 )  { appData  state = APP_STATE_SUCCESS ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_SUCCESS :  { appData  state = APP_STATE_IDLE ;  break ;  }  case APP_STATE_ERROR :  { appData  state = APP_STATE_IDLE ;  break ;  }  case APP_STATE_IDLE :  DRV_AT24_Close ( appData  drvHandle ) ;  default :  {  break ;  }  }  }  ",
							" Configuring The Library The AT24 driver library should be configured through the MHC The following figures show the MHC configuration window for the AT24 driver and brief description AT24 Driver with SPI peripheral connected drv_at24_mhc_config_with_i2c Configuration Options PLIB Used: Specifies the Peripheral library connected Number Of Clients: Indicates maximum number of clients Always set to one as it supports only a single client EEPROM Page Size: Size of one page of EEPROM memory (in bytes) EEPROM Flash Size: Total Size of the EEPROM memory (in bytes) Depending on the specified EEPROM Flash Size the driver will generate the appropriate number of address bits (8-bit 16-bit or 24-bit) thereby allowing it to communicate with EEPROM of different sizes in the AT24 family EEPROM Address: The seventh bit of I2C slave address of the EEPROM This pin must be configured as GPIO output in \"Pin Settings\" configuration AT24 EEPROM Start Address: Specifies the EEPROM memory start address to be used for Transfer operations The start address will be populated in the device geometry table DRV_AT24_GEOMETRY ",
							" Library Interface AT24 driver library provides the following interfaces: Functions Name Description DRV_AT24_Initialize Initializes the AT24 EEPROM device DRV_AT24_Status Gets the current status of the AT24 driver module DRV_AT24_Open Opens the specified AT24 driver instance and returns a handle to it DRV_AT24_Close Closes the opened-instance of the AT24 driver DRV_AT24_Read Reads 'n' bytes of data from the specified start address of EEPROM DRV_AT24_Write Writes 'n' bytes of data starting at the specified address DRV_AT24_PageWrite Writes one page of data starting at the specified address DRV_AT24_TransferStatusGet Gets the current status of the transfer request DRV_AT24_GeometryGet Returns the geometry of the device DRV_AT24_EventHandlerSet Allows a client to identify a transfer event handling function for the driver to call back when the requested transfer has finished Data types and constants Name Type Description DRV_AT24_TRANSFER_STATUS Enum Defines the data type for AT24 Driver transfer status DRV_AT24_GEOMETRY Struct Defines the data type for AT24 EEPROM Geometry details DRV_AT24_EVENT_HANDLER Typedef Pointer to a AT24 Driver Event handler function ",
							" DRV_AT24_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_AT24_Initialize (  const SYS_MODULE_INDEX drvIndex   const SYS_MODULE_INIT *  const init ) ",
							" Summary Initializes the AT24 EEPROM device ",
							" Description This routine initializes the AT24 EEPROM device driver making it ready for clients to open and use The initialization data is specified by the init parameter It is a single instance driver so this API should be called only once ",
							" Precondition None ",
							" Parameters Param Description drvIndex Identifier for the instance to be initialized init Pointer to the init data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise returns SYS_MODULE_OBJ_INVALID ",
							" Example SYS_MODULE_OBJ sysObjDrvAT24 ; DRV_AT24_PLIB_INTERFACE drvAT24PlibAPI =  {   writeRead =  ( DRV_AT24_PLIB_WRITE_READ ) TWIHS0_WriteRead    write =  ( DRV_AT24_PLIB_WRITE ) TWIHS0_Write    read =  ( DRV_AT24_PLIB_READ ) TWIHS0_Read    isBusy =  ( DRV_AT24_PLIB_IS_BUSY ) TWIHS0_IsBusy    errorGet =  ( DRV_AT24_PLIB_ERROR_GET ) TWIHS0_ErrorGet    callbackRegister =  ( DRV_AT24_PLIB_CALLBACK_REGISTER ) TWIHS0_CallbackRegister   } ; DRV_AT24_INIT drvAT24InitData =  {   i2cPlib =   drvAT24PlibAPI    slaveAddress =  0x57    pageSize = DRV_AT24_EEPROM_PAGE_SIZE    flashSize = DRV_AT24_EEPROM_FLASH_SIZE    numClients = DRV_AT24_CLIENTS_NUMBER_IDX    blockStartAddress =  0x0   } ; sysObjDrvAT24 =  DRV_AT24_Initialize ( DRV_AT24_INDEX   ( SYS_MODULE_INIT * )  drvAT24InitData ) ;  ",
							" Remarks This routine must be called before any other DRV_AT24 routine is called This routine should only be called once during system initialization ",
							" DRV_AT24_Status Function ",
							" C SYS_STATUS DRV_AT24_Status (  const SYS_MODULE_INDEX drvIndex ) ",
							" Summary Gets the current status of the AT24 driver module ",
							" Description This routine provides the current status of the AT24 driver module ",
							" Preconditions Function DRV_AT24_Initialize should have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the instance used to initialize driver ",
							" Returns SYS_STATUS_READY - Indicates that the driver is ready and accept requests for new operations SYS_STATUS_UNINITIALIZED - Indicates the driver is not initialized ",
							" Example SYS_STATUS status ; status =  DRV_AT24_Status ( DRV_AT24_INDEX ) ;  if  ( status == SYS_STATUS_READY )  {  // AT24 driver is initialized and ready to accept requests  } ",
							" Remarks None ",
							" DRV_AT24_Open Function ",
							" C DRV_HANDLE DRV_AT24_Open (  const SYS_MODULE_INDEX drvIndex   const DRV_IO_INTENT ioIntent ) ",
							" Summary Opens the specified AT24 driver instance and returns a handle to it ",
							" Description This routine opens the specified AT24 driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver The ioIntent parameter defines how the client interacts with this driver instance This driver is a single client driver so DRV_AT24_Open API should be called only once until driver is closed ",
							" Precondition Function DRV_AT24_Initialize must have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the object instance to be opened ioIntent Zero or more of the values from the enumeration DRV_IO_INTENT \"ORed\" together to indicate the intended use of the driver Note: This driver ignores the ioIntent argument ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) If an error occurs the return value is DRV_HANDLE_INVALID Error can occur if the driver has been already opened once and in use if the driver instance being opened is not initialized or is invalid ",
							" Example DRV_HANDLE handle ; handle =  DRV_AT24_Open ( DRV_AT24_INDEX  DRV_IO_INTENT_READWRITE ) ;  if  ( handle == DRV_HANDLE_INVALID )  {  // Unable to open the driver  // May be the driver is not initialized  } ",
							" Remarks The handle returned is valid until the DRV_AT24_Close routine is called ",
							" DRV_AT24_Close Function ",
							" C void  DRV_AT24_Close (  const DRV_HANDLE handle ) ",
							" Summary Closes the opened-instance of the AT24 driver ",
							" Description This routine closes opened-instance of the AT24 driver invalidating the handle A new handle must be obtained by calling DRV_AT24_Open before the caller may use the driver again ",
							" Precondition DRV_AT24_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns None ",
							" Example // 'handle' returned from the DRV_AT24_Open  DRV_AT24_Close ( handle ) ;  ",
							" Remarks None ",
							" DRV_AT24_Read Function ",
							" C bool DRV_AT24_Read ( const DRV_HANDLE handle   void  * rxData  uint32_t rxDataLength  uint32_t address ) ",
							" Summary Reads 'n' bytes of data from the specified start address of EEPROM ",
							" Description This function schedules a non-blocking read operation for the requested number of data bytes from the given address of the EEPROM The requesting client should call DRV_AT24_TransferStatusGet API to know the current status of the request OR the requesting client can register a callback function with the driver to get notified of the status ",
							" Precondition DRV_AT24_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine rxData Buffer pointer into which the data read from the DRV_AT24 Flash memory will be placed rxDataLength Total number of bytes to be read address Memory start address from where the data should be read ",
							" Returns true if the read request is accepted false if handle is invalid if the pointer to the receive buffer is NULL or number of bytes to read is 0 if the driver is busy handling another transfer request ",
							" Example # define BUFFER_SIZE 1024  # define MEM_ADDRESS 0x00 uint8_t CACHE_ALIGN readBuffer [ BUFFER_SIZE ] ;  // myHandle is the handle returned from DRV_AT24_Open API  // In the below example the transfer status is polled However application can  // register a callback and get notified when the transfer is complete  if  ( DRV_AT24_Read ( myHandle  readBuffer  BUFFER_SIZE  MEM_ADDRESS )  = true )  {  // Error handling here  }  else  {  // Wait for read to be completed  while ( DRV_AT24_TransferStatusGet ( myHandle )  == DRV_AT24_TRANSFER_STATUS_BUSY ) ;  }  ",
							" Remarks None ",
							" DRV_AT24_Write Function ",
							" C bool DRV_AT24_Write ( const DRV_HANDLE handle   void  * txData  uint32_t txDataLength  uint32_t address ) ",
							" Summary Writes 'n' bytes of data starting at the specified address ",
							" Description This function schedules a non-blocking write operation for writing txDataLength bytes of data starting from given address of EEPROM The requesting client should call DRV_AT24_TransferStatusGet API to know the current status of the request OR the requesting client can register a callback function with the driver to get notified of the status ",
							" Preconditions DRV_AT24_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine txData The source buffer containing data to be programmed into AT24 EEPROM txDataLength Total number of bytes to be written address Memory start address from where the data should be written ",
							" Returns true if the write request is accepted false if handle is invalid if the pointer to transmit buffer is NULL or number of bytes to write is 0 if the driver is busy handling another transfer request ",
							" Example # define BUFFER_SIZE 1024  # define MEM_ADDRESS 0x00 uint8_t CACHE_ALIGN writeBuffer [ BUFFER_SIZE ] ;  // myHandle is the handle returned from DRV_AT24_Open API  // In the below example the transfer status is polled However application can  // register a callback and get notified when the transfer is complete  if  ( DRV_AT24_Write ( myHandle  writeBuffer  BUFFER_SIZE  MEM_ADDRESS )  = true )  {  // Error handling here  }  else  {  // Wait for write to be completed  while ( DRV_AT24_TransferStatusGet ( myHandle )  == DRV_AT24_TRANSFER_STATUS_BUSY ) ;  } ",
							" Remarks None ",
							" DRV_AT24_PageWrite Function ",
							" C bool DRV_AT24_PageWrite ( const DRV_HANDLE handle   void  * txData  uint32_t address ) ",
							" Summary Writes one page of data starting at the specified address ",
							" Description This function schedules a non-blocking write operation for writing one page of data starting from the given address of the EEPROM The requesting client should call DRV_AT24_TransferStatusGet API to know the current status of the request OR the requesting client can register a callback function with the driver to get notified of the status ",
							" Preconditions DRV_AT24_Open must have been called to obtain a valid opened device handle \"address\" provided must be page boundary aligned in order to avoid overwriting the data in the beginning of the page ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine txData The source buffer containing data to be written to the AT24 EEPROM address Write memory start address from where the data should be written It must be page boundary aligned in order to avoid overwriting the data in the beginning of the page ",
							" Returns true if the write request is accepted false if handle is invalid if the pointer to the transmit data is NULL if the driver is busy handling another transfer request ",
							" Example # define BUFFER_SIZE 1024  # define MEM_ADDRESS 0x00 uint8_t CACHE_ALIGN writeBuffer [ PAGE_SIZE ] ;  // myHandle is the handle returned from DRV_AT24_Open API  // In the below example the transfer status is polled However application can  // register a callback and get notified when the transfer is complete  if  ( DRV_AT24_PageWrite ( myHandle  writeBuffer  MEM_ADDRESS )  = true )  {  // Error handling here  }  else  {  // Wait for write to be completed  while ( DRV_AT24_TransferStatusGet ( myHandle )  == DRV_AT24_TRANSFER_STATUS_BUSY ) ;  } ",
							" Remarks None ",
							" DRV_AT24_TransferStatusGet Function ",
							" C DRV_AT24_TRANSFER_STATUS DRV_AT24_TransferStatusGet ( const DRV_HANDLE handle ) ",
							" Summary Gets the current status of the transfer request ",
							" Description This routine gets the current status of the transfer request ",
							" Preconditions DRV_AT24_PageWrite DRV_AT24_Write or DRV_AT24_Read must have been called to obtain the status of transfer ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns One of the status element from the enum DRV_AT24_TRANSFER_STATUS ",
							" Example // myHandle is the handle returned from DRV_AT24_Open API  if  ( DRV_AT24_TransferStatusGet ( myHandle )  == DRV_AT24_TRANSFER_STATUS_COMPLETED )  {  // Operation Done  } ",
							" Remarks None ",
							" DRV_AT24_GeometryGet Function ",
							" C bool DRV_AT24_GeometryGet ( const DRV_HANDLE handle  DRV_AT24_GEOMETRY * geometry ) ",
							" Summary Returns the geometry of the device ",
							" Description This API gives the following geometrical details of the DRV_AT24 Flash: Number of Read/Write/Erase Blocks and their size in each region of the device ",
							" Precondition DRV_AT24_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine geometry Pointer to flash device geometry table instance ",
							" Returns true - if able to get the geometry details of the flash false - if handle is invalid ",
							" Example DRV_AT24_GEOMETRY eepromGeometry ; uint32_t readBlockSize  writeBlockSize  eraseBlockSize ; uint32_t nReadBlocks  nReadRegions  totalFlashSize ;  // myHandle is the handle returned from DRV_AT24_Open API  DRV_AT24_GeometryGet ( myHandle    eepromGeometry ) ; readBlockSize = eepromGeometry  readBlockSize ; nReadBlocks = eepromGeometry  readNumBlocks ; nReadRegions = eepromGeometry  readNumRegions ; writeBlockSize = eepromGeometry  writeBlockSize ; eraseBlockSize = eepromGeometry  eraseBlockSize ; totalFlashSize = readBlockSize * nReadBlocks * nReadRegions ;  ",
							" Remarks None ",
							" DRV_AT24_EventHandlerSet Function ",
							" C void  DRV_AT24_EventHandlerSet (  const DRV_HANDLE handle   const DRV_AT24_EVENT_HANDLER eventHandler   const uintptr_t context ) ",
							" Summary Allows a client to identify a transfer event handling function for the driver to call back when the requested transfer has finished ",
							" Description This function allows a client to register a transfer event handling function with the driver to call back when the requested transfer has finished The event handler should be set before the client submits any transfer requests that could generate events The event handler once set persists until the client closes the driver or sets another event handler (which could be a \"NULL\" pointer to indicate no callback) ",
							" Precondition DRV_AT24_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine eventHandler Pointer to the event handler function context The value of parameter will be passed back to the client unchanged when the eventHandler function is called It can be used to identify any client specific data object that identifies the instance of the client module (for example it may be a pointer to the client module's state structure) ",
							" Returns None ",
							" Example # define BUFFER_SIZE 256  # define MEM_ADDRESS 0x0  // myAppObj is an application specific state data object MY_APP_OBJ myAppObj ; uint8_t myBuffer [ BUFFER_SIZE ] ;  // myHandle is the handle returned from DRV_AT24_Open API  // Client registers an event handler with driver This is done once  DRV_AT24_EventHandlerSet ( myHandle  APP_AT24TransferEventHandler   ( uintptr_t )  myAppObj ) ;  if  ( DRV_AT24_Read ( myHandle  myBuffer  BUFFER_SIZE  MEM_ADDRESS )  == false )  {  // Error handling here  }  // The registered event handler is called when the request is complete  void  APP_AT24TransferEventHandler ( DRV_AT24_TRANSFER_STATUS event  uintptr_t context )  {  // The context handle was set to an application specific  // object It is now retrievable easily in the event handler MY_APP_OBJ * pMyAppObj =  ( MY_APP_OBJ * ) context ;  switch ( event )  {  case DRV_AT24_TRANSFER_STATUS_COMPLETED :  {  // This means the data was transferred  break ;  }  case DRV_AT24_TRANSFER_STATUS_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  } ",
							" Remarks If the client does not want to be notified when the queued buffer transfer has completed it does not need to register a callback ",
							" DRV_AT24_TRANSFER_STATUS Enum ",
							" C typedef  enum  {  /* Transfer is being processed */ DRV_AT24_TRANSFER_STATUS_BUSY   /* Transfer is successfully completed */ DRV_AT24_TRANSFER_STATUS_COMPLETED   /* Transfer had error */ DRV_AT24_TRANSFER_STATUS_ERROR } DRV_AT24_TRANSFER_STATUS ;  ",
							" Summary Defines the data type for AT24 Driver transfer status ",
							" Description This will be used to indicate the current transfer status of the AT24 EEPROM driver operations ",
							" Remarks None ",
							" DRV_AT24_GEOMETRY Struct ",
							" C typedef  struct  { uint32_t readBlockSize ; uint32_t readNumBlocks ; uint32_t readNumRegions ; uint32_t writeBlockSize ; uint32_t writeNumBlocks ; uint32_t writeNumRegions ; uint32_t eraseBlockSize ; uint32_t eraseNumBlocks ; uint32_t eraseNumRegions ; uint32_t blockStartAddress ;  } DRV_AT24_GEOMETRY ;  ",
							" Summary Defines the data type for AT24 EEPROM Geometry details ",
							" Description This will be used to get the geometry details of the attached AT24 EEPROM device ",
							" Remarks None ",
							" DRV_AT24_EVENT_HANDLER Typedef ",
							" C typedef  void  ( * DRV_AT24_EVENT_HANDLER ) ( DRV_AT24_TRANSFER_STATUS event  uintptr_t context ) ;  ",
							" Summary Pointer to a AT24 Driver Event handler function ",
							" Description This data type defines the required function signature for the AT24 driver event handling callback function A client must register a pointer using the event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver The parameters and return values are described here and a partial example implementation is provided ",
							" Parameters Param Description event Identifies the type of event context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Example void  APP_MyTransferEventHandler ( DRV_AT24_TRANSFER_STATUS event  uintptr_t context )  { MY_APP_DATA_STRUCT * pAppData =  ( MY_APP_DATA_STRUCT * ) context ;  switch ( event )  {  case DRV_AT24_TRANSFER_STATUS_COMPLETED :  // Handle the transfer complete event  break ;  case DRV_AT24_TRANSFER_STATUS_ERROR :  default :  // Handle error  break ;  }  } ",
							" Remarks If the event is DRV_AT24_TRANSFER_STATUS_COMPLETED it means that the data was transferred successfully If the event is DRV_AT24_TRANSFER_STATUS_ERROR it means that the data was not transferred successfully The context parameter contains the handle to the client context provided at the time the event handling function was registered using the DRV_AT24_EventHandlerSet function This context handle value is passed back to the client as the \"context\" parameter It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request The event handler function executes in the driver's interrupt context It is recommended of the application to not perform process intensive or blocking operations with in this function The DRV_AT24_Read DRV_AT24_Write and DRV_AT24_PageWrite functions can be called in the event handler to submit a new request to the driver ",
							" SPI EEPROM Drivers This section provides the SPI EEPROM based driver libraries help ",
							" AT25 Driver This driver provides a non-blocking interface to read and write to the external AT25 EEPROM The library uses the SPI peripheral library (PLIB) to interface with the AT25 Key Features: Supports a single instance of the AT25 EEPROM and a single client to the driver Supports page writes Supports writes to random memory address within page boundaries The library interface is compliant to the block media interface expected by the Memory Driver This allows running a file system on the AT25 EEPROM using the Memory Driver and the File System Service The library can be used in both Bare-Metal and RTOS environments ",
							" How the Library Works The AT25 driver library is a single-client single-instance based driver interface Abstraction Model The AT25 driver interface provides read and write functions that abstract out the internal workings of the AT25 driver and the underlying SPI protocol The client can be: Application - Directly access the AT25 EEPROM using the APIs provided by the AT25 Driver library Memory Driver - Application can run a file system on the AT25 EEPROM by connecting it to the Memory Driver which can further be connected to the File System Service drv_at25_abstraction_model Working flow The AT25 Driver Library registers an event handler with the underlying SPI peripheral library (PLIB) This event handler is called by the PLIB from the interrupt context to notify the AT25 driver that the requested transfer is complete The library's state machine is driven from the interrupt context Once a transfer is complete a callback (if registered by the application) is given to the application from the interrupt context The library does not support queuing of more than one requests The application must check and ensure that any previous request is completed before submitting a new one This can be done either by polling the status of the data transfer or by registering a callback ",
							" Using The Library The AT25 driver provides non-blocking API's to read write AT25 EEPROM The AT25 driver can be used in following ways: To perform reads and writes from/to any EEPROM memory address with number of bytes spanning multiple pages To perform page write to AT25 EEPROM Here the memory start address must be aligned to the page boundary To interface with the Memory driver to perform block operations on the AT25 EEPROM Application can either register a callback to get notified once the data transfer is complete or can poll the status of the data transfer Example application to Write and Read AT25 EEPROM # define BUFFER_SIZE 512  # define MEM_ADDRESS 0x0 APP_DATA CACHE_ALIGN appData ;  static uint32_t erase_index =  0 ;  static uint32_t write_index =  0 ;  static  void  APP_EEPROM_EventHandler ( DRV_AT25_TRANSFER_STATUS event  uintptr_t context )  {  switch ( event )  {  case DRV_AT25_TRANSFER_STATUS_COMPLETED :  { appData  isTransferDone = true ;  break ;  }  case DRV_AT25_TRANSFER_STATUS_ERROR :  default :  { appData  isTransferDone = false ; appData  state = APP_STATE_ERROR ;  break ;  }  }  }  void APP_Initialize (  void  )  { uint32_t i =  0 ;  /* Place the App state machine in its initial state */ appData  state = APP_STATE_INIT ;  for  ( i =  0 ; i  BUFFER_SIZE ; i ++ )  { appData  writeBuffer [ i ]  = i ;  } appData  isTransferDone = false ;  }  void APP_Tasks (  void  )  { uint32_t i ;  /* Check the application's current state */  switch  ( appData  state )  {  /* Application's initial state */  case APP_STATE_INIT :  { appData  drvHandle =  DRV_AT25_Open ( DRV_AT25_INDEX  DRV_IO_INTENT_READWRITE ) ;  if  ( appData  drvHandle = DRV_HANDLE_INVALID )  {  DRV_AT25_EventHandlerSet ( appData  drvHandle  APP_EEPROM_EventHandler   0 ) ; appData  state = APP_STATE_WRITE ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WRITE :  {  /* Set the next state first as callback may be fired before the state * is changed; potentially over-writing error state set from the callback */ appData  state = APP_STATE_WAIT_WRITE_COMPLETE ;  if  ( DRV_AT25_Write ( appData  drvHandle  appData  writeBuffer  BUFFER_SIZE  AT25_EEPROM_MEM_ADDR )  == false )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WAIT_WRITE_COMPLETE :  {  if  ( appData  isTransferDone == true )  { appData  isTransferDone = false ; appData  state = APP_STATE_READ ;  }  break ;  }  case APP_STATE_READ :  { appData  state = APP_STATE_WAIT_READ_COMPLETE ;  if  ( DRV_AT25_Read ( appData  drvHandle  appData  readBuffer  BUFFER_SIZE  AT25_EEPROM_MEM_ADDR )  == false )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WAIT_READ_COMPLETE :  {  if  ( appData  isTransferDone == true )  { appData  isTransferDone = false ; appData  state = APP_STATE_VERIFY ;  }  break ;  }  case APP_STATE_VERIFY :  {  if  ( memcmp ( appData  writeBuffer  appData  readBuffer  BUFFER_SIZE )  ==  0 )  { appData  state = APP_STATE_SUCCESS ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_SUCCESS :  { appData  state = APP_STATE_IDLE ;  break ;  }  case APP_STATE_ERROR :  { appData  state = APP_STATE_IDLE ;  break ;  }  case APP_STATE_IDLE :  DRV_AT25_Close ( appData  drvHandle ) ;  default :  {  break ;  }  }  }  ",
							" Configuring The Library The AT25 driver library should be configured through the MHC The following figures show the MHC configuration window for the AT25 driver and brief description AT25 Driver with SPI peripheral connected drv_at25_mhc_config_with_spi Configuration Options PLIB Used: Specifies the Peripheral library connected Number Of Clients: Indicates maximum number of clients Always set to one as it supports only a single client EEPROM Page Size: Size of one page of EEPROM memory (in bytes) EEPROM Flash Size: Total Size of the EEPROM memory (in bytes) Depending on the specified EEPROM Flash Size the driver will generate the appropriate number of address bits (8-bit 16-bit or 24-bit) thereby allowing it to communicate with EEPROM of different sizes in the AT25 family Chip Select Pin: FLASH chip select pin (active low) This pin must be configured as GPIO output in \"Pin Settings\" configuration Hold Pin: EEPROM hold pin (active low) This pin must be configured as GPIO output in \"Pin Settings\" configuration Write Protect Pin: EEPROM write protect pin (active low) This pin must be configured as GPIO output in \"Pin Settings\" configuration The AT25 driver keeps the Write Protect pin in logic high state which means writes are always allowed AT25 EEPROM Start Address: Specifies the EEPROM memory start address to be used for Transfer operations The start address will be populated in the device geometry table DRV_AT25_GEOMETRY ",
							" Library Interface AT25 driver library provides the following interfaces: Functions Name Description DRV_AT25_Initialize Initializes the AT25 EEPROM device DRV_AT25_Status Gets the current status of the AT25 driver module DRV_AT25_Open Opens the specified AT25 driver instance and returns a handle to it DRV_AT25_Close Closes the opened-instance of the AT25 driver DRV_AT25_Read Reads 'n' bytes of data from the specified start address of EEPROM DRV_AT25_Write Writes 'n' bytes of data starting at the specified address DRV_AT25_PageWrite Writes one page of data starting at the specified address DRV_AT25_TransferStatusGet Gets the current status of the transfer request DRV_AT25_GeometryGet Returns the geometry of the device DRV_AT25_EventHandlerSet Allows a client to identify a transfer event handling function for the driver to call back when the requested transfer has finished Data types and constants Name Type Description DRV_AT25_TRANSFER_STATUS Enum Defines the data type for AT25 Driver transfer status DRV_AT25_GEOMETRY Struct Defines the data type for AT25 EEPROM Geometry details DRV_AT25_EVENT_HANDLER Typedef Pointer to a AT25 Driver Event handler function ",
							" DRV_AT25_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_AT25_Initialize (  const SYS_MODULE_INDEX drvIndex   const SYS_MODULE_INIT *  const init ) ",
							" Summary Initializes the AT25 EEPROM device ",
							" Description This routine initializes the AT25 EEPROM device driver making it ready for clients to open and use The initialization data is specified by the init parameter It is a single instance driver so this API should be called only once ",
							" Precondition None ",
							" Parameters Param Description drvIndex Identifier for the instance to be initialized init Pointer to the init data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise returns SYS_MODULE_OBJ_INVALID ",
							" Example SYS_MODULE_OBJ sysObjDrvAT25 ; DRV_AT25_PLIB_INTERFACE drvAT25PlibAPI =  {   writeRead =  ( DRV_AT25_PLIB_WRITE_READ ) SPI0_WriteRead    write =  ( DRV_AT25_PLIB_WRITE ) SPI0_Write    read =  ( DRV_AT25_PLIB_READ ) SPI0_Read    isBusy =  ( DRV_AT25_PLIB_IS_BUSY ) SPI0_IsBusy    callbackRegister =  ( DRV_AT25_PLIB_CALLBACK_REGISTER ) SPI0_CallbackRegister   } ; DRV_AT25_INIT drvAT25InitData =  {   spiPlib =   drvAT25PlibAPI    numClients = DRV_AT25_CLIENTS_NUMBER_IDX    pageSize = DRV_AT25_EEPROM_PAGE_SIZE    flashSize = DRV_AT25_EEPROM_FLASH_SIZE    blockStartAddress =  0x0    chipSelectPin = DRV_AT25_CHIP_SELECT_PIN_IDX    holdPin = DRV_AT25_HOLD_PIN_IDX    writeProtectPin = DRV_AT25_WP_PIN_IDX   } ; sysObjDrvAT25 =  DRV_AT25_Initialize ( DRV_AT25_INDEX   ( SYS_MODULE_INIT * )  drvAT25InitData ) ;  ",
							" Remarks This routine must be called before any other DRV_AT25 routine is called This routine should only be called once during system initialization ",
							" DRV_AT25_Status Function ",
							" C SYS_STATUS DRV_AT25_Status (  const SYS_MODULE_INDEX drvIndex ) ",
							" Summary Gets the current status of the AT25 driver module ",
							" Description This routine provides the current status of the AT25 driver module ",
							" Preconditions Function DRV_AT25_Initialize should have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the instance used to initialize driver ",
							" Returns SYS_STATUS_READY - Indicates that the driver is ready and accept requests for new operations SYS_STATUS_UNINITIALIZED - Indicates the driver is not initialized ",
							" Example SYS_STATUS status ; status =  DRV_AT25_Status ( DRV_AT25_INDEX ) ;  if  ( status == SYS_STATUS_READY )  {  // AT25 driver is initialized and ready to accept requests  } ",
							" Remarks None ",
							" DRV_AT25_Open Function ",
							" C DRV_HANDLE DRV_AT25_Open (  const SYS_MODULE_INDEX drvIndex   const DRV_IO_INTENT ioIntent ) ",
							" Summary Opens the specified AT25 driver instance and returns a handle to it ",
							" Description This routine opens the specified AT25 driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver The ioIntent parameter defines how the client interacts with this driver instance This driver is a single client driver so DRV_AT25_Open API should be called only once until driver is closed ",
							" Precondition Function DRV_AT25_Initialize must have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the object instance to be opened ioIntent Zero or more of the values from the enumeration DRV_IO_INTENT \"ORed\" together to indicate the intended use of the driver Note: This driver ignores the ioIntent argument ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) If an error occurs the return value is DRV_HANDLE_INVALID Error can occur if the driver has been already opened once and in use if the driver instance being opened is not initialized or is invalid ",
							" Example DRV_HANDLE handle ; handle =  DRV_AT25_Open ( DRV_AT25_INDEX  DRV_IO_INTENT_READWRITE ) ;  if  ( handle == DRV_HANDLE_INVALID )  {  // Unable to open the driver  // May be the driver is not initialized  } ",
							" Remarks The handle returned is valid until the DRV_AT25_Close routine is called ",
							" DRV_AT25_Close Function ",
							" C void  DRV_AT25_Close (  const DRV_Handle handle ) ",
							" Summary Closes the opened-instance of the AT25 driver ",
							" Description This routine closes opened-instance of the AT25 driver invalidating the handle A new handle must be obtained by calling DRV_AT25_Open before the caller may use the driver again ",
							" Precondition DRV_AT25_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns None ",
							" Example // 'handle' returned from the DRV_AT25_Open  DRV_AT25_Close ( handle ) ;  ",
							" Remarks None ",
							" DRV_AT25_Read Function ",
							" C bool DRV_AT25_Read ( const DRV_HANDLE handle   void  * rxData  uint32_t rxDataLength  uint32_t address ) ",
							" Summary Reads 'n' bytes of data from the specified start address of EEPROM ",
							" Description This function schedules a non-blocking read operation for the requested number of data bytes from the given address of the EEPROM The requesting client should call DRV_AT25_TransferStatusGet API to know the current status of the request OR the requesting client can register a callback function with the driver to get notified of the status ",
							" Precondition DRV_AT25_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine rxData Buffer pointer into which the data read from the DRV_AT25 Flash memory will be placed rxDataLength Total number of bytes to be read address Memory start address from where the data should be read ",
							" Returns true if the read request is accepted false if handle is invalid if the pointer to the receive buffer is NULL or number of bytes to read is 0 if the driver is busy handling another transfer request ",
							" Example # define BUFFER_SIZE 1024  # define MEM_ADDRESS 0x00 uint8_t readBuffer [ BUFFER_SIZE ] ;  // myHandle is the handle returned from DRV_AT25_Open API  // In the below example the transfer status is polled However application can  // register a callback and get notified when the transfer is complete  if  ( DRV_AT25_Read ( myHandle  readBuffer  BUFFER_SIZE  MEM_ADDRESS )  = true )  {  // Error handling here  }  else  {  // Wait for read to be completed  while ( DRV_AT25_TransferStatusGet ( myHandle )  == DRV_AT25_TRANSFER_STATUS_BUSY ) ;  }  ",
							" Remarks None ",
							" DRV_AT25_Write Function ",
							" C bool DRV_AT25_Write ( const DRV_HANDLE handle   void  * txData  uint32_t txDataLength  uint32_t address ) ",
							" Summary Writes 'n' bytes of data starting at the specified address ",
							" Description This function schedules a non-blocking write operation for writing txDataLength bytes of data starting from given address of EEPROM The requesting client should call DRV_AT25_TransferStatusGet API to know the current status of the request OR the requesting client can register a callback function with the driver to get notified of the status ",
							" Preconditions DRV_AT25_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine txData The source buffer containing data to be programmed into AT25 EEPROM txDataLength Total number of bytes to be written address Memory start address from where the data should be written ",
							" Returns true if the write request is accepted false if handle is invalid if the pointer to transmit buffer is NULL or number of bytes to write is 0 if the driver is busy handling another transfer request ",
							" Example # define PAGE_SIZE 256  # define BUFFER_SIZE 1024  # define MEM_ADDRESS 0x00 uint8_t CACHE_ALIGN writeBuffer [ BUFFER_SIZE ] ;  // myHandle is the handle returned from DRV_AT25_Open API  // In the below example the transfer status is polled However application can  // register a callback and get notified when the transfer is complete  if  ( DRV_AT25_Write ( myHandle  writeBuffer  BUFFER_SIZE  MEM_ADDRESS )  = true )  {  // Error handling here  }  else  {  // Wait for write to be completed  while ( DRV_AT25_TransferStatusGet ( myHandle )  == DRV_AT25_TRANSFER_STATUS_BUSY ) ;  } ",
							" Remarks None ",
							" DRV_AT25_PageWrite Function ",
							" C bool DRV_AT25_PageWrite ( const DRV_HANDLE handle   void  * txData  uint32_t address ) ",
							" Summary Writes one page of data starting at the specified address ",
							" Description This function schedules a non-blocking write operation for writing one page of data starting from the given address of the EEPROM The requesting client should call DRV_AT25_TransferStatusGet API to know the current status of the request OR the requesting client can register a callback function with the driver to get notified of the status ",
							" Preconditions DRV_AT25_Open must have been called to obtain a valid opened device handle \"address\" provided must be page boundary aligned in order to avoid overwriting the data in the beginning of the page ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine txData The source buffer containing data to be written to the AT25 EEPROM address Write memory start address from where the data should be written It must be page boundary aligned in order to avoid overwriting the data in the beginning of the page ",
							" Returns true if the write request is accepted false if handle is invalid if the pointer to the transmit data is NULL if the driver is busy handling another transfer request ",
							" Example # define PAGE_SIZE 256  # define MEM_ADDRESS 0x0 uint8_t CACHE_ALIGN writeBuffer [ PAGE_SIZE ] ;  // myHandle is the handle returned from DRV_AT25_Open API  // In the below example the transfer status is polled However application can  // register a callback and get notified when the transfer is complete  if  ( DRV_AT25_PageWrite ( myHandle  writeBuffer  MEM_ADDRESS )  = true )  {  // Error handling here  }  else  {  // Wait for write to be completed  while ( DRV_AT25_TransferStatusGet ( myHandle )  == DRV_AT25_TRANSFER_STATUS_BUSY ) ;  } ",
							" Remarks None ",
							" DRV_AT25_TransferStatusGet Function ",
							" C DRV_AT25_TRANSFER_STATUS DRV_AT25_TransferStatusGet ( const DRV_HANDLE handle ) ",
							" Summary Gets the current status of the transfer request ",
							" Description This routine gets the current status of the transfer request ",
							" Preconditions DRV_AT25_PageWrite DRV_AT25_Write or DRV_AT25_Read must have been called to obtain the status of transfer ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns One of the status element from the enum DRV_AT25_TRANSFER_STATUS ",
							" Example // myHandle is the handle returned from DRV_AT25_Open API  if  ( DRV_AT25_TransferStatusGet ( myHandle )  == DRV_AT25_TRANSFER_STATUS_COMPLETED )  {  // Operation Done  } ",
							" Remarks None ",
							" DRV_AT25_GeometryGet Function ",
							" C bool DRV_AT25_GeometryGet ( const DRV_HANDLE handle  DRV_AT25_GEOMETRY * geometry ) ",
							" Summary Returns the geometry of the device ",
							" Description This API gives the following geometrical details of the DRV_AT25 Flash: Number of Read/Write/Erase Blocks and their size in each region of the device ",
							" Precondition DRV_AT25_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine geometry Pointer to flash device geometry table instance ",
							" Returns true - if able to get the geometry details of the flash false - if handle is invalid ",
							" Example DRV_AT25_GEOMETRY eepromGeometry ; uint32_t readBlockSize  writeBlockSize  eraseBlockSize ; uint32_t nReadBlocks  nReadRegions  totalFlashSize ;  // myHandle is the handle returned from DRV_AT25_Open API  DRV_AT25_GeometryGet ( myHandle    eepromGeometry ) ; readBlockSize = eepromGeometry  readBlockSize ; nReadBlocks = eepromGeometry  readNumBlocks ; nReadRegions = eepromGeometry  readNumRegions ; writeBlockSize = eepromGeometry  writeBlockSize ; eraseBlockSize = eepromGeometry  eraseBlockSize ; totalFlashSize = readBlockSize * nReadBlocks * nReadRegions ;  ",
							" Remarks None ",
							" DRV_AT25_EventHandlerSet Function ",
							" C void  DRV_AT25_EventHandlerSet (  const DRV_HANDLE handle   const DRV_AT25_EVENT_HANDLER eventHandler   const uintptr_t context ) ",
							" Summary Allows a client to identify a transfer event handling function for the driver to call back when the requested transfer has finished ",
							" Description This function allows a client to register a transfer event handling function with the driver to call back when the requested transfer has finished The event handler should be set before the client submits any transfer requests that could generate events The event handler once set persists until the client closes the driver or sets another event handler (which could be a \"NULL\" pointer to indicate no callback) ",
							" Precondition DRV_AT25_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine eventHandler Pointer to the event handler function context The value of parameter will be passed back to the client unchanged when the eventHandler function is called It can be used to identify any client specific data object that identifies the instance of the client module (for example it may be a pointer to the client module's state structure) ",
							" Returns None ",
							" Example # define BUFFER_SIZE 256  # define MEM_ADDRESS 0x00  // myAppObj is an application specific state data object MY_APP_OBJ myAppObj ; uint8_t myBuffer [ BUFFER_SIZE ] ;  // myHandle is the handle returned from DRV_AT25_Open API  // Client registers an event handler with driver This is done once  DRV_AT25_EventHandlerSet ( myHandle  APP_AT25TransferEventHandler   ( uintptr_t )  myAppObj ) ;  if  ( DRV_AT25_Read ( myHandle  myBuffer  BUFFER_SIZE  MEM_ADDRESS )  == false )  {  // Error handling here  }  // The registered event handler is called when the request is complete  void  APP_AT25TransferEventHandler ( DRV_AT25_TRANSFER_STATUS event  uintptr_t context )  {  // The context handle was set to an application specific  // object It is now retrievable easily in the event handler MY_APP_OBJ * pMyAppObj =  ( MY_APP_OBJ * ) context ;  switch ( event )  {  case DRV_AT25_TRANSFER_STATUS_COMPLETED :  {  // This means the data was transferred  break ;  }  case DRV_AT25_TRANSFER_STATUS_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  } ",
							" Remarks If the client does not want to be notified when the queued buffer transfer has completed it does not need to register a callback ",
							" DRV_AT25_TRANSFER_STATUS Enum ",
							" C typedef  enum  {  /* Transfer is being processed */ DRV_AT25_TRANSFER_STATUS_BUSY   /* Transfer is successfully completed*/ DRV_AT25_TRANSFER_STATUS_COMPLETED   /* Transfer had error */ DRV_AT25_TRANSFER_STATUS_ERROR } DRV_AT25_TRANSFER_STATUS ;  ",
							" Summary Defines the data type for AT25 Driver transfer status ",
							" Description This will be used to indicate the current transfer status of the AT25 EEPROM driver operations ",
							" Remarks None ",
							" DRV_AT25_GEOMETRY Struct ",
							" C typedef  struct  { uint32_t readBlockSize ; uint32_t readNumBlocks ; uint32_t readNumRegions ; uint32_t writeBlockSize ; uint32_t writeNumBlocks ; uint32_t writeNumRegions ; uint32_t eraseBlockSize ; uint32_t eraseNumBlocks ; uint32_t eraseNumRegions ; uint32_t blockStartAddress ;  } DRV_AT25_GEOMETRY ;  ",
							" Summary Defines the data type for AT25 EEPROM Geometry details ",
							" Description This will be used to get the geometry details of the attached AT25 EEPROM device ",
							" Remarks None ",
							" DRV_AT25_EVENT_HANDLER Typedef ",
							" C typedef  void  ( * DRV_AT25_EVENT_HANDLER ) ( DRV_AT25_TRANSFER_STATUS event  uintptr_t context ) ;  ",
							" Summary Pointer to a AT25 Driver Event handler function ",
							" Description This data type defines the required function signature for the AT25 driver event handling callback function A client must register a pointer using the event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver The parameters and return values are described here and a partial example implementation is provided ",
							" Parameters Param Description event Identifies the type of event context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Example void  APP_MyTransferEventHandler ( DRV_AT25_TRANSFER_STATUS event  uintptr_t context )  { MY_APP_DATA_STRUCT * pAppData =  ( MY_APP_DATA_STRUCT * ) context ;  switch ( event )  {  case DRV_AT25_TRANSFER_STATUS_COMPLETED :  // Handle the transfer complete event  break ;  case DRV_AT25_TRANSFER_STATUS_ERROR :  default :  // Handle error  break ;  }  } ",
							" Remarks If the event is DRV_AT25_TRANSFER_STATUS_COMPLETED it means that the data was transferred successfully If the event is DRV_AT25_TRANSFER_STATUS_ERROR it means that the data was not transferred successfully The context parameter contains the handle to the client context provided at the time the event handling function was registered using the DRV_AT25_EventHandlerSet function This context handle value is passed back to the client as the \"context\" parameter It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request The event handler function executes in the driver's interrupt context It is recommended of the application to not perform process intensive or blocking operations with in this function The DRV_AT25_Read DRV_AT25_Write and DRV_AT25_PageWrite functions can be called in the event handler to submit a request to the driver ",
							" SPI Flash Drivers This section provides the SPI flash based driver libraries help ",
							" AT25DF Driver This driver provides a non-blocking interface to read write and erase AT25DF Flash memory The library uses the SPI peripheral library (PLIB) to interface with the AT25DF Key Features: Supports Multiple variants of the AT25DF Flash devices Supports a single instance of the AT25DF Flash and a single client to the driver Supports Sector/Bulk/Chip Erase Operations Supports writes to random memory address within page boundaries The library interface is compliant to the block media interface expected by the Memory Driver This allows running a file system on the AT25DF Flash using the Memory Driver and the File System Service The library can be used in both Bare-Metal and RTOS environments ",
							" How the Library Works The AT25DF driver library is a single-client single-instance based driver interface Abstraction Model The AT25DF driver interface provides read write and Erase functions that abstract out the internal workings of the AT25DF driver and the underlying SPI protocol The client can be: Application - Directly access the AT25DF Flash using the APIs provided by the AT25DF Driver library Memory Driver - Application can run a file system on the AT25DF Flash by connecting it to the Memory Driver which can further be connected to the File System Service drv_at25df_abstraction_model Working flow The AT25DF Driver Library registers an event handler with the underlying SPI peripheral library (PLIB) This event handler is called by the PLIB from the interrupt context to notify the AT25DF driver that the requested transfer is complete The library's state machine is driven from the interrupt context Once a transfer is complete a callback (if registered by the application) is given to the application from the interrupt context The library does not support queuing of more than one requests The application must check and ensure that any previous request is completed before submitting a new one This can be done either by polling the status of the data transfer or by registering a callback ",
							" Using The Library The AT25DF driver provides non-blocking API's to read write and erase AT25DF Flash memory The AT25DF driver can be used in following ways: To perform reads writes and erase from/to any Flash memory address with number of bytes spanning multiple pages To perform page write to AT25DF Flash Here the memory start address must be aligned to the page boundary To perform Sector/Bulk/Chip Erase operations To interface with the Memory driver to perform block operations on the AT25DF Flash Application can either register a callback to get notified once the data transfer is complete or can poll the status of the data transfer Example application to Erase Write and Read AT25DF Flash Memory /* Erase-Write-Read 2 Sector of Data (4096 *2)*/  # define BUFFER_SIZE 8192  # define MEM_ADDRESS 0x0 APP_DATA CACHE_ALIGN appData ;  static uint32_t erase_index =  0 ;  static uint32_t write_index =  0 ;  void  APP_FLASH_EventHandler ( DRV_AT25DF_TRANSFER_STATUS event  uintptr_t context )  {  switch ( event )  {  case DRV_AT25DF_TRANSFER_STATUS_COMPLETED :  { appData  isTransferDone = true ;  break ;  }  case DRV_AT25DF_TRANSFER_STATUS_ERROR :  default :  { appData  isTransferDone = false ;  break ;  }  }  }  void APP_Initialize (  void  )  { uint32_t i =  0 ;  /* Place the App state machine in its initial state */ appData  state = APP_STATE_INIT ;  for  ( i =  0 ; i  BUFFER_SIZE ; i ++ )  { appData  writeBuffer [ i ]  = i ;  }  }  void APP_Tasks (  void  )  {  /* Check the application's current state */  switch  ( appData  state )  {  /* Application's initial state */  case APP_STATE_INIT :  {  if  ( DRV_AT25DF_Status ( DRV_AT25DF_INDEX )  == SYS_STATUS_READY )  { appData  state = APP_STATE_OPEN_DRIVER ;  }  break ;  }  case APP_STATE_OPEN_DRIVER :  { appData  handle =  DRV_AT25DF_Open ( DRV_AT25DF_INDEX  DRV_IO_INTENT_READWRITE ) ;  if  ( appData  handle = DRV_HANDLE_INVALID )  {  DRV_AT25DF_EventHandlerSet ( appData  handle  APP_FLASH_EventHandler   0 ) ; appData  state = APP_STATE_GEOMETRY_GET ;  }  break ;  }  case APP_STATE_GEOMETRY_GET :  {  if  ( DRV_AT25DF_GeometryGet ( appData  handle    appData  geometry )  = true )  { appData  state = APP_STATE_ERROR ;  break ;  } appData  state = APP_STATE_GEOMETRY_WAIT ;  break ;  }  case APP_STATE_GEOMETRY_WAIT :  {  if  ( appData  isTransferDone == true )  { appData  state = APP_STATE_ERASE_FLASH ; erase_index =  0 ; write_index =  0 ; appData  isTransferDone = false ;  }  else  if  ( DRV_AT25DF_TransferStatusGet ( appData  handle )  == DRV_AT25DF_TRANSFER_STATUS_ERROR )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_ERASE_FLASH :  {  if  ( DRV_AT25DF_SectorErase ( appData  handle   ( MEM_ADDRESS + erase_index ) )  = true )  { appData  state = APP_STATE_ERROR ;  } appData  state = APP_STATE_ERASE_WAIT ;  break ;  }  case APP_STATE_ERASE_WAIT :  {  if  ( appData  isTransferDone == true )  { erase_index += appData  geometry  erase_blockSize ;  if  ( erase_index  BUFFER_SIZE )  { appData  state = APP_STATE_ERASE_FLASH ;  }  else  { appData  state = APP_STATE_WRITE_MEMORY ;  } appData  isTransferDone = false ;  }  else  if  ( DRV_AT25DF_TransferStatusGet ( appData  handle )  == DRV_AT25DF_TRANSFER_ERROR_UNKNOWN )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WRITE_MEMORY :  {  if  ( DRV_AT25DF_PageWrite ( appData  handle   ( uint32_t * )  appData  writeBuffer [ write_index ]   ( MEM_ADDRESS + write_index ) )  = true )  { appData  state = APP_STATE_ERROR ;  break ;  } appData  state = APP_STATE_WRITE_WAIT ;  break ;  }  case APP_STATE_WRITE_WAIT :  {  if  ( appData  isTransferDone == true )  { write_index += appData  geometry  write_blockSize ;  if  ( write_index  BUFFER_SIZE )  { appData  state = APP_STATE_WRITE_MEMORY ;  }  else  { appData  state = APP_STATE_READ_MEMORY ;  } appData  isTransferDone = false ;  }  else  if  ( DRV_AT25DF_TransferStatusGet ( appData  handle )  == DRV_AT25DF_TRANSFER_ERROR_UNKNOWN )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_READ_MEMORY :  {  if  ( DRV_AT25DF_Read ( appData  handle   ( uint32_t * )  appData  readBuffer  BUFFER_SIZE  MEM_ADDRESS )  = true )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_READ_WAIT ;  }  break ;  }  case APP_STATE_READ_WAIT :  {  if  ( appData  isTransferDone == true )  { appData  isTransferDone = false ; appData  state = APP_STATE_VERIFY_DATA ;  }  else  if  ( DRV_AT25DF_TransferStatusGet ( appData  handle )  == DRV_AT25DF_TRANSFER_ERROR_UNKNOWN )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_VERIFY_DATA :  {  if  (  memcmp ( appData  writeBuffer  appData  readBuffer  BUFFER_SIZE ) )  { appData  state = APP_STATE_SUCCESS ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_SUCCESS :  {  DRV_AT25DF_Close ( appData  handle ) ;  break ;  }  case APP_STATE_ERROR :  default :  {  DRV_AT25DF_Close ( appData  handle ) ;  break ;  }  }  }  ",
							" Configuring The Library The AT25DF driver library should be configured through the MHC The following figures show the MHC configuration window for the AT25DF driver and brief description AT25DF Driver with SPI peripheral connected drv_at25df_mhc_config_with_spi AT25DF Driver with connection to Memory Driver drv_at25df_mhc_config_with_drv_mem Configuration Options PLIB Used: Specifies the Peripheral library connected Number Of Clients: Indicates maximum number of clients Always set to one as it supports only a single client Page Size: Size of one page of FLASH memory (in bytes) Flash Size: Total Size of the FLASH memory (in bytes) Chip Select Pin: FLASH chip select pin (active low) This pin must be configured as GPIO output in \"Pin Settings\" configuration AT25DF Flash Start Address: Specifies the flash memory start address to be used for Transfer operations The start address will be populated in the device geometry table DRV_AT25DF_GEOMETRY AT25DF Erase Buffer Size: This option appears only when the AT25DF driver is connected to the Memory driver for block operations Specifies the size for erase buffer used by Memory driver The size of the buffer should be equal to erase sector size as the memory driver will call DRV_AT25DF_SectorErase ",
							" Library Interface AT25DF driver library provides the following interfaces: Functions Name Description DRV_AT25DF_Initialize Initializes the AT25DF FLASH device DRV_AT25DF_Status Gets the current status of the AT25DF driver module DRV_AT25DF_Open Opens the specified AT25DF driver instance and returns a handle to it DRV_AT25DF_Close Closes the opened-instance of the AT25DF driver DRV_AT25DF_Read Reads 'n' bytes of data from the specified start address of FLASH DRV_AT25DF_Write Writes 'n' bytes of data starting at the specified address DRV_AT25DF_PageWrite Writes one page of data starting at the specified address DRV_AT25DF_SectorErase Erase the sector from the specified block start address DRV_AT25DF_BlockErase Erase a block from the specified block start address DRV_AT25DF_ChipErase Erase entire flash memory DRV_AT25DF_TransferStatusGet Gets the current status of the transfer request DRV_AT25DF_GeometryGet Returns the geometry of the device DRV_AT25DF_EventHandlerSet Allows a client to identify a transfer event handling function for the driver to call back when the requested transfer has finished Data types and constants Name Type Description DRV_AT25DF_TRANSFER_STATUS Enum Defines the data type for AT25DF Driver transfer status DRV_AT25DF_GEOMETRY Struct Defines the data type for AT25DF FLASH Geometry details DRV_AT25DF_EVENT_HANDLER Typedef Pointer to a AT25DF Driver Event handler function ",
							" DRV_AT25DF_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_AT25DF_Initialize (  const SYS_MODULE_INDEX drvIndex   const SYS_MODULE_INIT *  const init ) ",
							" Summary Initializes the AT25DF FLASH device ",
							" Description This routine initializes the AT25DF FLASH device driver making it ready for clients to open and use The initialization data is specified by the init parameter It is a single instance driver so this API should be called only once ",
							" Precondition None ",
							" Parameters Param Description drvIndex Identifier for the instance to be initialized init Pointer to the init data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise returns SYS_MODULE_OBJ_INVALID ",
							" Example SYS_MODULE_OBJ sysObjDrvAT25DF ; DRV_AT25DF_PLIB_INTERFACE drvAT25DFPlibAPI =  {   writeRead =  ( DRV_AT25DF_PLIB_WRITE_READ ) SPI0_WriteRead    write =  ( DRV_AT25DF_PLIB_WRITE ) SPI0_Write    read =  ( DRV_AT25DF_PLIB_READ ) SPI0_Read    isBusy =  ( DRV_AT25DF_PLIB_IS_BUSY ) SPI0_IsBusy    callbackRegister =  ( DRV_AT25DF_PLIB_CALLBACK_REGISTER ) SPI0_CallbackRegister   } ; DRV_AT25DF_INIT drvAT25DFInitData =  {   spiPlib =   drvAT25DFPlibAPI    numClients = DRV_AT25DF_CLIENTS_NUMBER_IDX    pageSize = DRV_AT25DF_PAGE_SIZE    flashSize = DRV_AT25DF_FLASH_SIZE    blockStartAddress =  0x0    chipSelectPin = DRV_AT25DF_CHIP_SELECT_PIN_IDX } ; sysObjDrvAT25DF =  DRV_AT25DF_Initialize ( DRV_AT25DF_INDEX   ( SYS_MODULE_INIT * )  drvAT25DFInitData ) ;  ",
							" Remarks This routine must be called before any other DRV_AT25DF routine is called This routine should only be called once during system initialization ",
							" DRV_AT25DF_Status Function ",
							" C SYS_STATUS DRV_AT25DF_Status (  const SYS_MODULE_INDEX drvIndex ) ",
							" Summary Gets the current status of the AT25DF driver module ",
							" Description This routine provides the current status of the AT25DF driver module ",
							" Preconditions Function DRV_AT25DF_Initialize should have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the instance used to initialize driver ",
							" Returns SYS_STATUS_READY - Indicates that the driver is ready and accept requests for new operations SYS_STATUS_UNINITIALIZED - Indicates the driver is not initialized ",
							" Example SYS_STATUS status ; status =  DRV_AT25DF_Status ( DRV_AT25DF_INDEX ) ;  if  ( status == SYS_STATUS_READY )  {  // AT25DF driver is initialized and ready to accept requests  } ",
							" Remarks None ",
							" DRV_AT25DF_Open Function ",
							" C DRV_HANDLE DRV_AT25DF_Open (  const SYS_MODULE_INDEX drvIndex   const DRV_IO_INTENT ioIntent ) ",
							" Summary Opens the specified AT25DF driver instance and returns a handle to it ",
							" Description This routine opens the specified AT25DF driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver The ioIntent parameter defines how the client interacts with this driver instance This driver is a single client driver so DRV_AT25DF_Open API should be called only once until driver is closed ",
							" Precondition Function DRV_AT25DF_Initialize must have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the object instance to be opened ioIntent Zero or more of the values from the enumeration DRV_IO_INTENT \"ORed\" together to indicate the intended use of the driver Note: This driver ignores the ioIntent argument ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) If an error occurs the return value is DRV_HANDLE_INVALID Error can occur if the driver has been already opened once and in use if the driver instance being opened is not initialized or is invalid ",
							" Example DRV_HANDLE handle ; handle =  DRV_AT25DF_Open ( DRV_AT25DF_INDEX  DRV_IO_INTENT_READWRITE ) ;  if  ( handle == DRV_HANDLE_INVALID )  {  // Unable to open the driver  // May be the driver is not initialized  } ",
							" Remarks The handle returned is valid until the DRV_AT25DF_Close routine is called ",
							" DRV_AT25DF_Close Function ",
							" C void  DRV_AT25DF_Close (  const DRV_Handle handle ) ",
							" Summary Closes the opened-instance of the AT25DF driver ",
							" Description This routine closes opened-instance of the AT25DF driver invalidating the handle A new handle must be obtained by calling DRV_AT25DF_Open before the caller may use the driver again ",
							" Precondition DRV_AT25DF_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns None ",
							" Example // 'handle' returned from the DRV_AT25DF_Open  DRV_AT25DF_Close ( handle ) ;  ",
							" Remarks None ",
							" DRV_AT25DF_Read Function ",
							" C bool DRV_AT25DF_Read ( const DRV_HANDLE handle   void  * rxData  uint32_t rxDataLength  uint32_t address ) ",
							" Summary Reads 'n' bytes of data from the specified start address of FLASH ",
							" Description This function schedules a non-blocking read operation for the requested number of data bytes from the given address of the FLASH The requesting client should call DRV_AT25DF_TransferStatusGet API to know the current status of the request OR the requesting client can register a callback function with the driver to get notified of the status ",
							" Precondition DRV_AT25DF_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine rxData Buffer pointer into which the data read from the DRV_AT25DF Flash memory will be placed rxDataLength Total number of bytes to be read address Memory start address from where the data should be read ",
							" Returns true if the read request is accepted false if handle is invalid if the pointer to the receive buffer is NULL or number of bytes to read is 0 if the driver is busy handling another transfer request ",
							" Example # define BUFFER_SIZE 1024  # define MEM_ADDRESS 0x00 uint8_t readBuffer [ BUFFER_SIZE ] ;  // myHandle is the handle returned from DRV_AT25DF_Open API  // In the below example the transfer status is polled However application can  // register a callback and get notified when the transfer is complete  if  ( DRV_AT25DF_Read ( myHandle  readBuffer  BUFFER_SIZE  MEM_ADDRESS )  = true )  {  // Error handling here  }  else  {  // Wait for read to be completed  while ( DRV_AT25DF_TransferStatusGet ( myHandle )  == DRV_AT25DF_TRANSFER_STATUS_BUSY ) ;  }  ",
							" Remarks None ",
							" DRV_AT25DF_Write Function ",
							" C bool DRV_AT25DF_Write ( const DRV_HANDLE handle   void  * txData  uint32_t txDataLength  uint32_t address ) ",
							" Summary Writes 'n' bytes of data starting at the specified address ",
							" Description This function schedules a non-blocking write operation for writing txDataLength bytes of data starting from given address of FLASH The requesting client should call DRV_AT25DF_TransferStatusGet API to know the current status of the request OR the requesting client can register a callback function with the driver to get notified of the status ",
							" Preconditions DRV_AT25DF_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine txData The source buffer containing data to be programmed into AT25DF FLASH txDataLength Total number of bytes to be written address Memory start address from where the data should be written ",
							" Returns true if the write request is accepted false if handle is invalid if the pointer to transmit buffer is NULL or number of bytes to write is 0 if the driver is busy handling another transfer request ",
							" Example # define PAGE_SIZE 256  # define BUFFER_SIZE 1024  # define MEM_ADDRESS 0x00 uint8_t CACHE_ALIGN writeBuffer [ BUFFER_SIZE ] ;  // myHandle is the handle returned from DRV_AT25DF_Open API  // In the below example the transfer status is polled However application can  // register a callback and get notified when the transfer is complete  if  ( DRV_AT25DF_Write ( myHandle  writeBuffer  BUFFER_SIZE  MEM_ADDRESS )  = true )  {  // Error handling here  }  else  {  // Wait for write to be completed  while ( DRV_AT25DF_TransferStatusGet ( myHandle )  == DRV_AT25DF_TRANSFER_STATUS_BUSY ) ;  } ",
							" Remarks None ",
							" DRV_AT25DF_PageWrite Function ",
							" C bool DRV_AT25DF_PageWrite ( const DRV_HANDLE handle   void  * txData  uint32_t address ) ",
							" Summary Writes one page of data starting at the specified address ",
							" Description This function schedules a non-blocking write operation for writing one page of data starting from the given address of the FLASH The requesting client should call DRV_AT25DF_TransferStatusGet API to know the current status of the request OR the requesting client can register a callback function with the driver to get notified of the status ",
							" Preconditions DRV_AT25DF_Open must have been called to obtain a valid opened device handle \"address\" provided must be page boundary aligned in order to avoid overwriting the data in the beginning of the page ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine txData The source buffer containing data to be written to the AT25DF FLASH address Write memory start address from where the data should be written It must be page boundary aligned in order to avoid overwriting the data in the beginning of the page ",
							" Returns true if the write request is accepted false if handle is invalid if the pointer to the transmit data is NULL if the driver is busy handling another transfer request ",
							" Example # define PAGE_SIZE 256  # define MEM_ADDRESS 0x0 uint8_t CACHE_ALIGN writeBuffer [ PAGE_SIZE ] ;  // myHandle is the handle returned from DRV_AT25DF_Open API  // In the below example the transfer status is polled However application can  // register a callback and get notified when the transfer is complete  if  ( DRV_AT25DF_PageWrite ( myHandle  writeBuffer  MEM_ADDRESS )  = true )  {  // Error handling here  }  else  {  // Wait for write to be completed  while ( DRV_AT25DF_TransferStatusGet ( myHandle )  == DRV_AT25DF_TRANSFER_STATUS_BUSY ) ;  } ",
							" Remarks None ",
							" DRV_AT25DF_SectorErase Function ",
							" C bool DRV_AT25DF_SectorErase ( const DRV_HANDLE handle  uint32_t address ) ; ",
							" Summary Erase the sector from the specified block start address ",
							" Description This function schedules a non-blocking sector erase operation of flash memory Each Sector is of 4 KByte The requesting client should call DRV_AT25DF_TransferStatusGet() API to know the current status of the request ",
							" Preconditions The DRV_AT25DF_Open() routine must have been called for the specified AT25DF driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine address block start address from where a sector needs to be erased ",
							" Returns true if the erase request is successfully sent to the flash false if Write enable fails before sending sector erase command to flash if sector erase command itself fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_AT25DF_Open uint32_t sectorStart =  0 ;  if ( DRV_AT25DF_SectorErase ( handle  sectorStart )  == false )  {  // Error handling here  }  // Wait for erase to be completed  while ( DRV_AT25DF_TransferStatusGet ( handle )  == DRV_AT25DF_TRANSFER_STATUS_BUSY ) ;  ",
							" Remarks This routine will block wait until erase request is submitted successfully Client should wait until erase is complete to send next transfer request ",
							" DRV_AT25DF_BlockErase Function ",
							" C bool DRV_AT25DF_BlockErase ( const DRV_HANDLE handle  uint32_t address ) ; ",
							" Summary Erase a block from the specified block start address ",
							" Description This function schedules a non-blocking block erase operation of flash memory The block size is 64 KByte The requesting client should call DRV_AT25DF_TransferStatusGet() API to know the current status of the request ",
							" Preconditions The DRV_AT25DF_Open() routine must have been called for the specified AT25DF driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine address block start address to be erased ",
							" Returns true if the erase request is successfully sent to the flash false if Write enable fails before sending sector erase command to flash if block erase command itself fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_AT25DF_Open uint32_t blockStart =  0 ;  if ( DRV_AT25DF_BlockErase ( handle  blockStart )  == false )  {  // Error handling here  }  // Wait for erase to be completed  while ( DRV_AT25DF_TransferStatusGet ( handle )  == DRV_AT25DF_TRANSFER_STATUS_BUSY ) ;  ",
							" Remarks This routine will block wait until erase request is submitted successfully Client should wait until erase is complete to send next transfer request ",
							" DRV_AT25DF_ChipErase Function ",
							" C bool DRV_AT25DF_ChipErase ( const DRV_HANDLE handle ) ; ",
							" Summary Erase entire flash memory ",
							" Description This function schedules a non-blocking chip erase operation of flash memory The requesting client should call DRV_AT25DF_TransferStatusGet() API to know the current status of the request ",
							" Preconditions The DRV_AT25DF_Open() routine must have been called for the specified AT25DF driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns true if the erase request is successfully sent to the flash false if Write enable fails before sending sector erase command to flash if chip erase command itself fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_AT25DF_Open  if ( DRV_AT25DF_ChipErase ( handle )  == false )  {  // Error handling here  }  // Wait for erase to be completed  while ( DRV_AT25DF_TransferStatusGet ( handle )  == DRV_AT25DF_TRANSFER_STATUS_BUSY ) ;  ",
							" Remarks This routine will block wait until erase request is submitted successfully Client should wait until erase is complete to send next transfer request ",
							" DRV_AT25DF_TransferStatusGet Function ",
							" C DRV_AT25DF_TRANSFER_STATUS DRV_AT25DF_TransferStatusGet ( const DRV_HANDLE handle ) ",
							" Summary Gets the current status of the transfer request ",
							" Description This routine gets the current status of the transfer request ",
							" Preconditions DRV_AT25DF_PageWrite DRV_AT25DF_Write or DRV_AT25DF_Read must have been called to obtain the status of transfer ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns One of the status element from the enum DRV_AT25DF_TRANSFER_STATUS ",
							" Example // myHandle is the handle returned from DRV_AT25DF_Open API  if  ( DRV_AT25DF_TransferStatusGet ( myHandle )  == DRV_AT25DF_TRANSFER_STATUS_COMPLETED )  {  // Operation Done  } ",
							" Remarks None ",
							" DRV_AT25DF_GeometryGet Function ",
							" C bool DRV_AT25DF_GeometryGet ( const DRV_HANDLE handle  DRV_AT25DF_GEOMETRY * geometry ) ",
							" Summary Returns the geometry of the device ",
							" Description This API gives the following geometrical details of the DRV_AT25DF Flash: Number of Read/Write/Erase Blocks and their size in each region of the device ",
							" Precondition DRV_AT25DF_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine geometry Pointer to flash device geometry table instance ",
							" Returns true - if able to get the geometry details of the flash false - if handle is invalid ",
							" Example DRV_AT25DF_GEOMETRY flashGeometry ; uint32_t readBlockSize  writeBlockSize  eraseBlockSize ; uint32_t nReadBlocks  nReadRegions  totalFlashSize ;  // myHandle is the handle returned from DRV_AT25DF_Open API  DRV_AT25DF_GeometryGet ( myHandle    flashGeometry ) ; readBlockSize = flashGeometry  readBlockSize ; nReadBlocks = flashGeometry  readNumBlocks ; nReadRegions = flashGeometry  readNumRegions ; writeBlockSize = flashGeometry  writeBlockSize ; eraseBlockSize = flashGeometry  eraseBlockSize ; totalFlashSize = readBlockSize * nReadBlocks * nReadRegions ;  ",
							" Remarks None ",
							" DRV_AT25DF_EventHandlerSet Function ",
							" C void  DRV_AT25DF_EventHandlerSet (  const DRV_HANDLE handle   const DRV_AT25DF_EVENT_HANDLER eventHandler   const uintptr_t context ) ",
							" Summary Allows a client to identify a transfer event handling function for the driver to call back when the requested transfer has finished ",
							" Description This function allows a client to register a transfer event handling function with the driver to call back when the requested transfer has finished The event handler should be set before the client submits any transfer requests that could generate events The event handler once set persists until the client closes the driver or sets another event handler (which could be a \"NULL\" pointer to indicate no callback) ",
							" Precondition DRV_AT25DF_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine eventHandler Pointer to the event handler function context The value of parameter will be passed back to the client unchanged when the eventHandler function is called It can be used to identify any client specific data object that identifies the instance of the client module (for example it may be a pointer to the client module's state structure) ",
							" Returns None ",
							" Example # define BUFFER_SIZE 256  # define MEM_ADDRESS 0x00  // myAppObj is an application specific state data object MY_APP_OBJ myAppObj ; uint8_t myBuffer [ BUFFER_SIZE ] ;  // myHandle is the handle returned from DRV_AT25DF_Open API  // Client registers an event handler with driver This is done once  DRV_AT25DF_EventHandlerSet ( myHandle  APP_AT25DFTransferEventHandler   ( uintptr_t )  myAppObj ) ;  if  ( DRV_AT25DF_Read ( myHandle  myBuffer  BUFFER_SIZE  MEM_ADDRESS )  == false )  {  // Error handling here  }  // The registered event handler is called when the request is complete  void  APP_AT25DFTransferEventHandler ( DRV_AT25DF_TRANSFER_STATUS event  uintptr_t context )  {  // The context handle was set to an application specific  // object It is now retrievable easily in the event handler MY_APP_OBJ * pMyAppObj =  ( MY_APP_OBJ * ) context ;  switch ( event )  {  case DRV_AT25DF_TRANSFER_STATUS_COMPLETED :  {  // This means the data was transferred  break ;  }  case DRV_AT25DF_TRANSFER_STATUS_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  } ",
							" Remarks If the client does not want to be notified when the queued buffer transfer has completed it does not need to register a callback ",
							" DRV_AT25DF_TRANSFER_STATUS Enum ",
							" C typedef  enum  {  /* Transfer is being processed */ DRV_AT25DF_TRANSFER_STATUS_BUSY   /* Transfer is successfully completed*/ DRV_AT25DF_TRANSFER_STATUS_COMPLETED   /* Transfer had error */ DRV_AT25DF_TRANSFER_STATUS_ERROR } DRV_AT25DF_TRANSFER_STATUS ;  ",
							" Summary Defines the data type for AT25DF Driver transfer status ",
							" Description This will be used to indicate the current transfer status of the AT25DF FLASH driver operations ",
							" Remarks None ",
							" DRV_AT25DF_GEOMETRY Struct ",
							" C typedef  struct  { uint32_t readBlockSize ; uint32_t readNumBlocks ; uint32_t readNumRegions ; uint32_t writeBlockSize ; uint32_t writeNumBlocks ; uint32_t writeNumRegions ; uint32_t eraseBlockSize ; uint32_t eraseNumBlocks ; uint32_t eraseNumRegions ; uint32_t blockStartAddress ;  } DRV_AT25DF_GEOMETRY ;  ",
							" Summary Defines the data type for AT25DF FLASH Geometry details ",
							" Description This will be used to get the geometry details of the attached AT25DF FLASH device ",
							" Remarks None ",
							" DRV_AT25DF_EVENT_HANDLER Typedef ",
							" C typedef  void  ( * DRV_AT25DF_EVENT_HANDLER ) ( DRV_AT25DF_TRANSFER_STATUS event  uintptr_t context ) ;  ",
							" Summary Pointer to a AT25DF Driver Event handler function ",
							" Description This data type defines the required function signature for the AT25DF driver event handling callback function A client must register a pointer using the event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver The parameters and return values are described here and a partial example implementation is provided ",
							" Parameters Param Description event Identifies the type of event context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Example void  APP_MyTransferEventHandler ( DRV_AT25DF_TRANSFER_STATUS event  uintptr_t context )  { MY_APP_DATA_STRUCT * pAppData =  ( MY_APP_DATA_STRUCT * ) context ;  switch ( event )  {  case DRV_AT25DF_TRANSFER_STATUS_COMPLETED :  {  // Handle the transfer complete event  break ;  }  case DRV_AT25DF_TRANSFER_STATUS_ERROR :  default :  {  // Handle error  break ;  }  }  } ",
							" Remarks If the event is DRV_AT25DF_TRANSFER_STATUS_COMPLETED it means that the data was transferred successfully If the event is DRV_AT25DF_TRANSFER_STATUS_ERROR it means that the data was not transferred successfully The context parameter contains the handle to the client context provided at the time the event handling function was registered using the DRV_AT25DF_EventHandlerSet function This context handle value is passed back to the client as the \"context\" parameter It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request The event handler function executes in the driver's interrupt context It is recommended of the application to not perform process intensive or blocking operations with in this function The DRV_AT25DF_Read DRV_AT25DF_Write and DRV_AT25DF_PageWrite functions can be called in the event handler to submit a request to the driver ",
							" SQI Flash Drivers This section provides the SQI flash based driver libraries help ",
							" MX25L Driver This driver provides a non-blocking interface to read write and erase MX25L Flash memory The driver uses the QSPI peripheral library to interface with the MX25L Flash Key Features: Supports Multiple variants of the MX25L Flash devices Supports a single instance of the MX25L Flash and a single client to the driver Supports Sector/Bulk/Chip Erase Operations Supports writes to random memory address within page boundaries The library interface is compliant to the block media interface expected by the Memory Driver This allows running a file system on the AT25DF Flash using the Memory Driver and the File System Service The library can be used in both Bare-Metal and RTOS environments ",
							" How the Library Works The MX25L driver library is a single-client single-instance based driver interface Abstraction Model The MX25L driver interface provides read write and Erase functions that abstract out the internal workings of the MX25L driver and the underlying QSPI protocol The client can be: Application - Directly access the MX25L Flash using the APIs provided by the MX25L Driver library Memory Driver - Application can run a file system on the MX25L Flash by connecting it to the Memory Driver which can further be connected to the File System Service drv_mx25l_abstraction_model Working flow The MX25L Driver performs initialization and puts the driver to ready state This status of the driver can be checked using DRV_MX25L_Status() The MX25L driver library performs set of flash operations during DRV_MX25L_Initialize() Resets the Flash Configures the flash device to QUAD IO Mode if underlying peripheral library is running in QSPI/SQI mode Unlocks the flash if it has been opened in write mode When the client requests for device geometry it queries for the JEDEC-Id and populates the geometry table DRV_MX25L_GEOMETRY appropriately The driver does not support queuing of more than one requests The application must check and ensure that any previous request is completed before submitting a new one This can be done by polling the status of data transfer using DRV_MX25L_TransferStatusGet() ",
							" Using The Library The MX25L driver provides non-blocking API's to read write and erase MX25L Flash memory The MX25L driver can be used in following ways: To perform page write to MX25L Flash Here the memory start address must be aligned to the page boundary To perform Sector/Bulk/Chip Erase operations To unlock flash before performing Erase/Write operations Done as part of DRV_MX25L_Open() To read flash JEDEC-ID To interface with the Memory driver to perform block operations on the MX25L Flash Note: The client should poll for the status of the data transfer Example application to Erase Write and Read MX25L Flash Memory /* Erase-Write-Read 2 Sector of Data (4096 *2)*/  # define BUFFER_SIZE 8192  # define MEM_ADDRESS 0x0 APP_DATA CACHE_ALIGN appData ;  static uint32_t erase_index =  0 ;  static uint32_t write_index =  0 ;  void APP_Initialize (  void  )  { uint32_t i =  0 ;  /* Place the App state machine in its initial state */ appData  state = APP_STATE_INIT ;  for  ( i =  0 ; i  BUFFER_SIZE ; i ++ )  { appData  writeBuffer [ i ]  = i ;  }  }  void APP_Tasks (  void  )  { DRV_MX25L_TRANSFER_STATUS transferStatus = DRV_MX25L_TRANSFER_ERROR_UNKNOWN ;  /* Check the application's current state */  switch  ( appData  state )  {  /* Application's initial state */  case APP_STATE_INIT :  {  if  ( DRV_MX25L_Status ( DRV_MX25L_INDEX )  == SYS_STATUS_READY )  { appData  state = APP_STATE_OPEN_DRIVER ;  }  break ;  }  case APP_STATE_OPEN_DRIVER :  { appData  handle =  DRV_MX25L_Open ( DRV_MX25L_INDEX  DRV_IO_INTENT_READWRITE ) ;  if  ( appData  handle = DRV_HANDLE_INVALID )  { appData  state = APP_STATE_GEOMETRY_GET ;  }  break ;  }  case APP_STATE_GEOMETRY_GET :  {  if  ( DRV_MX25L_GeometryGet ( appData  handle    appData  geometry )  = true )  { appData  state = APP_STATE_ERROR ;  break ;  } erase_index =  0 ; write_index =  0 ; appData  state = APP_STATE_ERASE_FLASH ;  break ;  }  case APP_STATE_ERASE_FLASH :  {  if  ( DRV_MX25L_SectorErase ( appData  handle   ( MEM_ADDRESS + erase_index ) )  = true )  { appData  state = APP_STATE_ERROR ;  } appData  state = APP_STATE_ERASE_WAIT ;  break ;  }  case APP_STATE_ERASE_WAIT :  { transferStatus =  DRV_MX25L_TransferStatusGet ( appData  handle ) ;  if ( transferStatus == DRV_MX25L_TRANSFER_COMPLETED )  { erase_index += appData  geometry  erase_blockSize ;  if  ( erase_index  BUFFER_SIZE )  { appData  state = APP_STATE_ERASE_FLASH ;  }  else  { appData  state = APP_STATE_WRITE_MEMORY ;  }  }  else  if  ( transferStatus == DRV_MX25L_TRANSFER_ERROR_UNKNOWN )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WRITE_MEMORY :  {  if  ( DRV_MX25L_PageWrite ( appData  handle   ( uint32_t * )  appData  writeBuffer [ write_index ]   ( MEM_ADDRESS + write_index ) )  = true )  { appData  state = APP_STATE_ERROR ;  break ;  } appData  state = APP_STATE_WRITE_WAIT ;  break ;  }  case APP_STATE_WRITE_WAIT :  { transferStatus =  DRV_MX25L_TransferStatusGet ( appData  handle ) ;  if ( transferStatus == DRV_MX25L_TRANSFER_COMPLETED )  { write_index += appData  geometry  write_blockSize ;  if  ( write_index  BUFFER_SIZE )  { appData  state = APP_STATE_WRITE_MEMORY ;  }  else  { appData  state = APP_STATE_READ_MEMORY ;  }  }  else  if  ( transferStatus == DRV_MX25L_TRANSFER_ERROR_UNKNOWN )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_READ_MEMORY :  {  if  ( DRV_MX25L_Read ( appData  handle   ( uint32_t * )  appData  readBuffer  BUFFER_SIZE  MEM_ADDRESS )  = true )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_VERIFY_DATA ;  }  break ;  }  case APP_STATE_VERIFY_DATA :  {  if  (  memcmp ( appData  writeBuffer  appData  readBuffer  BUFFER_SIZE ) )  { appData  state = APP_STATE_SUCCESS ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_SUCCESS :  {  DRV_MX25L_Close ( appData  handle ) ;  break ;  }  case APP_STATE_ERROR :  default :  {  DRV_MX25L_Close ( appData  handle ) ;  break ;  }  }  }  ",
							" Configuring The Library The MX25L driver library should be configured through the MHC The following figures show the MHC configuration window for the MX25L driver and brief description MX25L Driver with QSPI peripheral in SQI mode connected drv_mx25l_mhc_config_with_qspi_sqi MX25L Driver with connection to Memory Driver drv_mx25l_mhc_config_with_drv_mem Configuration Options PLIB Used: Specifies the Peripheral library connected Number Of Clients: Indicates maximum number of clients Always set to one as it supports only a single client MX25L Start Address: Specifies the flash memory start address to be used for Transfer operations The start address will be populated in the device geometry table DRV_MX25L_GEOMETRY MX25L Erase Buffer Size: This option appears only when the MX25L driver is connected to the Memory driver for block operations Specifies the size for erase buffer used by Memory driver The size of the buffer should be equal to erase sector size as the memory driver will call DRV_MX25L_SectorErase ",
							" Library Interface MX25L driver library provides the following interfaces: Functions Name Description DRV_MX25L_Initialize Initializes the MX25L Driver DRV_MX25L_Open Opens the specified MX25L driver instance and returns a handle to it DRV_MX25L_Close Closes an opened-instance of the MX25L driver DRV_MX25L_Status Gets the current status of the MX25L driver module DRV_MX25L_ResetFlash Reset the flash device to standby mode DRV_MX25L_ReadJedecId Reads JEDEC-ID of the flash device DRV_MX25L_SectorErase Erase the sector from the specified block start address DRV_MX25L_BlockErase Erase a block from the specified block start address DRV_MX25L_ChipErase Erase entire flash memory DRV_MX25L_Read Reads n bytes of data from the specified start address of flash memory DRV_MX25L_PageWrite Writes one page of data starting at the specified address DRV_MX25L_TransferStatusGet Gets the current status of the transfer request DRV_MX25L_GeometryGet Returns the geometry of the device Data types and constants Name Type Description DRV_MX25L_TRANSFER_STATUS Enum MX25L Driver Transfer Status DRV_MX25L_GEOMETRY Struct MX25L Device Geometry data ",
							" DRV_MX25L_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_MX25L_Initialize (  const SYS_MODULE_INDEX drvIndex   const SYS_MODULE_INIT * const init ) ; ",
							" Summary Initializes the MX25L Driver ",
							" Description This routine initializes the MX25L driver making it ready for client to use Resets the Flash Device Puts it on QUAD IO Mode Unlocks the flash ",
							" Precondition None ",
							" Parameters Param Description drvIndex Identifier for the instance to be initialized init Pointer to a data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example // This code snippet shows an example of initializing the MX25L Driver  // with MX25L QSPI flash device attached SYS_MODULE_OBJ objectHandle ;  const DRV_MX25L_PLIB_INTERFACE drvMX25LPlibAPI =  {   CommandWrite = QSPI_CommandWrite    RegisterRead = QSPI_RegisterRead    RegisterWrite = QSPI_RegisterWrite    MemoryRead = QSPI_MemoryRead    MemoryWrite = QSPI_MemoryWrite } ;  const DRV_MX25L_INIT drvMX25LInitData =  {   mx25lPlib =   drvMX25LPlibAPI   } ; objectHandle =  DRV_MX25L_Initialize ( ( SYS_MODULE_INDEX ) DRV_MX25L_INDEX   ( SYS_MODULE_INIT * )  drvMX25LInitData ) ;  if  ( SYS_MODULE_OBJ_INVALID == objectHandle )  {  // Handle error  } ",
							" Remarks This routine must be called before any other MX25L driver routine is called This routine should only be called once during system initialization This routine will block for hardware access ",
							" DRV_MX25L_Open Function ",
							" C DRV_HANDLE DRV_MX25L_Open (  const SYS_MODULE_INDEX drvIndex   const DRV_IO_INTENT ioIntent ) ; ",
							" Summary Opens the specified MX25L driver instance and returns a handle to it ",
							" Description This routine opens the specified MX25L driver instance and provides a handle This handle must be provided to all other client-level operations to identify the caller and the instance of the driver ",
							" Preconditions Function DRV_MX25L_Initialize must have been called before calling this function Driver should be in ready state to accept the request Can be checked by calling DRV_MX25L_Status() ",
							" Parameters Param Description drvIndex Identifier for the instance to be opened ioIntent Zero or more of the values from the enumeration DRV_IO_INTENT \"ORed\" together to indicate the intended use of the driver ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) If an error occurs DRV_HANDLE_INVALID is returned Errors can occur under the following circumstances: if the driver hardware instance being opened is not initialized ",
							" Example DRV_HANDLE handle ; handle =  DRV_MX25L_Open ( DRV_MX25L_INDEX ) ;  if  ( DRV_HANDLE_INVALID == handle )  {  // Unable to open the driver  } ",
							" Remarks The handle returned is valid until the DRV_MX25L_Close routine is called If the driver has already been opened it should not be opened again ",
							" DRV_MX25L_Close Function ",
							" C void  DRV_MX25L_Close (  const DRV_HANDLE handle ) ; ",
							" Summary Closes an opened-instance of the MX25L driver ",
							" Description This routine closes an opened-instance of the MX25L driver invalidating the handle ",
							" Precondition DRV_MX25L_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns None ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_MX25L_Open  DRV_MX25L_Close ( handle ) ; ",
							" Remarks After calling this routine the handle passed in \"handle\" must not be used with any of the remaining driver routines A new handle must be obtained by calling DRV_MX25L_Open before the caller may use the driver again Usually there is no need for the driver client to verify that the Close operation has completed ",
							" DRV_MX25L_Status Function ",
							" C SYS_STATUS DRV_MX25L_Status (  const SYS_MODULE_INDEX drvIndex ) ; ",
							" Summary Gets the current status of the MX25L driver module ",
							" Description This routine provides the current status of the MX25L driver module ",
							" Preconditions Function DRV_MX25L_Initialize should have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the instance used to initialize driver ",
							" Returns SYS_STATUS_READY - Indicates that the driver is ready and accept requests for new operations SYS_STATUS_UNINITIALIZED - Indicates the driver is not initialized SYS_STATUS_BUSY - Indicates the driver is in busy state ",
							" Example SYS_STATUS Status ; Status =  DRV_MX25L_Status ( DRV_MX25L_INDEX ) ;  if  ( status == SYS_STATUS_READY )  {  // MX25L driver is initialized and ready to accept requests  } ",
							" Remarks This routine will NEVER block wait for hardware ",
							" DRV_MX25L_ResetFlash Function ",
							" C bool DRV_MX25L_ResetFlash ( void ) ; ",
							" Summary Reset the flash device to standby mode ",
							" Description This function schedules a blocking operation for resetting the flash device to standby mode All the volatile bits and settings will be cleared then which makes the device return to the default status as power on ",
							" Precondition The DRV_MX25L_Open() routine must have been called for the specified MX25L driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns true - if the reset is successfully completed false - if Reset-Enable or Reset flash command itself fails ",
							" Example if ( DRV_MX25L_ResetFlash ( )  == false )  {  // Error handling here  }  ",
							" Remarks This routine will block wait for request to complete ",
							" DRV_MX25L_ReadJedecId Function ",
							" C bool DRV_MX25L_ReadJedecId (  const DRV_HANDLE handle   void  * jedec_id ) ; ",
							" Summary Reads JEDEC-ID of the flash device ",
							" Description This function schedules a blocking operation for reading the JEDEC-ID This information can be used to get the flash device geometry The request is sent in QUAD_MODE to flash device ",
							" Precondition The DRV_MX25L_Open() routine must have been called for the specified MX25L driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns true - if the read is successfully completed false - if read jedec-id command fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_MX25L_Open uint32_t jedec_id =  0 ;  if ( DRV_MX25L_ReadJedecId ( handle    jedec_id )  == false )  {  // Error handling here  }  ",
							" Remarks This routine will block wait for transfer to complete ",
							" DRV_MX25L_SectorErase Function ",
							" C bool DRV_MX25L_SectorErase (  const DRV_HANDLE handle  uint32_t address ) ; ",
							" Summary Erase the sector from the specified block start address ",
							" Description This function schedules a non-blocking sector erase operation of flash memory Each Sector is of 4 KByte The requesting client should call DRV_MX25L_TransferStatusGet() API to know the current status of the request The request is sent in QUAD_MODE to flash device ",
							" Preconditions The DRV_MX25L_Open() routine must have been called for the specified MX25L driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine address block start address from where a sector needs to be erased ",
							" Returns true if the erase request is successfully sent to the flash false if Write enable fails before sending sector erase command to flash if sector erase command itself fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_MX25L_Open uint32_t sectorStart =  0 ;  if ( DRV_MX25L_SectorErase ( handle  sectorStart )  == false )  {  // Error handling here  }  // Wait for erase to be completed  while ( DRV_MX25L_TransferStatusGet ( handle )  == DRV_MX25L_TRANSFER_BUSY ) ;  ",
							" Remarks This routine will block wait until erase request is submitted successfully Client should wait until erase is complete to send next transfer request ",
							" DRV_MX25L_BlockErase Function ",
							" C bool DRV_MX25L_BlockErase (  const DRV_HANDLE handle  uint32_t address ) ; ",
							" Summary Erase a block from the specified block start address ",
							" Description This function schedules a non-blocking block erase operation of flash memory The block size can be 8 KByte 32KByte or 64 KByte The requesting client should call DRV_MX25L_TransferStatusGet() API to know the current status of the request The request is sent in QUAD_MODE to flash device ",
							" Preconditions The DRV_MX25L_Open() routine must have been called for the specified MX25L driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine address block start address to be erased ",
							" Returns true if the erase request is successfully sent to the flash false if Write enable fails before sending sector erase command to flash if block erase command itself fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_MX25L_Open uint32_t blockStart =  0 ;  if ( DRV_MX25L_SectorErase ( handle  blockStart )  == false )  {  // Error handling here  }  // Wait for erase to be completed  while ( DRV_MX25L_TransferStatusGet ( handle )  == DRV_MX25L_TRANSFER_BUSY ) ;  ",
							" Remarks This routine will block wait until erase request is submitted successfully Client should wait until erase is complete to send next transfer request ",
							" DRV_MX25L_ChipErase Function ",
							" C bool DRV_MX25L_ChipErase (  const DRV_HANDLE handle ) ; ",
							" Summary Erase entire flash memory ",
							" Description This function schedules a non-blocking chip erase operation of flash memory The requesting client should call DRV_MX25L_TransferStatusGet() API to know the current status of the request The request is sent in QUAD_MODE to flash device ",
							" Preconditions The DRV_MX25L_Open() routine must have been called for the specified MX25L driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns true if the erase request is successfully sent to the flash false if Write enable fails before sending sector erase command to flash if chip erase command itself fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_MX25L_Open  if ( DRV_MX25L_ChipErase ( handle )  == false )  {  // Error handling here  }  // Wait for erase to be completed  while ( DRV_MX25L_TransferStatusGet ( handle )  == DRV_MX25L_TRANSFER_BUSY ) ;  ",
							" Remarks This routine will block wait until erase request is submitted successfully Client should wait until erase is complete to send next transfer request ",
							" DRV_MX25L_Read Function ",
							" C bool DRV_MX25L_Read (  const DRV_HANDLE handle   void  * rx_data  uint32_t rx_data_length  uint32_t address ) ; ",
							" Summary Reads n bytes of data from the specified start address of flash memory ",
							" Description This function schedules a blocking operation for reading requested number of data bytes from the flash memory The request is sent in QUAD_MODE to flash device ",
							" Precondition The DRV_MX25L_Open() routine must have been called for the specified MX25L driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine *rx_data Buffer pointer into which the data read from the MX25L Flash memory will be placed rx_data_length Total number of bytes to be read address Read memory start address from where the data should be read ",
							" Returns true - if number of bytes requested are read from flash memory false - if read command itself fails ",
							" Example # define BUFFER_SIZE 1024  # define MEM_ADDRESS 0x0 DRV_HANDLE handle ;  // Returned from DRV_MX25L_Open uint8_t CACHE_ALIGN readBuffer [ BUFFER_SIZE ] ;  if  ( DRV_MX25L_Read ( handle   ( void  * )  readBuffer  BUFFER_SIZE  MEM_ADDRESS )  == false )  {  // Error handling here  }  ",
							" Remarks This routine will block waiting until read request is completed successfully ",
							" DRV_MX25L_PageWrite Function ",
							" C bool DRV_MX25L_PageWrite (  const DRV_HANDLE handle   void  * tx_data  uint32_t tx_data_length  uint32_t address ) ; ",
							" Summary Writes one page of data starting at the specified address ",
							" Description This function schedules a non-blocking write operation for writing maximum one page of data into flash memory The requesting client should call DRV_MX25L_TransferStatusGet() API to know the current status of the request The request is sent in QUAD_MODE to flash device ",
							" Preconditions The DRV_MX25L_Open() routine must have been called for the specified MX25L driver instance The flash address location which has to be written must have been erased before using the MX25L_xxxErase() routine The flash address has to be a Page aligned address ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine *tx_data The source buffer containing data to be programmed into MX25L Flash tx_data_length Total number of bytes to be written should not be greater than page size address Write memory start address from where the data should be written ",
							" Returns true if the write request is successfully sent to the flash false if Write enable fails before sending sector erase command to flash if write command itself fails ",
							" Example # define PAGE_SIZE 256  # define BUFFER_SIZE 1024  # define MEM_ADDRESS 0x0 DRV_HANDLE handle ;  // Returned from DRV_MX25L_Open uint8_t CACHE_ALIGN writeBuffer [ BUFFER_SIZE ] ; bool status = false ;  if ( DRV_MX25L_SectorErase ( handle )  == false )  {  // Error handling here  }  // Wait for erase to be completed  while ( DRV_MX25L_TransferStatusGet ( handle )  == DRV_MX25L_TRANSFER_BUSY ) ;  for  ( uint32_t j =  0 ; j  BUFFER_SIZE ; j += PAGE_SIZE )  {  if  ( DRV_MX25L_PageWrite ( handle   ( void  * )  writeBuffer [ j ]   ( MEM_ADDRESS + j ) )  == false )  { status = false ;  break ;  }  // Wait for write to be completed  while ( DRV_MX25L_TransferStatusGet ( handle )  == DRV_MX25L_TRANSFER_BUSY ) ; status = true ;  }  if ( status == false )  {  // Error handling here  }  ",
							" Remarks This routine will block wait until write request is submitted successfully Client should wait until write is complete to send next transfer request ",
							" DRV_MX25L_TransferStatusGet Function ",
							" C DRV_MX25L_TRANSFER_STATUS DRV_MX25L_TransferStatusGet (  const DRV_HANDLE handle ) ; ",
							" Summary Gets the current status of the transfer request ",
							" Description This routine gets the current status of the transfer request The application must use this routine where the status of a scheduled request needs to be polled on ",
							" Preconditions The DRV_MX25L_Open() routine must have been called for the specified MX25L driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns DRV_MX25L_TRANSFER_ERROR_UNKNOWN - If the flash status register read request fails DRV_MX25L_TRANSFER_BUSY - If the current transfer request is still being processed DRV_MX25L_TRANSFER_COMPLETED - If the transfer request is completed ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_MX25L_Open  if  ( DRV_MX25L_TransferStatusGet ( handle )  == DRV_MX25L_TRANSFER_COMPLETED )  {  // Operation Done  } ",
							" Remarks This routine will block for hardware access ",
							" DRV_MX25L_GeometryGet Function ",
							" C bool DRV_MX25L_GeometryGet (  const DRV_HANDLE handle  MX25L_GEOMETRY * geometry ) ; ",
							" Summary Returns the geometry of the device ",
							" Description This API gives the following geometrical details of the MX25L Flash: Number of Read/Write/Erase Blocks and their size in each region of the device Flash block start address ",
							" Precondition The DRV_MX25L_Open() routine must have been called for the specified MX25L driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine *geometry_table pointer to flash device geometry table instance ",
							" Returns true - if able to get the geometry details of the flash false - if read device id fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_MX25L_Open DRV_MX25L_GEOMETRY mx25lFlashGeometry ; uint32_t readBlockSize  writeBlockSize  eraseBlockSize ; uint32_t nReadBlocks  nReadRegions  totalFlashSize ;  DRV_MX25L_GeometryGet ( handle    mx25lFlashGeometry ) ; readBlockSize = mx25lFlashGeometry  read_blockSize ; nReadBlocks = mx25lFlashGeometry  read_numBlocks ; nReadRegions = mx25lFlashGeometry  numReadRegions ; writeBlockSize = mx25lFlashGeometry  write_blockSize ; eraseBlockSize = mx25lFlashGeometry  erase_blockSize ; totalFlashSize = readBlockSize * nReadBlocks * nReadRegions ;  ",
							" Remarks This API is more useful when used to interface with block driver like memory driver ",
							" DRV_MX25L_TRANSFER_STATUS Enum ",
							" C typedef  enum  {  /* Transfer is being processed */ DRV_MX25L_TRANSFER_BUSY   /* Transfer is successfully completed*/ DRV_MX25L_TRANSFER_COMPLETED   /* Transfer had error*/ DRV_MX25L_TRANSFER_ERROR_UNKNOWN   } DRV_MX25L_TRANSFER_STATUS ;  ",
							" Summary MX25L Driver Transfer Status ",
							" Description This data type will be used to indicate the current transfer status for MX25L driver ",
							" Remarks None ",
							" DRV_MX25L_GEOMETRY Struct ",
							" C typedef  struct  { uint32_t read_blockSize ; uint32_t read_numBlocks ; uint32_t numReadRegions ; uint32_t write_blockSize ; uint32_t write_numBlocks ; uint32_t numWriteRegions ; uint32_t erase_blockSize ; uint32_t erase_numBlocks ; uint32_t numEraseRegions ; uint32_t blockStartAddress ;  } DRV_MX25L_GEOMETRY ;  ",
							" Summary MX25L Device Geometry data ",
							" Description This data type will be used to get the geometry details of the MX25L flash device ",
							" Remarks None ",
							" SST26 Driver This driver provides a non-blocking interface to read write and erase SST26 Flash memory The driver uses the below peripheral library to interface with the SST26 Flash QSPI Peripheral Library Supports both SPI mode and Quad IO Mode SPI Peripheral Library Supports only SPI mode SQI peripheral Library Supports Quad Lane Mode and Single Lane Mode Key Features: Supports Multiple variants of the SST26 Flash devices Supports a single instance of the SST26 Flash and a single client to the driver Supports Sector/Bulk/Chip Erase Operations Supports writes to random memory address within page boundaries The library interface is compliant to the block media interface expected by the Memory Driver This allows running a file system on the AT25DF Flash using the Memory Driver and the File System Service The library can be used in both Bare-Metal and RTOS environments ",
							" How the Library Works The sst26 driver library is a single-client single-instance based driver interface Abstraction Model The SST26 driver interface provides read write and Erase functions that abstract out the internal workings of the SST26 driver and the underlying QSPI/SQI/SPI protocol The client can be: Application - Directly access the SST26 Flash using the APIs provided by the SST26 Driver library Memory Driver - Application can run a file system on the SST26 Flash by connecting it to the Memory Driver which can further be connected to the File System Service drv_sst26_abstraction_model Working flow The SST26 Driver performs initialization and puts the driver to ready state This status of the driver can be checked using DRV_SST26_Status() The SST26 driver library performs set of flash operations during DRV_SST26_Open() If any of the below flash operations fails an invalid Handle will be returned DRV_SST26_Open() can be repeatedly called until it returns a valid handle Resets the Flash Configures the flash device to QUAD IO Mode if underlying peripheral library is running in QSPI/SQI mode Unlocks the flash if it has been opened in write mode When the client requests for device geometry it queries for the JEDEC-Id and populates the geometry table DRV_SST26_GEOMETRY appropriately The driver does not support queuing of more than one requests The application must check and ensure that any previous request is completed before submitting a new one This can be done by polling the status of data transfer using DRV_SST26_TransferStatusGet() ",
							" Using The Library The SST26 driver provides non-blocking API's to read write and erase SST26 Flash memory The SST26 driver can be used in following ways: To perform page write to SST26 Flash Here the memory start address must be aligned to the page boundary To perform Sector/Bulk/Chip Erase operations To unlock flash before performing Erase/Write operations Done as part of DRV_SST26_Open() To read flash JEDEC-ID To interface with the Memory driver to perform block operations on the SST26 Flash Note: The client should poll for the status of the data transfer when in QSPI mode Example application to Erase Write and Read SST26 Flash Memory /* Erase-Write-Read 2 Sector of Data (4096 *2)*/  # define BUFFER_SIZE 8192  # define MEM_ADDRESS 0x0 APP_DATA CACHE_ALIGN appData ;  static uint32_t erase_index =  0 ;  static uint32_t write_index =  0 ;  void APP_Initialize (  void  )  { uint32_t i =  0 ;  /* Place the App state machine in its initial state */ appData  state = APP_STATE_INIT ;  for  ( i =  0 ; i  BUFFER_SIZE ; i ++ )  { appData  writeBuffer [ i ]  = i ;  }  }  void APP_Tasks (  void  )  { DRV_SST26_TRANSFER_STATUS transferStatus = DRV_SST26_TRANSFER_ERROR_UNKNOWN ;  /* Check the application's current state */  switch  ( appData  state )  {  /* Application's initial state */  case APP_STATE_INIT :  {  if  ( DRV_SST26_Status ( DRV_SST26_INDEX )  == SYS_STATUS_READY )  { appData  state = APP_STATE_OPEN_DRIVER ;  }  break ;  }  case APP_STATE_OPEN_DRIVER :  { appData  handle =  DRV_SST26_Open ( DRV_SST26_INDEX  DRV_IO_INTENT_READWRITE ) ;  if  ( appData  handle = DRV_HANDLE_INVALID )  { appData  state = APP_STATE_GEOMETRY_GET ;  }  break ;  }  case APP_STATE_GEOMETRY_GET :  {  if  ( DRV_SST26_GeometryGet ( appData  handle    appData  geometry )  = true )  { appData  state = APP_STATE_ERROR ;  break ;  } erase_index =  0 ; write_index =  0 ; appData  state = APP_STATE_ERASE_FLASH ;  break ;  }  case APP_STATE_ERASE_FLASH :  {  if  ( DRV_SST26_SectorErase ( appData  handle   ( MEM_ADDRESS + erase_index ) )  = true )  { appData  state = APP_STATE_ERROR ;  } appData  state = APP_STATE_ERASE_WAIT ;  break ;  }  case APP_STATE_ERASE_WAIT :  { transferStatus =  DRV_SST26_TransferStatusGet ( appData  handle ) ;  if ( transferStatus == DRV_SST26_TRANSFER_COMPLETED )  { erase_index += appData  geometry  erase_blockSize ;  if  ( erase_index  BUFFER_SIZE )  { appData  state = APP_STATE_ERASE_FLASH ;  }  else  { appData  state = APP_STATE_WRITE_MEMORY ;  }  }  else  if  ( transferStatus == DRV_SST26_TRANSFER_ERROR_UNKNOWN )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_WRITE_MEMORY :  {  if  ( DRV_SST26_PageWrite ( appData  handle   ( uint32_t * )  appData  writeBuffer [ write_index ]   ( MEM_ADDRESS + write_index ) )  = true )  { appData  state = APP_STATE_ERROR ;  break ;  } appData  state = APP_STATE_WRITE_WAIT ;  break ;  }  case APP_STATE_WRITE_WAIT :  { transferStatus =  DRV_SST26_TransferStatusGet ( appData  handle ) ;  if ( transferStatus == DRV_SST26_TRANSFER_COMPLETED )  { write_index += appData  geometry  write_blockSize ;  if  ( write_index  BUFFER_SIZE )  { appData  state = APP_STATE_WRITE_MEMORY ;  }  else  { appData  state = APP_STATE_READ_MEMORY ;  }  }  else  if  ( transferStatus == DRV_SST26_TRANSFER_ERROR_UNKNOWN )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_READ_MEMORY :  {  if  ( DRV_SST26_Read ( appData  handle   ( uint32_t * )  appData  readBuffer  BUFFER_SIZE  MEM_ADDRESS )  = true )  { appData  state = APP_STATE_ERROR ;  }  else  { appData  state = APP_STATE_READ_WAIT ;  }  break ;  }  case APP_STATE_READ_WAIT :  { transferStatus =  DRV_SST26_TransferStatusGet ( appData  handle ) ;  if ( transferStatus == DRV_SST26_TRANSFER_COMPLETED )  { appData  state = APP_STATE_VERIFY_DATA ;  }  else  if  ( transferStatus == DRV_SST26_TRANSFER_ERROR_UNKNOWN )  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_VERIFY_DATA :  {  if  (  memcmp ( appData  writeBuffer  appData  readBuffer  BUFFER_SIZE ) )  { appData  state = APP_STATE_SUCCESS ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  }  case APP_STATE_SUCCESS :  {  DRV_SST26_Close ( appData  handle ) ;  break ;  }  case APP_STATE_ERROR :  default :  {  DRV_SST26_Close ( appData  handle ) ;  break ;  }  }  }  ",
							" Configuring The Library The SST26 driver library should be configured through the MHC The following figures show the MHC configuration window for the SST26 driver and brief description SST26 Driver with SQI peripheral connected drv_sst26_mhc_config_with_sqi SST26 Driver with QSPI peripheral in SPI mode connected drv_sst26_mhc_config_with_qspi_spi SST26 Driver with QSPI peripheral in SQI mode connected drv_sst26_mhc_config_with_qspi_sqi SST26 Driver with connection to Memory Driver drv_sst26_mhc_config_with_drv_mem Configuration Options PLIB Used: Specifies the Peripheral library connected Number Of Clients: Indicates maximum number of clients Always set to one as it supports only a single client Number Of Buffer Descriptors This option appears only when SQI peripheral is connected to the driver Indicates Maximum number of SQI DMA Buffer Descriptors to be used to create chain of requests for Read Increase in number of descriptors will allow to read (256 * Number of Descriptors) Bytes from flash at one shot SQI Lane Mode: This option appears only when SQI peripheral is connected to the driver Specifies number of lanes to be used for sending the data on SQI SQI Chip Select: This option appears only when SQI peripheral is connected to the driver Specifies the Chip select to be used Should align with Chip select configured in SQI peripheral library settings Chip Select Pin: This option appears only when SPI peripheral or QSPI peripheral in SPI mode is connected to the driver GPIO Pin to be used as chip select when connected in SPI mode SST26 Start Address: Specifies the flash memory start address to be used for Transfer operations The start address will be populated in the device geometry table DRV_SST26_GEOMETRY SST26 Erase Buffer Size: This option appears only when the SST26 driver is connected to the Memory driver for block operations Specifies the size for erase buffer used by Memory driver The size of the buffer should be equal to erase sector size as the memory driver will call DRV_SST26_SectorErase ",
							" Library Interface SST26 driver library provides the following interfaces: Functions Name Description DRV_SST26_Initialize Initializes the SST26 Driver DRV_SST26_Open Opens the specified SST26 driver instance and returns a handle to it DRV_SST26_Close Closes an opened-instance of the SST26 driver DRV_SST26_Status Gets the current status of the SST26 driver module DRV_SST26_UnlockFlash Unlocks the flash device for Erase and Program operations DRV_SST26_ReadJedecId Reads JEDEC-ID of the flash device DRV_SST26_SectorErase Erase the sector from the specified block start address DRV_SST26_BulkErase Erase a block from the specified block start address DRV_SST26_ChipErase Erase entire flash memory DRV_SST26_Read Reads n bytes of data from the specified start address of flash memory DRV_SST26_PageWrite Writes one page of data starting at the specified address DRV_SST26_TransferStatusGet Gets the current status of the transfer request DRV_SST26_GeometryGet Returns the geometry of the device DRV_SST26_EventHandlerSet Allows a client to identify a transfer event handling function for the driver to call back when the requested transfer has finished Data types and constants Name Type Description DRV_SST26_TRANSFER_STATUS Enum SST26 Driver Transfer Status DRV_SST26_GEOMETRY Struct SST26 Device Geometry data DRV_SST26_EVENT_HANDLER Typedef Pointer to a SST26 Driver Event handler function ",
							" DRV_SST26_Initialize Function ",
							" C SYS_MODULE_OBJ DRV_SST26_Initialize (  const SYS_MODULE_INDEX drvIndex   const SYS_MODULE_INIT * const init ) ; ",
							" Summary Initializes the SST26 Driver ",
							" Description This routine initializes the SST26 driver making it ready for client to use ",
							" Precondition None ",
							" Parameters Param Description drvIndex Identifier for the instance to be initialized init Pointer to a data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid driver instance object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example // This code snippet shows an example of initializing the SST26 Driver  // with SST26 QSPI flash device attached SYS_MODULE_OBJ objectHandle ;  const DRV_SST26_PLIB_INTERFACE drvSST26PlibAPI =  {   CommandWrite = QSPI_CommandWrite    RegisterRead = QSPI_RegisterRead    RegisterWrite = QSPI_RegisterWrite    MemoryRead = QSPI_MemoryRead    MemoryWrite = QSPI_MemoryWrite } ;  const DRV_SST26_INIT drvSST26InitData =  {   sst26Plib =   drvSST26PlibAPI   } ; objectHandle =  DRV_SST26_Initialize ( ( SYS_MODULE_INDEX ) DRV_SST26_INDEX   ( SYS_MODULE_INIT * )  drvSST26InitData ) ;  if  ( SYS_MODULE_OBJ_INVALID == objectHandle )  {  // Handle error  } ",
							" Remarks This routine must be called before any other SST26 driver routine is called This routine should only be called once during system initialization ",
							" DRV_SST26_Open Function ",
							" C DRV_HANDLE DRV_SST26_Open (  const SYS_MODULE_INDEX drvIndex   const DRV_IO_INTENT ioIntent ) ; ",
							" Summary Opens the specified SST26 driver instance and returns a handle to it ",
							" Description This routine opens the specified SST26 driver instance and provides a handle It performs the following blocking operations: Resets the Flash Device Puts it on QUAD IO Mode Unlocks the flash if DRV_SST26_Open was called with write intent This handle must be provided to all other client-level operations to identify the caller and the instance of the driver ",
							" Preconditions Function DRV_SST26_Initialize must have been called before calling this function Driver should be in ready state to accept the request Can be checked by calling DRV_SST26_Status() ",
							" Parameters Param Description drvIndex Identifier for the instance to be opened ioIntent Zero or more of the values from the enumeration DRV_IO_INTENT \"ORed\" together to indicate the intended use of the driver ",
							" Returns If successful the routine returns a valid open-instance handle (a number identifying both the caller and the module instance) If an error occurs DRV_HANDLE_INVALID is returned Errors can occur under the following circumstances: if the driver hardware instance being opened is not initialized ",
							" Example DRV_HANDLE handle ; handle =  DRV_SST26_Open ( DRV_SST26_INDEX ) ;  if  ( DRV_HANDLE_INVALID == handle )  {  // Unable to open the driver  } ",
							" Remarks The handle returned is valid until the DRV_SST26_Close routine is called If the driver has already been opened it should not be opened again ",
							" DRV_SST26_Close Function ",
							" C void  DRV_SST26_Close (  const DRV_HANDLE handle ) ; ",
							" Summary Closes an opened-instance of the SST26 driver ",
							" Description This routine closes an opened-instance of the SST26 driver invalidating the handle ",
							" Precondition DRV_SST26_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns None ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_SST26_Open  DRV_SST26_Close ( handle ) ; ",
							" Remarks After calling this routine the handle passed in \"handle\" must not be used with any of the remaining driver routines A new handle must be obtained by calling DRV_SST26_Open before the caller may use the driver again Usually there is no need for the driver client to verify that the Close operation has completed ",
							" DRV_SST26_Status Function ",
							" C SYS_STATUS DRV_SST26_Status (  const SYS_MODULE_INDEX drvIndex ) ; ",
							" Summary Gets the current status of the SST26 driver module ",
							" Description This routine provides the current status of the SST26 driver module ",
							" Preconditions Function DRV_SST26_Initialize should have been called before calling this function ",
							" Parameters Param Description drvIndex Identifier for the instance used to initialize driver ",
							" Returns SYS_STATUS_READY - Indicates that the driver is ready and accept requests for new operations SYS_STATUS_UNINITIALIZED - Indicates the driver is not initialized SYS_STATUS_BUSY - Indicates the driver is in busy state ",
							" Example SYS_STATUS Status ; Status =  DRV_SST26_Status ( DRV_SST26_INDEX ) ;  if  ( status == SYS_STATUS_READY )  {  // SST26 driver is initialized and ready to accept requests  } ",
							" Remarks None ",
							" DRV_SST26_UnlockFlash Function ",
							" C bool DRV_SST26_UnlockFlash (  const DRV_HANDLE handle ) ; ",
							" Summary Unlocks the flash device for Erase and Program operations ",
							" Description This function schedules a blocking operation for unlocking the flash blocks globally This allows to perform erase and program operations on the flash ",
							" Precondition The DRV_SST26_Open() routine must have been called for the specified SST26 driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns true - if the unlock is successfully completed false - if Write enable fails before sending unlock command to flash and - if Unlock flash command itself fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_SST26_Open  if ( DRV_SST26_UnlockFlash ( handle )  == false )  {  // Error handling here  }  ",
							" Remarks None ",
							" DRV_SST26_ReadJedecId Function ",
							" C bool DRV_SST26_ReadJedecId (  const DRV_HANDLE handle   void  * jedec_id ) ; ",
							" Summary Reads JEDEC-ID of the flash device ",
							" Description This function schedules a blocking operation for reading the JEDEC-ID This information can be used to get the flash device geometry ",
							" Precondition The DRV_SST26_Open() routine must have been called for the specified SST26 driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns true - if the read is successfully completed false - if read jedec-id command fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_SST26_Open uint32_t jedec_id =  0 ;  if ( DRV_SST26_ReadJedecId ( handle    jedec_id )  == false )  {  // Error handling here  }  ",
							" Remarks None ",
							" DRV_SST26_SectorErase Function ",
							" C bool DRV_SST26_SectorErase (  const DRV_HANDLE handle  uint32_t address ) ; ",
							" Summary Erase the sector from the specified block start address ",
							" Description This function schedules a non-blocking sector erase operation of flash memory Each Sector is of 4 KByte The requesting client should call DRV_SST26_TransferStatusGet() API to know the current status of the request ",
							" Preconditions The DRV_SST26_Open() routine must have been called for the specified SST26 driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine address block start address from where a sector needs to be erased ",
							" Returns true if the erase request is successfully sent to the flash false if Write enable fails before sending sector erase command to flash if sector erase command itself fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_SST26_Open uint32_t sectorStart =  0 ;  if ( DRV_SST26_SectorErase ( handle  sectorStart )  == false )  {  // Error handling here  }  // Wait for erase to be completed  while ( DRV_SST26_TRANSFER_BUSY ==  DRV_SST26_TransferStatusGet ( handle ) ) ;  ",
							" Remarks None ",
							" DRV_SST26_BulkErase Function ",
							" C bool DRV_SST26_BulkErase (  const DRV_HANDLE handle  uint32_t address ) ; ",
							" Summary Erase a block from the specified block start address ",
							" Description This function schedules a non-blocking block erase operation of flash memory The block size can be 8 KByte 32KByte or 64 KByte The requesting client should call DRV_SST26_TransferStatusGet() API to know the current status of the request ",
							" Preconditions The DRV_SST26_Open() routine must have been called for the specified SST26 driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine address block start address to be erased ",
							" Returns true if the erase request is successfully sent to the flash false if Write enable fails before sending sector erase command to flash if block erase command itself fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_SST26_Open uint32_t blockStart =  0 ;  if ( DRV_SST26_SectorErase ( handle  blockStart )  == false )  {  // Error handling here  }  // Wait for erase to be completed  while ( DRV_SST26_TransferStatusGet ( handle )  == DRV_SST26_TRANSFER_BUSY ) ;  ",
							" Remarks None ",
							" DRV_SST26_ChipErase Function ",
							" C bool DRV_SST26_ChipErase (  const DRV_HANDLE handle ) ; ",
							" Summary Erase entire flash memory ",
							" Description This function schedules a non-blocking chip erase operation of flash memory The requesting client should call DRV_SST26_TransferStatusGet() API to know the current status of the request ",
							" Preconditions The DRV_SST26_Open() routine must have been called for the specified SST26 driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns true if the erase request is successfully sent to the flash false if Write enable fails before sending sector erase command to flash if chip erase command itself fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_SST26_Open  if ( DRV_SST26_ChipErase ( handle )  == flase )  {  // Error handling here  }  // Wait for erase to be completed  while ( DRV_SST26_TransferStatusGet ( handle )  == DRV_SST26_TRANSFER_BUSY ) ;  ",
							" Remarks None ",
							" DRV_SST26_Read Function ",
							" C bool DRV_SST26_Read (  const DRV_HANDLE handle   void  * rx_data  uint32_t rx_data_length  uint32_t address ) ; ",
							" Summary Reads n bytes of data from the specified start address of flash memory ",
							" Description This function schedules a blocking operation for reading requested number of data bytes from the flash memory ",
							" Precondition The DRV_SST26_Open() routine must have been called for the specified SST26 driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine *rx_data Buffer pointer into which the data read from the SST26 Flash memory will be placed rx_data_length Total number of bytes to be read address Read memory start address from where the data should be read ",
							" Returns true - if number of bytes requested are read from flash memory false - if read command itself fails ",
							" Example # define BUFFER_SIZE 1024  # define MEM_ADDRESS 0x0 DRV_HANDLE handle ;  // Returned from DRV_SST26_Open uint8_t CACHE_ALIGN readBuffer [ BUFFER_SIZE ] ;  if  ( DRV_SST26_Read ( handle   ( void  * )  readBuffer  BUFFER_SIZE  MEM_ADDRESS )  == false )  {  // Error handling here  }  // Wait for read to be completed  while ( DRV_SST26_TransferStatusGet ( handle )  == DRV_SST26_TRANSFER_BUSY ) ;  ",
							" Remarks None ",
							" DRV_SST26_PageWrite Function ",
							" C bool DRV_SST26_PageWrite (  const DRV_HANDLE handle   void  * tx_data  uint32_t tx_data_length  uint32_t address ) ; ",
							" Summary Writes one page of data starting at the specified address ",
							" Description This function schedules a non-blocking write operation for writing maximum one page of data into flash memory The requesting client should call DRV_SST26_TransferStatusGet() API to know the current status of the request ",
							" Preconditions The DRV_SST26_Open() routine must have been called for the specified SST26 driver instance The flash address location which has to be written must have been erased before using the SST26_xxxErase() routine The flash address has to be a Page aligned address ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine *tx_data The source buffer containing data to be programmed into SST26 Flash tx_data_length Total number of bytes to be written should not be greater than page size address Write memory start address from where the data should be written ",
							" Returns true if the write request is successfully sent to the flash false if Write enable fails before sending sector erase command to flash if write command itself fails ",
							" Example # define PAGE_SIZE 256  # define BUFFER_SIZE 1024  # define MEM_ADDRESS 0x0 DRV_HANDLE handle ;  // Returned from DRV_SST26_Open uint8_t CACHE_ALIGN writeBuffer [ BUFFER_SIZE ] ; bool status = false ;  if ( false ==  DRV_SST26_SectorErase ( handle ) )  {  // Error handling here  }  // Wait for erase to be completed  while ( DRV_SST26_TransferStatusGet ( handle )  == DRV_SST26_TRANSFER_BUSY ) ;  for  ( uint32_t j =  0 ; j  BUFFER_SIZE ; j += PAGE_SIZE )  {  if  ( DRV_SST26_PageWrite ( handle   ( void  * )  writeBuffer [ j ]   ( MEM_ADDRESS + j ) )  == false )  { status = false ;  break ;  }  // Wait for write to be completed  while ( DRV_SST26_TransferStatusGet ( handle )  == DRV_SST26_TRANSFER_BUSY ) ; status = true ;  }  if ( status == false )  {  // Error handling here  }  ",
							" Remarks None ",
							" DRV_SST26_TransferStatusGet Function ",
							" C DRV_SST26_TRANSFER_STATUS DRV_SST26_TransferStatusGet (  const DRV_HANDLE handle ) ; ",
							" Summary Gets the current status of the transfer request ",
							" Description This routine gets the current status of the transfer request The application must use this routine where the status of a scheduled request needs to be polled on ",
							" Preconditions The DRV_SST26_Open() routine must have been called for the specified SST26 driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine ",
							" Returns DRV_SST26_TRANSFER_ERROR_UNKNOWN - If the flash status register read request fails DRV_SST26_TRANSFER_BUSY - If the current transfer request is still being processed DRV_SST26_TRANSFER_COMPLETED - If the transfer request is completed ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_SST26_Open  if  ( DRV_SST26_TransferStatusGet ( handle )  == DRV_SST26_TRANSFER_COMPLETED )  {  // Operation Done  } ",
							" Remarks None ",
							" DRV_SST26_GeometryGet Function ",
							" C bool DRV_SST26_GeometryGet (  const DRV_HANDLE handle  SST26_GEOMETRY * geometry ) ; ",
							" Summary Returns the geometry of the device ",
							" Description This API gives the following geometrical details of the SST26 Flash: Number of Read/Write/Erase Blocks and their size in each region of the device Flash block start address ",
							" Precondition The DRV_SST26_Open() routine must have been called for the specified SST26 driver instance ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine *geometry_table pointer to flash device geometry table instance ",
							" Returns true - if able to get the geometry details of the flash false - if read device id fails ",
							" Example DRV_HANDLE handle ;  // Returned from DRV_SST26_Open DRV_SST26_GEOMETRY sst26FlashGeometry ; uint32_t readBlockSize  writeBlockSize  eraseBlockSize ; uint32_t nReadBlocks  nReadRegions  totalFlashSize ;  DRV_SST26_GeometryGet ( handle    sst26FlashGeometry ) ; readBlockSize = sst26FlashGeometry  read_blockSize ; nReadBlocks = sst26FlashGeometry  read_numBlocks ; nReadRegions = sst26FlashGeometry  numReadRegions ; writeBlockSize = sst26FlashGeometry  write_blockSize ; eraseBlockSize = sst26FlashGeometry  erase_blockSize ; totalFlashSize = readBlockSize * nReadBlocks * nReadRegions ;  ",
							" Remarks This API is more useful when used to interface with Memory driver ",
							" DRV_SST26_EventHandlerSet Function ",
							" C void  DRV_SST26_EventHandlerSet (  const DRV_HANDLE handle   const DRV_SST26_EVENT_HANDLER eventHandler   const uintptr_t context ) ",
							" Summary Allows a client to identify a transfer event handling function for the driver to call back when the requested transfer has finished ",
							" Description This function allows a client to register a transfer event handling function with the driver to call back when the requested transfer has finished The event handler should be set before the client submits any transfer requests that could generate events The event handler once set persists until the client closes the driver or sets another event handler (which could be a \"NULL\" pointer to indicate no callback) This function is only supported when sst26 driver is using QSPI PLIB in SPI mode SPI PLIB ",
							" Precondition DRV_SST26_Open must have been called to obtain a valid opened device handle ",
							" Parameters Param Description handle A valid open-instance handle returned from the driver's open routine eventHandler Pointer to the event handler function context The value of parameter will be passed back to the client unchanged when the eventHandler function is called It can be used to identify any client specific data object that identifies the instance of the client module (for example it may be a pointer to the client module's state structure) ",
							" Returns None ",
							" Example # define BUFFER_SIZE 256  # define MEM_ADDRESS 0x00  // myAppObj is an application specific state data object MY_APP_OBJ myAppObj ; uint8_t CACHE_ALIGN myBuffer [ BUFFER_SIZE ] ;  // The registered event handler is called when the request is complete  void  APP_SST26TransferEventHandler ( DRV_SST26_TRANSFER_STATUS event  uintptr_t context )  {  // The context handle was set to an application specific  // object It is now retrievable easily in the event handler MY_APP_OBJ * pMyAppObj =  ( MY_APP_OBJ * ) context ;  switch ( event )  {  case DRV_SST26_TRANSFER_COMPLETED :  {  // This means the data was transferred  break ;  }  case DRV_SST26_TRANSFER_ERROR :  {  // Error handling here  break ;  }  default :  {  break ;  }  }  }  // myHandle is the handle returned from DRV_SST26_Open API  // Client registers an event handler with driver This is done once  DRV_SST26_EventHandlerSet ( myHandle  APP_SST26TransferEventHandler   ( uintptr_t )  myAppObj ) ;  if  ( DRV_SST26_Read ( myHandle  myBuffer  BUFFER_SIZE  MEM_ADDRESS )  == false )  {  // Error handling here  }  ",
							" Remarks If the client does not want to be notified when the queued buffer transfer has completed it does not need to register a callback ",
							" DRV_SST26_TRANSFER_STATUS Enum ",
							" C typedef  enum  {  /* Transfer is being processed */ DRV_SST26_TRANSFER_BUSY   /* Transfer is successfully completed*/ DRV_SST26_TRANSFER_COMPLETED   /* Transfer had error*/ DRV_SST26_TRANSFER_ERROR_UNKNOWN   } DRV_SST26_TRANSFER_STATUS ;  ",
							" Summary SST26 Driver Transfer Status ",
							" Description This data type will be used to indicate the current transfer status for SST26 driver ",
							" Remarks None ",
							" DRV_SST26_GEOMETRY Struct ",
							" C typedef  struct  { uint32_t read_blockSize ; uint32_t read_numBlocks ; uint32_t numReadRegions ; uint32_t write_blockSize ; uint32_t write_numBlocks ; uint32_t numWriteRegions ; uint32_t erase_blockSize ; uint32_t erase_numBlocks ; uint32_t numEraseRegions ; uint32_t blockStartAddress ;  } DRV_SST26_GEOMETRY ;  ",
							" Summary SST26 Device Geometry data ",
							" Description This data type will be used to get the geometry details of the SST26 flash device ",
							" Remarks None ",
							" DRV_SST26_EVENT_HANDLER Typedef ",
							" C typedef  void  ( * DRV_SST26_EVENT_HANDLER )  ( DRV_SST26_TRANSFER_STATUS event  uintptr_t context ) ;  ",
							" Summary Pointer to a SST26 Driver Event handler function ",
							" Description This data type defines the required function signature for the SST26 driver event handling callback function A client must register a pointer using the event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive transfer related event calls back from the driver This data type is only supported when sst26 driver is using QSPI PLIB in SPI mode SPI PLIB ",
							" Parameters Param Description event Identifies the type of event context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Example void  APP_MyTransferEventHandler ( DRV_SST26_TRANSFER_STATUS event  uintptr_t context )  { MY_APP_DATA_STRUCT * pAppData =  ( MY_APP_DATA_STRUCT * ) context ;  switch ( event )  {  case DRV_SST26_TRANSFER_COMPLETED :  {  // Handle the transfer complete event  break ;  }  case DRV_SST26_TRANSFER_ERROR_UNKNOWN :  default :  {  // Handle error  break ;  }  }  } ",
							" Remarks If the event is DRV_SST26_TRANSFER_COMPLETED it means that the data was transferred successfully If the event is DRV_SST26_TRANSFER_ERROR_UNKNOWN it means that the data was not transferred successfully The context parameter contains the handle to the client context provided at the time the event handling function was registered using the DRV_SST26_EventHandlerSet function This context handle value is passed back to the client as the \"context\" parameter It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request The event handler function executes in the driver's interrupt context It is recommended of the application to not perform process intensive or blocking operations with in this function ",
							" System Service Libraries MPLAB Harmony provides system service libraries to support common functionality and manage resources that are shared by multiple drivers libraries and other modules A system service encapsulates code that manages a shared resource or implements a common capability in a single location so that it does not need to be replicated by individual drivers and libraries This feature eliminates duplicated code and creates consistency across all modules and also helps to eliminate potential conflicts and complex configuration issues and runtime interactions resulting in a smaller and simpler overall solution System services may directly manage one or more peripherals or core processor capabilities by utilizing peripheral libraries special function registers special CPU instructions or coprocessor registers Some system services may utilize drivers other system services or even entire middleware stacks to share or emulate a common resource System services may be implemented statically (possibly generated by the MPLAB Harmony Configurator (MHC)) or dynamically to support multiple channels and instances like a driver However system services will not normally provide common Open and Close functions like a driver In general the distinguishing feature of a system service is that it implements a common capability that would otherwise \"cut horizontally\" across multiple modules in a system causing interoperability and compatibility conflicts if the capability were implemented by other libraries System service functions use the following naming convention: SYS_ module-abbreviation _ operation Where SYS_ indicates that this is a system service function module-abbreviation is the abbreviated name of the system service module to which this function belongs is an optional short (or shortened) name that identifies the feature of the associated system service module to which this function refers The feature short name will appear in the name of all functions that interact with or provide access to that particular feature operation is a verb that identifies the action taken by the function For example SYS_TIME_TimerStart where: module-abbreviation = TIME which indicates that this is a Time System Service function feature-short-name = Timer which indicates that this function controls the Time feature of the Timer System Service operation = Start which indicates that this function starts the software timer created with Time System Service Below are the System Service libraries that are available in MPLAB Harmony 3 Core ",
							" Common System Services Library Common system services library provides the following data types and constants that are shared and common to all system services Media System Service Data types and constants Name Type Description SYS_MEDIA_BLOCK_COMMAND_HANDLE Typedef Handle identifying block commands of the media SYS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID Macro Defines the invalid media block command handle SYS_MEDIA_EVENT_HANDLER Typedef Pointer to the Media Event Handler function SYS_MEDIA_BLOCK_EVENT Enum Identifies the possible events that can result from a request SYS_MEDIA_PROPERTY Enum Contains information of property of a media SYS_MEDIA_STATUS Enum The state of media SYS_MEDIA_COMMAND_STATUS Enum The enumeration for status of buffer SYS_MEDIA_GEOMETRY_TABLE_ENTRY Macros Defines the Sys Media Geometry table entry Macros SYS_MEDIA_REGION_GEOMETRY Struct Contains information of a sys media region SYS_MEDIA_GEOMETRY Struct Contains all the geometrical information of a media device Module System Service Data types and constants Name Type Description SYS_MODULE_INDEX Typedef Identifies which instance of a system module should be initialized or opened SYS_MODULE_OBJ Typedef Handle to an instance of a system module SYS_MODULE_OBJ_INVALID Macro Object handle value returned if unable to initialize the requested instance of a system module SYS_MODULE_OBJ_STATIC Macro Object handle value returned by static modules SYS_STATUS Enum Identifies the current status/state of a system module (including device drivers) SYS_MODULE_INIT Union Initializes a module (including device drivers) as requested by the system SYS_MODULE_INITIALIZE_ROUTINE Typedef Pointer to a routine that initializes a system module (driver library or system-maintained application) SYS_MODULE_REINITIALIZE_ROUTINE Typedef Pointer to a routine that reinitializes a system module (driver library or system-maintained application) SYS_MODULE_DEINITIALIZE_ROUTINE Typedef Pointer to a routine that deinitializes a system module (driver library or system-maintained application) SYS_MODULE_STATUS_ROUTINE Typedef Pointer to a routine that gets the current status of a system module (driver library or system-maintained application) SYS_MODULE_TASKS_ROUTINE Typedef Pointer to a routine that performs the tasks necessary to maintain a state machine in a module system module (driver library or system-maintained application) ",
							" SYS_MEDIA_BLOCK_COMMAND_HANDLE Typedef ",
							" C typedef uintptr_t SYS_MEDIA_BLOCK_COMMAND_HANDLE ; ",
							" Summary Handle identifying block commands of the media ",
							" Description A block command handle is returned by a call to the Read Write or Erase functions This handle allows the application to track the completion of the operation The handle is returned back to the client by the \"event handler callback\" function registered with the driver The handle assigned to a client request expires when the client has been notified of the completion of the operation (after event handler function that notifies the client returns) or after the buffer has been retired by the driver if no event handler callback was set ",
							" Remarks None ",
							" SYS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID Macro ",
							" C # define SYS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID  ",
							" Summary Defines the invalid media block command handle ",
							" Description This value defines invalid handle for the media block command It is returned by read/write/erase routines when the request could not be taken ",
							" Remarks None ",
							" SYS_MEDIA_EVENT_HANDLER Typedef ",
							" C typedef  void  ( * SYS_MEDIA_EVENT_HANDLER )  ( SYS_MEDIA_BLOCK_EVENT event  SYS_MEDIA_BLOCK_COMMAND_HANDLE commandHandle  uintptr_t context ) ;  ",
							" Summary Pointer to the Media Event Handler function ",
							" Description This data type defines the required function signature for the media event handling callback function A client must register a pointer to an event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive event calls back from the driver ",
							" Parameters Param Description event Identifies the type of event commandHandle Handle returned from the media operation requests context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Remarks None ",
							" SYS_MEDIA_BLOCK_EVENT Enum ",
							" C typedef  enum  {  /* Block operation has been completed successfully */ SYS_MEDIA_EVENT_BLOCK_COMMAND_COMPLETE   /* There was an error during the block operation */ SYS_MEDIA_EVENT_BLOCK_COMMAND_ERROR } SYS_MEDIA_BLOCK_EVENT ;  ",
							" Summary Identifies the possible events that can result from a request ",
							" Description This enumeration identifies the possible events that can result from a media ",
							" Remarks One of these values is passed in the \"event\" parameter of the event handling callback function that client registered with the driver by setting the event handler when a block request is completed ",
							" SYS_MEDIA_PROPERTY Enum ",
							" C typedef  enum  {  /* Media supports Byte Write */ SYS_MEDIA_SUPPORTS_BYTE_WRITES =  0x01   /* Media supports only Read operation */ SYS_MEDIA_SUPPORTS_READ_ONLY =  0x02   /* Media supports OTP (One Time Programming) */ SYS_MEDIA_SUPPORTS_ONE_TIME_PROGRAMING =  0x04   /* Read in blocking */ SYS_MEDIA_READ_IS_BLOCKING =  0x08   /* Write is blocking */ SYS_MEDIA_WRITE_IS_BLOCKING =  0x10   } SYS_MEDIA_PROPERTY ;  ",
							" Summary Contains information of property of a media ",
							" Description This structure contains the information of property of a media device ",
							" Remarks For a device if multiple properties are applicable they can be ORed together and used ",
							" SYS_MEDIA_STATUS Enum ",
							" C typedef  enum  {  /* Media is detached */ SYS_MEDIA_DETACHED   /* Media is attached */ SYS_MEDIA_ATTACHED } SYS_MEDIA_STATUS ;  ",
							" Summary The state of media ",
							" Description This enumeration states if the media is attached or not ",
							" Remarks None ",
							" SYS_MEDIA_COMMAND_STATUS Enum ",
							" C typedef  enum  {  /*Done OK and ready */ SYS_MEDIA_COMMAND_COMPLETED =  0    /*Scheduled but not started */ SYS_MEDIA_COMMAND_QUEUED =  1   /*Currently being in transfer */ SYS_MEDIA_COMMAND_IN_PROGRESS =  2   /*Unknown buffer */ SYS_MEDIA_COMMAND_UNKNOWN =  - 1   } SYS_MEDIA_COMMAND_STATUS ;  ",
							" Summary The enumeration for status of buffer ",
							" Description This enumeration contains the various status of buffer ",
							" Remarks None ",
							" SYS_MEDIA_GEOMETRY_TABLE_ENTRY Macros ",
							" C /* Read Region Geometry Table Index Numbers */  # define SYS_MEDIA_GEOMETRY_TABLE_READ_ENTRY (0)  /* Write Region Geometry Table Index Numbers */  # define SYS_MEDIA_GEOMETRY_TABLE_WRITE_ENTRY (1)  /* Erase Region Geometry Table Index Numbers */  # define SYS_MEDIA_GEOMETRY_TABLE_ERASE_ENTRY (2)  ",
							" Summary Defines the Sys Media Geometry table entry Macros ",
							" Description These Macros can be used the get the Geometry details for particular operation (read/write/erase) populates using the SYS_MEDIA_REGION_GEOMETRY structure ",
							" Remarks None ",
							" SYS_MEDIA_REGION_GEOMETRY Struct ",
							" C typedef  struct  {  /* Size of a each block in Bytes */ uint32_t blockSize ;  /* Number of Blocks of identical size within the Region */ uint32_t numBlocks ;  } SYS_MEDIA_REGION_GEOMETRY ;  ",
							" Summary Contains information of a sys media region ",
							" Description This structure contains the information of a sys media region ",
							" Remarks A media can have multiple regions Sum of size of all the regions is the total memory size of the media Each region is further divided into blocks of identical size ",
							" SYS_MEDIA_GEOMETRY Struct ",
							" C typedef  struct  {  /* Properties of a Media For a device if multiple properties are applicable they can be ORed */ SYS_MEDIA_PROPERTY mediaProperty ;  /* Number of Read Regions */ uint32_t numReadRegions ;  /* Number of Write Regions */ uint32_t numWriteRegions ;  /* Number of Erase Regions */ uint32_t numEraseRegions ;  /* Pointer to the table containing the geometry information */ SYS_MEDIA_REGION_GEOMETRY * geometryTable ;  } SYS_MEDIA_GEOMETRY ;  ",
							" Summary Contains all the geometrical information of a media device ",
							" Description This structure contains all the geometrical information of a media device the structure also has property of the media like media is one time programmable (OTP) or Read Only etc ",
							" Remarks A memory device can have multiple erase block regions Sum of all the regions is the total memory size of the device ",
							" SYS_MODULE_INDEX Typedef ",
							" C typedef  unsigned  short  int SYS_MODULE_INDEX ;  ",
							" Summary Identifies which instance of a system module should be initialized or opened ",
							" Description This data type identifies to which instance of a system module a call to that module's \"Initialize\" and \"Open\" routines refers ",
							" Remarks Each individual module will usually define macro names for the index values it supports (e g DRV_USART_INDEX_1 DRV_USART_INDEX_2 ) ",
							" SYS_MODULE_OBJ Typedef ",
							" C typedef uintptr_t SYS_MODULE_OBJ ;  ",
							" Summary Handle to an instance of a system module ",
							" Description This data type is a handle to a specific instance of a system module (such as a device driver) ",
							" Remarks Code outside of a specific module should consider this as an opaque type (much like a void *) Do not make any assumptions about base type as it may change in the future or about the value stored in a variable of this type ",
							" SYS_MODULE_OBJ_INVALID Macro ",
							" C # define SYS_MODULE_OBJ_INVALID ((SYS_MODULE_OBJ) -1 )  ",
							" Summary Object handle value returned if unable to initialize the requested instance of a system module ",
							" Description This is the object handle value returned if unable to initialize the requested instance of a system module ",
							" Remarks Do not rely on the actual value of this constant It may change in future implementations ",
							" SYS_MODULE_OBJ_STATIC Macro ",
							" C # define SYS_MODULE_OBJ_STATIC ((SYS_MODULE_OBJ) 0 )  ",
							" Summary Object handle value returned by static modules ",
							" Description This is the object handle value returned by static system modules ",
							" Remarks Do not rely on the actual value of this constant It may change in future implementations ",
							" SYS_STATUS Enum ",
							" C typedef  enum  {  // Indicates that a non-system defined error has occurred The caller  // must call the extended status routine for the module in question to  // identify the error SYS_STATUS_ERROR_EXTENDED =  - 10   /*An unspecified error has occurred */ SYS_STATUS_ERROR =  - 1   // The module has not yet been initialized SYS_STATUS_UNINITIALIZED =  0   // An operation is currently in progress SYS_STATUS_BUSY =  1   // Any previous operations have succeeded and the module is ready for  // additional operations SYS_STATUS_READY =  2   // Indicates that the module is in a non-system defined ready/run state  // The caller must call the extended status routine for the module in  // question to identify the state SYS_STATUS_READY_EXTENDED =  10  } SYS_STATUS ;  ",
							" Summary Identifies the current status/state of a system module (including device drivers) ",
							" Description This enumeration identifies the current status/state of a system module (including device drivers) ",
							" Remarks This enumeration is the return type for the system-level status routine defined by each device driver or system module (for example DRV_I2C_Status) ",
							" SYS_MODULE_INIT Union ",
							" C typedef  union  { uint8_t value ;  struct  {  // Module-definable field module-specific usage uint8_t reserved :  4 ;  } sys ;  } SYS_MODULE_INIT ; ",
							" Summary Initializes a module (including device drivers) as requested by the system ",
							" Description This structure provides the necessary data to initialize or reinitialize a module (including device drivers) The structure can be extended in a module specific way as to carry module specific initialization data ",
							" Remarks This structure is used in the device driver routines DRV_ Initialize and DRV _Reinitialize that are defined by each device driver ",
							" SYS_MODULE_INITIALIZE_ROUTINE Typedef ",
							" C typedef SYS_MODULE_OBJ ( * SYS_MODULE_INITIALIZE_ROUTINE )  (  const SYS_MODULE_INDEX index   ",
							" Summary Pointer to a routine that initializes a system module (driver library or system-maintained application) ",
							" Description This data type is a pointer to a routine that initializes a system module (driver library or system-maintained application) ",
							" Precondition The low-level board initialization must have (and will be) completed before the system will call the initialization routine for any modules ",
							" Parameters Param Description index Identifier for the module instance to be initialized init Pointer to the data structure containing any data necessary to initialize the module This pointer may be null if no data is required and default initialization is to be used ",
							" Returns A handle to the instance of the system module that was initialized This handle is a necessary parameter to all of the other system-module level routines for that module ",
							" Remarks This function will only be called once during system initialization ",
							" SYS_MODULE_REINITIALIZE_ROUTINE Typedef ",
							" C  typedef  void  ( * SYS_MODULE_REINITIALIZE_ROUTINE )  ( SYS_MODULE_OBJ object   ",
							" Summary Pointer to a routine that reinitializes a system module (driver library or system-maintained application) ",
							" Description This data type is a pointer to a routine that reinitializes a system module (driver library or system-maintained application) ",
							" Precondition The low-level board initialization must have (and will be) completed and the module's initialization routine will have been called before the system will call the reinitialization routine for any modules ",
							" Parameters Param Description object Handle to the module instance init Pointer to the data structure containing any data necessary to initialize the module This pointer may be null if no data is required and default initialization is to be used ",
							" Returns None ",
							" Example None ",
							" Remarks This operation uses the same initialization data structure as the Initialize operation This operation can be used to refresh the hardware state as defined by the initialization data thus it must guarantee that all hardware state has been refreshed This function can be called multiple times to reinitialize the module ",
							" SYS_MODULE_DEINITIALIZE_ROUTINE Typedef ",
							" C typedef  void  ( * SYS_MODULE_DEINITIALIZE_ROUTINE )  ( SYS_MODULE_OBJ object ) ; ",
							" Summary Pointer to a routine that deinitializes a system module (driver library or system-maintained application) ",
							" Description System Module Deinitialization Routine Pointer This data type is a pointer to a routine that deinitializes a system module (driver library or system-maintained application) ",
							" Preconditions The low-level board initialization must have (and will be) completed and the module's initialization routine will have been called before the system will call the deinitialization routine for any modules ",
							" Parameters Param Description object Handle to the module instance ",
							" Returns None ",
							" Example None ",
							" Remarks If the module instance has to be used again the module's \"initialize\" function must first be called ",
							" SYS_MODULE_STATUS_ROUTINE Typedef ",
							" C typedef SYS_STATUS ( * SYS_MODULE_STATUS_ROUTINE )  ( SYS_MODULE_OBJ object ) ;  ",
							" Summary Pointer to a routine that gets the current status of a system module (driver library or system-maintained application) ",
							" Description This data type is a pointer to a routine that gets the current status of a system module (driver library or system-maintained application) ",
							" Precondition The low-level board initialization must have (and will be) completed and the module's initialization routine will have been called before the system will call the status routine for any modules ",
							" Parameters Param Description object Handle to the module instance ",
							" Returns One of the possible status codes from SYS_STATUS ",
							" Remarks A module's status operation can be used to determine when any of the other module level operations has completed as well as to obtain general status of the module The value returned by the status routine will be checked after calling any of the module operations to find out when they have completed If the status operation returns SYS_STATUS_BUSY the previous operation has not yet completed Once the status operation returns SYS_STATUS_READY any previous operations have completed The value of SYS_STATUS_ERROR is negative (-1) A module may define module-specific error values of less or equal SYS_STATUS_ERROR_EXTENDED (-10) The status function must NEVER block If the status operation returns an error value the error may be cleared by calling the reinitialize operation If that fails the deinitialize operation will need to be called followed by the initialize operation to return to normal operations ",
							" SYS_MODULE_TASKS_ROUTINE Typedef ",
							" C typedef  void  ( * SYS_MODULE_TASKS_ROUTINE )  ( SYS_MODULE_OBJ object ) ;  ",
							" Summary Pointer to a routine that performs the tasks necessary to maintain a state machine in a module system module (driver library or system-maintained application) ",
							" Description This data type is a pointer to a routine that performs the tasks necessary to maintain a state machine in a module system module (driver library or system-maintained application) ",
							" Precondition The low-level board initialization must have (and will be) completed and the module's initialization routine will have been called before the system will call the deinitialization routine for any modules ",
							" Parameters Param Description object Handle to the module instance ",
							" Returns None ",
							" Example None ",
							" Remarks If the module is interrupt driven the system will call this routine from an interrupt context ",
							" Cache System Service The Cache system service uses either CMSIS Cache interfaces or the device specific Cache Peripheral interfaces based on the device selection to perform the Data and Instruction Cache operations It provides interface to Enable Disable Clean Invalidate Data and Instruction Cache Abstraction Model This library provides an abstraction of the Cache subsystem that is used by device drivers middleware libraries and applications to perform Cache maintenance operations sys_cache_abstraction_model Library Interface Cache system service provides the following interfaces: Functions Name Description SYS_CACHE_EnableCaches Enables both Instruction and Data Caches SYS_CACHE_DisableCaches Disables both Instruction and Data Caches SYS_CACHE_EnableICache Enable Instruction Cache SYS_CACHE_DisableICache Disable Instruction Cache SYS_CACHE_InvalidateICache Invalidate Instruction Cache SYS_CACHE_EnableDCache Enable Data Cache SYS_CACHE_DisableDCache Disable Data Cache SYS_CACHE_InvalidateDCache Invalidate Data Cache SYS_CACHE_CleanDCache Clean Data Cache SYS_CACHE_CleanInvalidateDCache Clean and Invalidate Data Cache SYS_CACHE_InvalidateDCache_by_Addr Invalidate Data Cache by address SYS_CACHE_CleanDCache_by_Addr Data Cache Clean by address SYS_CACHE_CleanInvalidateDCache_by_Addr Data Cache Clean and Invalidate by address ",
							" SYS_CACHE_EnableCaches Function ",
							" C void SYS_CACHE_EnableCaches ( void ) ",
							" Summary Enables both Instruction and Data Caches ",
							" Description Turns on both Instruction and Data Caches ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example SYS_CACHE_EnableCaches ( ) ; ",
							" Remarks None ",
							" SYS_CACHE_DisableCaches Function ",
							" C void SYS_CACHE_DisableCaches ( void ) ",
							" Summary Disables both Instruction and Data Caches ",
							" Description Turns off both Instruction and Data Caches ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example SYS_CACHE_DisableCaches ( ) ; ",
							" Remarks None ",
							" SYS_CACHE_EnableICache Function ",
							" C void SYS_CACHE_EnableICache ( void ) ",
							" Summary Enable Instruction Cache ",
							" Description Turns on Instruction Cache ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example SYS_CACHE_EnableICache ( ) ; ",
							" Remarks None ",
							" SYS_CACHE_DisableICache Function ",
							" C void SYS_CACHE_DisableICache ( void ) ",
							" Summary Disable Instruction Cache ",
							" Description Turns off Instruction Cache ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example SYS_CACHE_DisableICache ( ) ; ",
							" Remarks None ",
							" SYS_CACHE_InvalidateICache Function ",
							" C void SYS_CACHE_InvalidateICache ( void ) ",
							" Summary Invalidate Instruction Cache ",
							" Description Invalidates Instruction Cache ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example SYS_CACHE_InvalidateICache ( ) ; ",
							" Remarks None ",
							" SYS_CACHE_EnableDCache Function ",
							" C void SYS_CACHE_EnableDCache ( void ) ",
							" Summary Enable Data Cache ",
							" Description Turns on Data Cache ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example SYS_CACHE_EnableDCache ( ) ; ",
							" Remarks None ",
							" SYS_CACHE_DisableDCache Function ",
							" C void SYS_CACHE_DisableDCache ( void ) ",
							" Summary Disable Data Cache ",
							" Description Turns off Data Cache ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example SYS_CACHE_DisableDCache ( ) ; ",
							" Remarks None ",
							" SYS_CACHE_InvalidateDCache Function ",
							" C void SYS_CACHE_InvalidateDCache ( void ) ",
							" Summary Invalidate Data Cache ",
							" Description Invalidates Data Cache ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example SYS_CACHE_InvalidateDCache ( ) ; ",
							" Remarks None ",
							" SYS_CACHE_CleanDCache Function ",
							" C void SYS_CACHE_CleanDCache ( void ) ",
							" Summary Clean Data Cache ",
							" Description Cleans Data Cache ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example SYS_CACHE_CleanDCache ( ) ; ",
							" Remarks None ",
							" SYS_CACHE_CleanInvalidateDCache Function ",
							" C void SYS_CACHE_CleanInvalidateDCache ( void ) ",
							" Summary Clean and Invalidate Data Cache ",
							" Description Cleans and Invalidates Data Cache ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example SYS_CACHE_CleanInvalidateDCache ( ) ; ",
							" Remarks None ",
							" SYS_CACHE_InvalidateDCache_by_Addr Function ",
							" C void SYS_CACHE_InvalidateDCache_by_Addr ( uint32_t * addr  int32_t size ) ",
							" Summary Invalidate Data Cache by address ",
							" Description Invalidates Data Cache for the given address ",
							" Precondition None ",
							" Parameters Param Description addr address (aligned to 32-byte boundary) size size of memory block (in number of bytes) ",
							" Returns None ",
							" Example SYS_CACHE_InvalidateDCache_by_Addr ( addr  size ) ; ",
							" Remarks None ",
							" SYS_CACHE_CleanDCache_by_Addr Function ",
							" C void SYS_CACHE_CleanDCache_by_Addr ( uint32_t * addr  int32_t size ) ",
							" Summary Data Cache Clean by address ",
							" Description Cleans Data Cache for the given address ",
							" Precondition None ",
							" Parameters Param Description addr address (aligned to 32-byte boundary) size size of memory block (in number of bytes) ",
							" Returns None ",
							" Example SYS_CACHE_CleanDCache_by_Addr ( addr  size ) ; ",
							" Remarks None ",
							" SYS_CACHE_CleanInvalidateDCache_by_Addr Function ",
							" C void SYS_CACHE_CleanInvalidateDCache_by_Addr ( uint32_t * addr  int32_t size ) ",
							" Summary Data Cache Clean and Invalidate by address ",
							" Description Cleans and invalidates Data Cache for the given address ",
							" Precondition None ",
							" Parameters Param Description addr address (aligned to 32-byte boundary) size size of memory block (in number of bytes) ",
							" Returns None ",
							" Example SYS_CACHE_CleanInvalidateDCache_by_Addr ( addr  size ) ; ",
							" Remarks None ",
							" Command Processor System Service The Command Processor System Service Library is a collection of operations specific to supporting user input commands It provides the developer with simple APIs to implement a command console The commands can be uniquely native to each client service and can be dynamically added The library can support multiple client services at once ",
							" How the Library Works Abstraction Model The Command Processor System Service is a module that works closely with the Console System Service to present a user interface command prompt sys_command_abstraction_model Working Flow Initialization and Reinitialization Initialization of the Command Processor System Service initializes the status of the module and sets the state of the internal state machine The Command Processor Status and Tasks routines are required for the normal operation of the service Adding Commands The Command Processor System Service will accept commands dynamically during run-time through the follow interface: SYS_COMMAND_ADDGRP ( const _SYS_CMD_DCPT * pCmdTbl   int nCmds   const  char * groupName   const  char * menuStr ) Command Prompt In conjunction with the Console System Service the Command Processor System Service provides the user with an ASCII command prompt It will interpret the commands entered at the prompt and process accordingly It also supports command history as well as command help ",
							" Using The Library In conjunction with the Console System Service the Command Processor System Service provides the user with an ASCII command prompt It will interpret the commands entered at the prompt and process accordingly It also supports command history as well as command help ",
							" Configuring The Library Command System Service Library should be configured via MHC The following figures show the MHC configuration window for Command System Service and brief description The Command Processor is dependent on the services provided by the console system which in turn depends on the UART PLIB or USB CDC function driver Command System Service connected to UART based Console sys_command_mhc_config_uart_console Command System Service connected to USB based Console sys_command_mhc_config_usb_console Configuration Options Device Used: Indicates the console instance that the Debug System Service will use Command Print Buffer Size (512-8192): Indicates the size of the command print buffer in bytes Maximum Command Groups: Specifies the maximum command groups to be used Maximum Arguments Per Command: Specifies the maximum number of arguments per command RTOS Settings: Stack Size (in bytes): Specifies the number of bytes to be allocated on the stack for the System Command task Task Priority: Specifies priority for the System Commandtask thread The value can vary based on RTOS used Use Task Delay When enabled the System Command task will be scheduled out voluntarily after every run based on the delay configured Task Delay (ms): Indicates the amount of time for which the System Command RTOS thread is put in blocked state by the scheduler before it is run again RTOS Settings For MicriumOS-III RTOS Below additional options are visible in system commands RTOS settings when the MicriumOS-III is added into project graph rtos_settings_micrium_os_iii Maximum Message Queue Size: This argument specifies the maximum number of messages that the task can receive through internal message queue A MicriumOS-III task contains an optional internal message queue (if OS_CFG_TASK_Q_EN is set to DEF_ENABLED in os_cfg h) The user may specify that the task is unable to receive messages by setting this argument to 0 Task Time Quanta: The amount of time (in clock ticks) for the time quanta when Round Robin is enabled If you specify 0 then the default time quanta will be used which is the tick rate divided by 10 Task Specific Options: Contains task-specific options Each option consists of one bit The option is selected when the bit is set The current version of MicriumOS-III supports the following options: Stack checking is allowed for the task: Specifies whether stack checking is allowed for the task Stack needs to be cleared: Specifies whether the stack needs to be cleared Floating-point registers needs to be saved: Specifies whether floating-point registers are saved This option is only valid if the processor has floating-point hardware and the processor-specific code saves the floating-point registers TLS (Thread Local Storage) support needed for the task: If the caller doesn�t want or need TLS (Thread Local Storage) support for the task being created If you do not include this option TLS will be supported by default TLS support was added in V3 03 00 ",
							" Library Interface Command System Service library provides the following interfaces: Functions Name Description SYS_CMD_Initialize Initializes data for the instance of the Command Processor module SYS_CMD_ADDGRP Allows clients to add command process to the Command Processor System Service SYS_CMD_DELETE Removes CMDIO parameters from the Command Processor System Service console SYS_CMD_READY_TO_READ Allows upper layer application to confirm that the command module is ready to accept command input SYS_CMD_READY_TO_WRITE Allows upper layer application to confirm that the command module is ready to write output to the Console System Service SYS_CMD_Tasks Maintains the Command Processor System Service's internal state machine SYS_CMD_MESSAGE Outputs a message to the Command Processor System Service console SYS_CMD_PRINT Outputs a printout to the Command Processor System Service console SYS_CMDIO_GET_HANDLE Gets the CMDIO Handle base via index SYS_CMDIO_ADD Adds CMDIO parameters to the Command Processor System Service console Data types and constants Name Type Description COMMAND_HISTORY_DEPTH Macro Command Processor System Service Maximum Depth of Command History SYS_CMD_MAX_LENGTH Macro Command Processor System Service Command Buffer Maximum Length definition SYS_CMD_READ_BUFFER_SIZE Macro Command Processor System Service Read Buffer Size definition SYS_CMD_CallbackFunction Typedef Command Callback Function Handle SYS_CMD_HANDLE Typedef Identifies a particular Command I/O instance SYS_CMD_MSG_FNC Typedef Identifies a message function API SYS_CMD_PRINT_FNC Typedef Identifies a print function API SYS_CMD_PUTC_FNC Typedef Identifies a single character print function API SYS_CMD_DATA_RDY_FNC Typedef Identifies a data available function API SYS_CMD_GETC_FNC Typedef Identifies a get single character function API SYS_CMD_READC_FNC Typedef Identifies a read single character function API SYS_CMD_API Struct Identifies the Command API structure SYS_CMD_EVENT Enum Identifies the Command Event Types SYS_CMD_CONSOLE_IO_PARAM Enum Defines whether the command module is single character or full command read SYS_CMD_INIT Struct Identifies the system command initialize structure SYS_CMD_DEVICE_NODE Struct Defines the data structure to store each command instance SYS_CMD_FNC Typedef Identifies the command process function API SYS_CMD_DESCRIPTOR Struct Defines the descriptor structure for a single command process ",
							" SYS_CMD_Initialize Function ",
							" C bool SYS_CMD_Initialize (  const SYS_MODULE_INIT *  const init ) ",
							" Summary Initializes data for the instance of the Command Processor module ",
							" Description This function initializes the Command Processor module It also initializes any internal data structures ",
							" Precondition None ",
							" Parameters Param Description init Pointer to a data structure containing any data necessary to initialize the sys command This pointer may be null if no data is required because static overrides have been provided ",
							" Returns true - Indicates success false - Indicates an error occurred ",
							" Remarks This routine should only be called once during system initialization ",
							" SYS_CMD_ADDGRP Function ",
							" C bool SYS_CMD_ADDGRP ( const SYS_CMD_DESCRIPTOR * pCmdTbl   int nCmds   const  char * groupName   const  char * menuStr ) ",
							" Summary Allows clients to add command process to the Command Processor System Service ",
							" Description Client modules may call this function to add command process to the Command Processor System Service ",
							" Precondition SYS_CMD_Initialize was successfully run once ",
							" Parameters None ",
							" Example static const SYS_CMD_DESCRIPTOR cmdTbl = { {\"command_as_typed_at_the_prompt\" _Function_Name_That_Supports_The_Command \": Helpful description of the command for the user\"} }; bool APP_AddCommandFunction() { if ( SYS_CMD_ADDGRP(cmdTbl sizeof(cmdTbl)/sizeof(*cmdTbl) \"Command Group Name\" \": Command Group Description\")) { return false; } return true; } ",
							" Returns true - Indicates success false - Indicates an error occurred ",
							" Remarks None ",
							" SYS_CMD_DELETE Function ",
							" C bool SYS_CMD_DELETE ( SYS_CMD_DEVICE_NODE * pDevNode ) ; ",
							" Summary Removes CMDIO parameters from the Command Processor System Service console ",
							" Description This function removes CMDIO parameters from the Command Processor System Service console ",
							" Precondition SYS_CMD_Initialize was successfully run once ",
							" Parameters None ",
							" Returns true - if the corresponding dommand device has been deleted false - otherwise (no such node) ",
							" Remarks None ",
							" SYS_CMD_READY_TO_READ Function ",
							" C bool SYS_CMD_READY_TO_READ (  void  ) ",
							" Summary Allows upper layer application to confirm that the command module is ready to accept command input ",
							" Description This function allows upper layer application to confirm that the command module is ready to accept command input ",
							" Precondition SYS_CMD_Initialize was successfully run once ",
							" Parameters None ",
							" Returns true - Indicates command module is ready false - Indicates command module is not ready ",
							" Remarks None ",
							" SYS_CMD_READY_TO_WRITE Function ",
							" C bool SYS_CMD_READY_TO_WRITE (  void  ) ",
							" Summary Allows upper layer application to confirm that the command module is ready to write output to the Console System Service ",
							" Description This function allows upper layer application to confirm that the command module is ready to write output to the Console System Service ",
							" Precondition SYS_CMD_Initialize was successfully run once ",
							" Parameters None ",
							" Returns true - Indicates command module is ready false - Indicates command module is not ready ",
							" Remarks None ",
							" SYS_CMD_Tasks Function ",
							" C bool SYS_CMD_Tasks (  void  ) ",
							" Summary Maintains the Command Processor System Service's internal state machine ",
							" Description This function is used to maintain the Command Processor System Service internal state machine ",
							" Precondition SYS_CMD_Initialize was successfully run once ",
							" Parameters None ",
							" Returns true - Indicates success false - Indicates an error occurred ",
							" Remarks None ",
							" SYS_CMD_MESSAGE Function ",
							" C void SYS_CMD_MESSAGE ( const  char * message ) ",
							" Summary Outputs a message to the Command Processor System Service console ",
							" Description This function outputs a message to the Command Processor System Service console ",
							" Precondition SYS_CMD_Initialize was successfully run once ",
							" Parameters None ",
							" Returns None ",
							" Remarks None ",
							" SYS_CMD_PRINT Function ",
							" C void  SYS_CMD_PRINT ( const  char  * format      ) ",
							" Summary Outputs a printout to the Command Processor System Service console ",
							" Description This function outputs a printout to the Command Processor System Service console ",
							" Precondition SYS_CMD_Initialize was successfully run once ",
							" Parameters None ",
							" Returns None ",
							" Remarks None ",
							" SYS_CMDIO_GET_HANDLE Function ",
							" C SYS_CMD_DEVICE_NODE *  SYS_CMDIO_GET_HANDLE ( short num ) ",
							" Summary Gets the CMDIO Handle base via index ",
							" Description This function returns the handle for the CMDIO when supplied with an index ",
							" Precondition SYS_CMD_Initialize was successfully run once ",
							" Parameters short num ",
							" Returns SYS_CMD_DEVICE_NODE Handle for the CMDIO - Indicates success NULL - Indicates not successful ",
							" Remarks None ",
							" SYS_CMDIO_ADD Function ",
							" C SYS_CMD_DEVICE_NODE *  SYS_CMDIO_ADD ( const SYS_CMD_API * opApi   const  void * cmdIoParam   int unused ) ",
							" Summary Adds CMDIO parameters to the Command Processor System Service console ",
							" Description This function adds CMDIO Parameters to the Command Processor System Service console ",
							" Precondition SYS_CMD_Initialize was successfully run once ",
							" Parameters None ",
							" Returns None ",
							" Remarks None ",
							" COMMAND_HISTORY_DEPTH Macro ",
							" C # define COMMAND_HISTORY_DEPTH 4  ",
							" Summary Command Processor System Service Maximum Depth of Command History ",
							" Description This macro defines the maximum depth of the command history ",
							" Remarks None ",
							" SYS_CMD_MAX_LENGTH Macro ",
							" C # define SYS_CMD_MAX_LENGTH 80  ",
							" Summary Command Processor System Service Command Buffer Maximum Length definition ",
							" Description This macro defines the maximum length of the command buffer ",
							" Remarks None ",
							" SYS_CMD_READ_BUFFER_SIZE Macro ",
							" C # define SYS_CMD_READ_BUFFER_SIZE 128  ",
							" Summary Command Processor System Service Read Buffer Size definition ",
							" Description This macro defines the maximum size of the command buffer ",
							" Remarks None ",
							" SYS_CMD_CallbackFunction Typedef ",
							" C typedef  void  ( * SYS_CMD_CallbackFunction )  ( void  * handle ) ;  ",
							" Summary Command Callback Function Handle ",
							" Description Command Callback Function Handle ",
							" Remarks None ",
							" SYS_CMD_HANDLE Typedef ",
							" C typedef  const  void * SYS_CMD_HANDLE ;  ",
							" Summary Identifies a particular Command I/O instance ",
							" Description Command I/O Handle This event handle identifies a registered instance of a Command IO object Every time the application that tries to access the parameters with respect to a particular event this event handle is used to refer to that event ",
							" Remarks None ",
							" SYS_CMD_MSG_FNC Typedef ",
							" C typedef  void  ( * SYS_CMD_MSG_FNC ) ( const  void * cmdIoParam   const  char * str ) ;  ",
							" Summary Identifies a message function API ",
							" Description Message function API This handle identifies the interface structure of the message function API within the Command I/O encapsulation ",
							" Remarks None ",
							" SYS_CMD_PRINT_FNC Typedef ",
							" C typedef  void  ( * SYS_CMD_PRINT_FNC ) ( const  void * cmdIoParam   const  char * format      ) ;  ",
							" Summary Identifies a print function API ",
							" Description Print function API This handle identifies the interface structure of the print function API within the Command I/O encapsulation ",
							" Remarks None ",
							" SYS_CMD_PUTC_FNC Typedef ",
							" C typedef  void  ( * SYS_CMD_PUTC_FNC ) ( const  void * cmdIoParam   char c ) ;  ",
							" Summary Identifies a single character print function API ",
							" Description Single Character Print function API This handle identifies the interface structure of single character print function API within the Command I/O encapsulation ",
							" Remarks None ",
							" SYS_CMD_DATA_RDY_FNC Typedef ",
							" C typedef  int  ( * SYS_CMD_DATA_RDY_FNC ) ( const  void * cmdIoParam ) ;  ",
							" Summary Identifies a data available function API ",
							" Description Ready Status Check function API This handle identifies the interface structure of the data available function API within the Command IO encapsulation Returns the number of available characters that could be read ",
							" Remarks None ",
							" SYS_CMD_GETC_FNC Typedef ",
							" C typedef  char  ( * SYS_CMD_GETC_FNC ) ( const  void * cmdIoParam ) ;  ",
							" Summary Identifies a get single character function API ",
							" Description Get Single Character function API This handle identifies the interface structure of the get single character function API within the Command I/O encapsulation ",
							" Remarks None ",
							" SYS_CMD_READC_FNC Typedef ",
							" C typedef size_t ( * SYS_CMD_READC_FNC ) ( const  void * cmdIoParam ) ;  ",
							" Summary Identifies a read single character function API ",
							" Description Read Single Character function API This handle identifies the interface structure of read single character function API within the Command I/O encapsulation ",
							" Remarks None ",
							" SYS_CMD_API Struct ",
							" C typedef  struct  {  // Message function API SYS_CMD_MSG_FNC msg ;  // Print function API SYS_CMD_PRINT_FNC print ;  // Put single char function API SYS_CMD_PUTC_FNC putc ;  // Data available API SYS_CMD_DATA_RDY_FNC isRdy ;  // Get single data API SYS_CMD_GETC_FNC getc ;  } SYS_CMD_API ;  ",
							" Summary Identifies the Command API structure ",
							" Description This structure identifies the Command API structure ",
							" Remarks None ",
							" SYS_CMD_EVENT Enum ",
							" C typedef  enum  { SYS_CMD_EVENT_WRITE_COMPLETE  SYS_CMD_EVENT_READ_COMPLETE   } SYS_CMD_EVENT ;  ",
							" Summary Identifies the Command Event Types ",
							" Description This structure identifies the Command Event Types ",
							" Remarks None ",
							" SYS_CMD_CONSOLE_IO_PARAM Enum ",
							" C typedef  enum  { SYS_CMD_SINGLE_CHARACTER_READ_CONSOLE_IO_PARAM =  0   } SYS_CMD_CONSOLE_IO_PARAM ;  ",
							" Summary Defines whether the command module is single character or full command read ",
							" Description This enumeration defines whether the command module is single character or full command read ",
							" Remarks None ",
							" SYS_CMD_INIT Struct ",
							" C typedef  struct  {  /* System module initialization */ SYS_MODULE_INIT moduleInit ; uint8_t consoleCmdIOParam ;  /* Console index to receive debug messages */ SYS_MODULE_INDEX consoleIndex ;  } SYS_CMD_INIT ;  ",
							" Summary Identifies the system command initialize structure ",
							" Description This structure identifies the system command initialize structure ",
							" Remarks None ",
							" SYS_CMD_DEVICE_NODE Struct ",
							" C typedef  struct  {  const SYS_CMD_API * pCmdApi ;  // Cmd IO APIs  const  void * cmdIoParam ;  // channel specific parameter  } SYS_CMD_DEVICE_NODE ;  ",
							" Summary Defines the data structure to store each command instance ",
							" Description This data structure stores all the data relevant to a uniquely entered command instance It is a node for a linked list structure to support the Command Processor System Service's command history feature ",
							" Remarks None ",
							" SYS_CMD_FNC Typedef ",
							" C typedef  void  ( * SYS_CMD_FNC ) ( SYS_CMD_DEVICE_NODE * pCmdIO   int argc   char  * * argv ) ;  SYS CMD Command Function ",
							" Summary Identifies the command process function API ",
							" Description Command Process Function API This handle identifies the interface structure of the command process function API ",
							" Remarks None ",
							" SYS_CMD_DESCRIPTOR Struct ",
							" C typedef  struct  {  const  char * cmdStr ;  // string identifying the command SYS_CMD_FNC cmdFnc ;  // function to execute for this command  const  char * cmdDescr ;  // simple command description  } SYS_CMD_DESCRIPTOR ;  // a simple command descriptor  ",
							" Summary Defines the descriptor structure for a single command process ",
							" Description This data structure stores the information for a single unique command process ",
							" Remarks None ",
							" Console System Service The Console System Service is a middleware library that is part of a layered software architecture The purpose of this software layering is to allow each module to provide a consistent interface to its client thus making it easy for the developer to add and remove modules as needed The console core layer_provides a POSIX-like read/write API to applications and middleware libraries to send and receive data to and from the console device Data and message buffering along with the details of the data transfer are contained within the console device and peripheral library (PLIB) layers ",
							" How the Library Works Each supported console device has its own implementation of the Console System service APIs Function pointers to the console device implementations are provided in the console device descriptor registered to each console instance This allows the user to utilize the same API for all console devices making application code more portable across different devices Note: Currently UART and USB CDC Console Devices are supported Abstraction Model sys_console_abstraction_model The Console System Service consists of a core_layer and a console device_layer The core_layer handles module initialization and system functions It provides a common API for use by applications and middleware libraries to send and receive data to and from one or more console devices The Console System core layer_maintains the status and device descriptor information for each console instance that has been initialized The console device layer_contains the functional implementation of the core layer_APIs Each console device may have a different implementation but the behavior of the API should be uniform across different devices The console device layer_interacts with the peripheral libraries or drivers or middle-wares to send and receive data to and from the hardware peripheral The details of the data transaction are abstracted by the console device layer Working Flow Read The console device layer saves the received data in an internal receive ring buffer The size of the receive buffer is user configurable When the application submits a read request the console device layer copies the available data from the receive buffer to the application buffer and returns the number of bytes copied The application must check the return value to verify the number of bytes copied If the return value is less than the one requested the application should retry again after some time Additional APIs let application query the number of bytes available in the receive buffer and the free space in the receive buffer It is the application's responsibility to ensure it reads the data out from the receive buffer at regular intervals to avoid receive buffer overflow and hence loss of data Write For the write requests the console device layer copies the application data into the transmit ring buffer The size of the transmit buffer is user configurable The number of bytes actually copied in the transmit buffer is indicated by the return value of the write API Depending on the free space available in the transmit buffer; the application data may be completely or partially copied It is the application's responsibility to check the return value If the return value is less than the one requested the application should retry sending the remaining characters after some time Additional APIs let application query the free space available in the transmit buffer APIs are provided to query the number of bytes pending transmission and the configured size of the transmit buffer State Machine For UART the read and write state machines are run from the interrupt context in both bare-metal and RTOS environment For USB CDC console the read and write state machine is run from a while(1) loop along with other tasks In RTOS environment a separate RTOS thread runs the USB CDC console state machine ",
							" Using The Library The Console System Service allows the application/middleware to route messages/debug information to a console running on a host computer Depending on the application need the size of the transmit and receive ring buffers can be configured The read/write API called by the calling program returns immediately For read requests the read API returns the available bytes from the receive buffer For write requests the write API copies the application data to the transmit buffer For read APIs are provided to query the number of bytes present in the receive buffer the amount of free space available in the receive buffer and the size of the receive buffer Similarly for writes APIs are provided to query the number of bytes pending transmission in the transmit buffer the amount of free space in the transmit buffer and the size of the transmit buffer Example Application to Read and Write from UART Console # define UART_CONSOLE_NUM_BYTES_READ 10  # define UART_CONSOLE_READ_BUFFER_SIZE 10 uint8_t uart_console_read_buffer [ UART_CONSOLE_READ_BUFFER_SIZE ] ; APP_DATA appData ;  void APP_Initialize (  void  )  {  /* Place the App state machine in its initial state */ appData  state = APP_STATE_WAIT_UART_CONSOLE_CONFIGURED ;  }  void APP_Tasks (  void  )  {  switch  ( appData  state )  {  case APP_STATE_WAIT_UART_CONSOLE_CONFIGURED :  if  ( SYS_CONSOLE_Status ( SYS_CONSOLE_INDEX_0 )  == SYS_STATUS_READY )  { appData  state = APP_STATE_GET_CONSOLE_HANDLE ;  }  break ;  case APP_STATE_GET_CONSOLE_HANDLE :  /* Get handles to both the USB console instances */ appData  consoleHandle =  SYS_CONSOLE_HandleGet ( SYS_CONSOLE_INDEX_0 ) ;  if  ( appData  consoleHandle = SYS_CONSOLE_HANDLE_INVALID )  { appData  state = APP_STATE_READ_FROM_CONSOLE ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  case APP_STATE_READ_FROM_CONSOLE :  SYS_CONSOLE_PRINT ( \" n rFree Space in RX Buffer = %d bytes\"   SYS_CONSOLE_ReadFreeBufferCountGet ( appData  consoleHandle ) ) ;  SYS_CONSOLE_Print ( appData  consoleHandle   \" n rEnter %d characters:\"  UART_CONSOLE_NUM_BYTES_READ ) ; appData  state = APP_STATE_WAIT_READ_COMPLETE ;  break ;  case APP_STATE_WAIT_READ_COMPLETE :  /* Demonstrate SYS_CONSOLE_ReadCountGet() and SYS_CONSOLE_Read() APIs */  if  ( SYS_CONSOLE_ReadCountGet ( appData  consoleHandle )  = UART_CONSOLE_NUM_BYTES_READ )  {  SYS_CONSOLE_PRINT ( \" n rFree Space in RX Buffer = %d bytes\"   SYS_CONSOLE_ReadFreeBufferCountGet ( appData  consoleHandle ) ) ;  /* UART_CONSOLE_NUM_BYTES_READ or more characters are available Read the data in the application buffer */  if  ( SYS_CONSOLE_Read ( appData  consoleHandle  uart_console_read_buffer  UART_CONSOLE_NUM_BYTES_READ )  == UART_CONSOLE_NUM_BYTES_READ )  { appData  state = APP_STATE_WRITE_RECEIVED_DATA ;  }  else  { appData  state = APP_STATE_ERROR ;  }  }  break ;  case APP_STATE_WRITE_RECEIVED_DATA :  /* Demonstrate SYS_CONSOLE_WriteFreeBufferCountGet() and SYS_CONSOLE_Write() APIs */  SYS_CONSOLE_MESSAGE ( \" n rReceived Characters:\" ) ;  SYS_CONSOLE_Write ( appData  consoleHandle  uart_console_read_buffer  UART_CONSOLE_NUM_BYTES_READ ) ; appData  state = APP_STATE_WAIT_WRITE_BUFFER_EMPTY ;  break ;  case APP_STATE_WAIT_WRITE_BUFFER_EMPTY :  if  ( SYS_CONSOLE_WriteCountGet ( appData  consoleHandle )  ==  0 )  {  SYS_CONSOLE_PRINT ( \" n rFree Space in TX Buffer = %d\"   SYS_CONSOLE_WriteFreeBufferCountGet ( appData  consoleHandle ) ) ; appData  state = APP_STATE_ECHO_TEST ;  }  break ;  case APP_STATE_ECHO_TEST :  SYS_CONSOLE_Message ( appData  consoleHandle   \" n r n r***Echo Test*** n rEnter a character and it will be echoed back n r\" ) ; appData  state = APP_STATE_CONSOLE_READ_WRITE ;  break ;  case APP_STATE_CONSOLE_READ_WRITE :  if  ( SYS_CONSOLE_Read ( appData  consoleHandle  uart_console_read_buffer   1 )  =  1 )  {  SYS_CONSOLE_Write ( appData  consoleHandle  uart_console_read_buffer   1 ) ;  }  break ;  case APP_STATE_ERROR :  default :  break ;  }  }  ",
							" Configuring The Library Console System Service Library should be configured via MHC The following figures show the MHC configuration window for Console System Service and brief description Common User Configuration for all Instances sys_console_mhc_config_common Number of Instances Using UART: Specifies the number of console instances using UART Number of Instances Using USB: Specifies the number of console instances using USB CDC Console Print Buffer Size (128-8192): Specifies the Print buffer size for console system service in bytes UART Console The following figure shows the MHC configuration window for configuring the UART Console Device and a brief description of various configuration options The console system service requires the connected UART peripheral library to be configured in the interrupt mode Console System Service Instance configurations with SERCOM UART PLIB sys_console_mhc_config_uart_console SERCOM UART PLIB configurations with Console System Service sys_console_mhc_config_uart_console_sercom Configuration Options Device Used: Indicates the hardware UART Peripheral Library instance used by the Console System Service The underlying USART/SERCOM/FLEXCOM PLIB must be configured in interrupt mode Note: The TX/RX ring buffers must be configured in the attached PLIB as shown above In the above example the TX and RX ring buffer sizes are configured in the attached SERCOM3 PLIB USB Console: The following figure shows the MHC configuration window for configuring the USB Console Device and a brief description of various configuration options Console System Service Instance configurations with USB CDC Driver sys_console_mhc_config_usb_console Configuration Options Device Used: Indicates the USB CDC Instance used by the Console System Service Transmit Buffer Size (1-4096): Size of the transmit ring buffer Receive Buffer Size (1-4096): Size of the receive ring buffer RTOS Settings: Stack Size (in bytes): Specifies the number of bytes to be allocated on the stack for the System Console task of the instance Task Priority: Specifies priority for the System Console task thread The value can vary based on RTOS used Use Task Delay When enabled the System Console task will be scheduled out voluntarily after every run based on the delay configured Task Delay (ms): Indicates the amount of time for which the System Console RTOS thread is put in blocked state by the scheduler before it is run again RTOS Settings For MicriumOS-III RTOS Below additional options are visible in system console instance RTOS settings when the MicriumOS-III is added into project graph rtos_settings_micrium_os_iii Maximum Message Queue Size: This argument specifies the maximum number of messages that the task can receive through internal message queue A MicriumOS-III task contains an optional internal message queue (if OS_CFG_TASK_Q_EN is set to DEF_ENABLED in os_cfg h) The user may specify that the task is unable to receive messages by setting this argument to 0 Task Time Quanta: The amount of time (in clock ticks) for the time quanta when Round Robin is enabled If you specify 0 then the default time quanta will be used which is the tick rate divided by 10 Task Specific Options: Contains task-specific options Each option consists of one bit The option is selected when the bit is set The current version of MicriumOS-III supports the following options: Stack checking is allowed for the task: Specifies whether stack checking is allowed for the task Stack needs to be cleared: Specifies whether the stack needs to be cleared Floating-point registers needs to be saved: Specifies whether floating-point registers are saved This option is only valid if the processor has floating-point hardware and the processor-specific code saves the floating-point registers TLS (Thread Local Storage) support needed for the task: If the caller doesn�t want or need TLS (Thread Local Storage) support for the task being created If you do not include this option TLS will be supported by default TLS support was added in V3 03 00 ",
							" Library Interface Console System Service library provides the following interfaces: Functions Name Description SYS_CONSOLE_Initialize Initializes the console instance module and opens or initializes the specific module instance to which it is associated SYS_CONSOLE_Tasks Maintains the console's state machine SYS_CONSOLE_Status Returns status of the specific instance of the Console module SYS_CONSOLE_HandleGet Returns a handle to the requested console instance SYS_CONSOLE_DeviceGet Returns the device type for a given console instance SYS_CONSOLE_Read Reads data from the console device SYS_CONSOLE_Write Writes data to the console device SYS_CONSOLE_Flush Flushes the read and write queues for the given console instance SYS_CONSOLE_ReadFreeBufferCountGet Returns the amount of free space in bytes available in the receive buffer SYS_CONSOLE_ReadCountGet Returns number of unread bytes available in the receive buffer SYS_CONSOLE_WriteFreeBufferCountGet Returns the amount of free space in bytes in the transmit buffer SYS_CONSOLE_WriteCountGet Returns the number of bytes pending for transmission in the transmit buffer SYS_CONSOLE_Print Formats and prints a message with a variable number of arguments to the console SYS_CONSOLE_Message Prints a message to the console Data types and constants Name Type Description STDXXX_FILENO Macros Standard Input/Output/Error File Number Macros SYS_CONSOLE_DEFAULT_INSTANCE Macro System Console defualt instance SYS_CONSOLE_PRINT Macro Prints formatted message on the default console instance SYS_CONSOLE_MESSAGE Macro Prints message on the default console instance SYS_CONSOLE_STATUS Enum System Console Status SYS_CONSOLE_DEVICE Enum Lists the available console devices SYS_CONSOLE_HANDLE Typedef Handle to an instance of the console system service SYS_CONSOLE_HANDLE_INVALID Macro Invalid console handle ",
							" SYS_CONSOLE_Initialize Function ",
							" C SYS_MODULE_OBJ SYS_CONSOLE_Initialize (  const SYS_MODULE_INDEX index   const SYS_MODULE_INIT *  const init ) ",
							" Summary Initializes the console instance module and opens or initializes the specific module instance to which it is associated ",
							" Description This function initializes the internal data structures used by the console module It also initializes the associated I/O driver/PLIB ",
							" Precondition None ",
							" Parameters Param Description index Index for the instance to be initialized init Pointer to a data structure containing any data necessary to initialize the Console System service This pointer may be null if no data is required because static overrides have been provided ",
							" Returns If successful returns a valid handle to the console instance Otherwise it returns SYS_MODULE_OBJ_INVALID The returned object must be passed as argument to SYS_CONSOLE_Tasks and SYS_CONSOLE_Status routines ",
							" Example SYS_MODULE_OBJ objectHandle ;  // Populate the console initialization structure  const SYS_CONSOLE_INIT sysConsole0Init =  {   deviceInitData =  ( void * )  sysConsole0UARTInitData    consDevDesc =   sysConsoleUARTDevDesc    deviceIndex =  0   } ; objectHandle =  SYS_CONSOLE_Initialize ( SYS_CONSOLE_INDEX_0   ( SYS_MODULE_INIT * )  sysConsole0Init ) ;  if  ( objectHandle == SYS_MODULE_OBJ_INVALID )  {  // Handle error  } ",
							" Remarks This routine should only be called once during system initialization ",
							" SYS_CONSOLE_Tasks Function ",
							" C void SYS_CONSOLE_Tasks ( SYS_MODULE_OBJ object ) ",
							" Summary Maintains the console's state machine ",
							" Description This function runs the console system service's internal state machine ",
							" Precondition The SYS_CONSOLE_Initialize function must have been called for the specified CONSOLE driver instance ",
							" Parameters Param Description object SYS CONSOLE object handle returned from SYS_CONSOLE_Initialize ",
							" Returns None ",
							" Example SYS_MODULE_OBJ object ;  // Returned from SYS_CONSOLE_Initialize  while  ( true )  { SYS_CONSOLE_Tasks ( object ) ;  // Do other tasks  } ",
							" Remarks This function is normally not called directly by an application It is called by the system's Tasks routine (SYS_Tasks) or by the appropriate raw ISR ",
							" SYS_CONSOLE_Status Function ",
							" C SYS_STATUS SYS_CONSOLE_Status ( SYS_MODULE_OBJ object ) ",
							" Summary Returns status of the specific instance of the Console module ",
							" Description This function returns the status of the specific module instance ",
							" Precondition The SYS_CONSOLE_Initialize function should have been called before calling this function ",
							" Parameters Param Description object SYS CONSOLE object handle returned from SYS_CONSOLE_Initialize ",
							" Returns SYS_STATUS_READY - Indicates that the driver is initialized and is ready to accept new requests from the clients SYS_STATUS_BUSY - Indicates that the driver is busy with a previous requests from the clients However depending on the configured queue size for transmit and receive it may be able to queue a new request SYS_STATUS_ERROR - Indicates that the driver is in an error state Any value less than SYS_STATUS_ERROR is also an error state SYS_STATUS_UNINITIALIZED - Indicates that the driver is not initialized ",
							" Example // Given \"object\" returned from SYS_CONSOLE_Initialize SYS_STATUS consStatus ; consStatus = SYS_CONSOLE_Status ( object ) ;  if  ( consStatus == SYS_STATUS_READY )  {  // Console is initialized and is ready to accept client requests  } ",
							" Remarks Application must ensure that the SYS_CONSOLE_Status returns SYS_STATUS_READY before performing console read/write ",
							" SYS_CONSOLE_HandleGet Function ",
							" C SYS_CONSOLE_HANDLE SYS_CONSOLE_HandleGet (  const SYS_MODULE_INDEX index ) ",
							" Summary Returns a handle to the requested console instance ",
							" Description This function returns a handle to the requested console instance ",
							" Preconditions The SYS_CONSOLE_Initialize function should have been called before calling this function ",
							" Parameters Param Description index index of the console instance ",
							" Returns SYS_CONSOLE_HANDLE - Handle to the requested console instance ",
							" Example SYS_CONSOLE_HANDLE myConsoleHandle ; myConsoleHandle =  SYS_CONSOLE_HandleGet ( SYS_CONSOLE_INDEX_0 ) ;  if  ( myConsoleHandle = SYS_CONSOLE_HANDLE_INVALID )  {  // Found a valid handle to the console instance  // Write some data over the USB console  SYS_CONSOLE_Write ( myConsoleHandle  data   10 ) ;  } ",
							" Remarks None ",
							" SYS_CONSOLE_DeviceGet Function ",
							" C SYS_CONSOLE_DEVICE SYS_CONSOLE_DeviceGet (  const SYS_CONSOLE_HANDLE handle ) ",
							" Summary Returns the device type for a given console instance ",
							" Description This function returns the device type supported by the given console instance ",
							" Preconditions The SYS_CONSOLE_Initialize function should have been called before calling this function ",
							" Parameters Param Description handle A valid handle to the console instance ",
							" Returns SYS_CONSOLE_DEVICE - Returns console device type Returns SYS_CONSOLE_DEV_MAX in case of an error ",
							" Example SYS_CONSOLE_HANDLE myConsoleHandle ; SYS_CONSOLE_DEVICE myConsoleDevType // myConsoleHandle is assumed to be a valid console handle myConsoleDevType =  SYS_CONSOLE_DeviceGet ( myConsoleHandle ) ; ",
							" Remarks None ",
							" SYS_CONSOLE_Read Function ",
							" C ssize_t SYS_CONSOLE_Read (  const SYS_CONSOLE_HANDLE handle   void * buf  size_t count ) ",
							" Summary Reads data from the console device ",
							" Description This function reads the data from the console device If the data is not read out from the internal receive buffer by calling the SYS_CONSOLE_Read API at regular intervals there is a possibility of the receive buffer becoming full As a result the new data may be lost Hence the application must call the SYS_CONSOLE_Read API at regular intervals to avoid buffer overflow condition The SYS_CONSOLE_ReadCountGet() and the SYS_CONSOLE_ReadFreeBufferCountGet() APIs may be used to know the number of unread bytes available in the receive buffer and the amount of free space available in the receive buffer respectively ",
							" Preconditions The SYS_CONSOLE_Initialize function should have been called before calling this function ",
							" Parameters Param Description handle Handle to the console instance buf Buffer to hold the read data count Number of bytes to read ",
							" Returns Return value indicates the number of bytes actually read Returns -1 in case of any error ",
							" Example ssize_t nr ;  //indicates the actual number of bytes read  char myBuffer [ MY_BUFFER_SIZE ] ; SYS_CONSOLE_HANDLE myConsoleHandle ;  // myConsoleHandle is assumed to be pointing to a valid console handle nr =  SYS_CONSOLE_Read ( myConsoleHandle  myBuffer  MY_BUFFER_SIZE ) ;  if  ( nr ==  - 1 )  {  // Handle error  } ",
							" Remarks None ",
							" SYS_CONSOLE_Write Function ",
							" C ssize_t SYS_CONSOLE_Write (  const SYS_CONSOLE_HANDLE handle   const  void * buf  size_t count ) ",
							" Summary Writes data to the console device ",
							" Description This function writes data to the console device The function performs a deep-copy of the data passed in buf ",
							" Preconditions The SYS_CONSOLE_Initialize function should have been called before calling this function ",
							" Parameters Param Description handle Handle to the console instance buf Buffer holding the data to be written count Number of bytes to write ",
							" Returns The return value indicates the number of bytes accepted by the function In case the return value is less than the count value the application must try to send the remaining bytes in next attempt(s) Returns -1 in case of any error ",
							" Example ssize_t nr ;  char myBuffer [ ]  =  \"message\" ; SYS_CONSOLE_HANDLE myConsoleHandle ;  // myConsoleHandle is assumed to be a valid console handle nr =  SYS_CONSOLE_Write ( myConsoleHandle  myBuffer   strlen ( myBuffer )  ) ;  if  ( nr ==  - 1 )  {  // Handle error  }  if  ( nr =  strlen ( myBuffer ) )  {  // Try send the remaining data after some time  } ",
							" Remarks Application may check the free space available in the transmit buffer by calling the SYS_CONSOLE_WriteFreeBufferCountGet() API ",
							" SYS_CONSOLE_Flush Function ",
							" C bool SYS_CONSOLE_Flush ( const SYS_CONSOLE_HANDLE handle ) ",
							" Summary Flushes the read and write queues for the given console instance ",
							" Description This function flushes the read and write buffers Any on-going transfers will not be flushed ",
							" Preconditions The SYS_CONSOLE_Initialize function should have been called before calling this function ",
							" Parameters Param Description handle Handle to the console instance ",
							" Returns true - If the operation is successful false - In case of failure ",
							" Example SYS_CONSOLE_HANDLE myConsoleHandle ; bool status ;  // myConsoleHandle is assumed to be a valid console handle status =  SYS_CONSOLE_Flush ( myConsoleHandle ) ;  if  ( status == false )  {  // Handle error  } ",
							" Remarks This API may do nothing and return true where the read and write are not buffered ",
							" SYS_CONSOLE_ReadFreeBufferCountGet Function ",
							" C ssize_t SYS_CONSOLE_ReadFreeBufferCountGet ( const SYS_CONSOLE_HANDLE handle ) ",
							" Summary Returns the amount of free space in bytes available in the receive buffer ",
							" Description This function indicates the number of free space available in the receive buffer thereby indicating the number of bytes that can be received without overflowing the receive buffer ",
							" Preconditions The SYS_CONSOLE_Initialize function should have been called before calling this function ",
							" Parameters Param Description handle Handle to a valid console instance ",
							" Returns The return value indicates the number of bytes of free space available in the receive buffer Returns -1 in case of any error ",
							" Example ssize_t nr ; SYS_CONSOLE_HANDLE myConsoleHandle ;  // myConsoleHandle is assumed to be a valid console handle nr =  SYS_CONSOLE_ReadFreeBufferCountGet ( myConsoleHandle ) ;  if  ( nr ==  - 1 )  {  // Handle error  } ",
							" Remarks None ",
							" SYS_CONSOLE_ReadCountGet Function ",
							" C ssize_t SYS_CONSOLE_ReadCountGet ( const SYS_CONSOLE_HANDLE handle ) ",
							" Summary Returns number of unread bytes available in the receive buffer ",
							" Description This function indicates the number of unread bytes in the receive buffer ",
							" Preconditions The SYS_CONSOLE_Initialize function should have been called before calling this function ",
							" Parameters Param Description handle Handle to the console instance ",
							" Returns The return value indicates the number of bytes of unread data available in the receive buffer Returns -1 in case of any error ",
							" Example ssize_t nUnreadBytes ; ssize_t nBytesRead ;  char myBuffer [ 100 ] ; SYS_CONSOLE_HANDLE myConsoleHandle ;  // Get the number of bytes available in the receive buffer nUnreadBytes =  SYS_CONSOLE_ReadCountGet ( myConsoleHandle ) ;  if  ( nUnreadBytes ==  - 1 )  {  // Handle error  }  // Read the available data into the application buffer  SYS_CONSOLE_Read ( myConsoleHandle   0  myBuffer  nUnreadBytes ) ; ",
							" Remarks None ",
							" SYS_CONSOLE_WriteFreeBufferCountGet Function ",
							" C ssize_t SYS_CONSOLE_WriteFreeBufferCountGet ( const SYS_CONSOLE_HANDLE handle ) ",
							" Summary Returns the amount of free space in bytes in the transmit buffer ",
							" Description This function indicates the number of bytes of free space available in the transmit buffer ",
							" Preconditions The SYS_CONSOLE_Initialize function should have been called before calling this function In some cases application may call this API to know the amount of free buffer space available in the transmit buffer before calling SYS_CONSOLE_Write() API ",
							" Parameters Param Description handle Handle to the console instance ",
							" Returns The return value indicates the number of bytes of free space available in the transmit buffer Returns -1 in case of any error ",
							" Example ssize_t nFreeSpace ;  char myBuffer [ 100 ] ; SYS_CONSOLE_HANDLE myConsoleHandle ;  // Get the number of bytes of free space available in the transmit buffer nFreeSpace =  SYS_CONSOLE_WriteFreeBufferCountGet ( myConsoleHandle ) ;  if  ( ( nFreeSpace =  sizeof ( myBuffer ) )    ( nFreeSpace =  - 1 ) )  {  // Write the application buffer  SYS_CONSOLE_Write ( myConsoleHandle  myBuffer   sizeof ( myBuffer )  ) ;  } ",
							" Remarks None ",
							" SYS_CONSOLE_WriteCountGet Function ",
							" C ssize_t SYS_CONSOLE_WriteCountGet ( const SYS_CONSOLE_HANDLE handle ) ",
							" Summary Returns the number of bytes pending for transmission in the transmit buffer ",
							" Description This function indicates the number of bytes pending for transmission in the transmit buffer ",
							" Preconditions The SYS_CONSOLE_Initialize function should have been called before calling this function ",
							" Parameters Param Description handle Handle to the console instance ",
							" Returns The return value indicates the number of bytes present in the transmit buffer waiting to be transmitted Returns -1 in case of any error ",
							" Example ssize_t nTxBytesPending ; SYS_CONSOLE_HANDLE myConsoleHandle ; nTxBytesPending =  SYS_CONSOLE_WriteCountGet ( myConsoleHandle ) ;  if  ( nTxBytesPending ==  - 1 )  {  // API reported error  }  if  ( nTxBytesPending ==  0 )  {  // All the data has been written to the console  } ",
							" Remarks None ",
							" SYS_CONSOLE_Print Function ",
							" C void  SYS_CONSOLE_Print ( const SYS_CONSOLE_HANDLE handle   const  char  * format      ) ",
							" Summary Formats and prints a message with a variable number of arguments to the console ",
							" Description This function formats and prints a message with a variable number of arguments to the console ",
							" Precondition SYS_CONSOLE_Initialize must have returned a valid object handle ",
							" Parameters Param Description handle Handle to a console instance format Pointer to a buffer containing the format string for the message to be displayed  Zero or more optional parameters to be formated as defined by the format string ",
							" Returns None ",
							" Example SYS_CONSOLE_HANDLE myConsoleHandle ; myConsoleHandle =  SYS_CONSOLE_HandleGet ( SYS_CONSOLE_INDEX_0 ) ; uint8_t num_bytes_to_enter =  10 ;  if  ( myConsoleHandle = SYS_CONSOLE_HANDLE_INVALID )  {  // Found a valid handle to the console instance  SYS_CONSOLE_Print ( myConsoleHandle   \"Enter %d characters\"  num_bytes_to_enter ) ;  } ",
							" Remarks The format string and arguments follow the printf convention Call SYS_CONSOLE_PRINT macro to print on the default console instance 0 ",
							" SYS_CONSOLE_Message Function ",
							" C void  SYS_CONSOLE_Message ( const SYS_CONSOLE_HANDLE handle   const  char  * message ) ",
							" Summary Prints a message to the console ",
							" Description This function prints a message to the console ",
							" Precondition SYS_CONSOLE_Initialize must have returned a valid object handle ",
							" Parameters Param Description handle Handle to a console instance message Pointer to a message string to be displayed ",
							" Returns None ",
							" Example SYS_CONSOLE_HANDLE myConsoleHandle ; myConsoleHandle =  SYS_CONSOLE_HandleGet ( SYS_CONSOLE_INDEX_0 ) ;  if  ( myConsoleHandle = SYS_CONSOLE_HANDLE_INVALID )  {  SYS_CONSOLE_Message ( myConsoleHandle   \"Printing using SYS_Message\" ) ;  } ",
							" Remarks Call SYS_CONSOLE_MESSAGE macro to print on the default console instance 0 ",
							" STDXXX_FILENO Numbers ",
							" C # define STDIN_FILENO 0  # define STDOUT_FILENO 1  # define STDERR_FILENO 2 ",
							" Summary Standard Input/Output/Error File Number Macros ",
							" Description These macros provide the Standard Input Output and Error File numbers aligned to unistd h ",
							" Remarks None ",
							" SYS_CONSOLE_DEFAULT_INSTANCE Macro ",
							" C # define SYS_CONSOLE_DEFAULT_INSTANCE 0  ",
							" Summary System Console defualt instance ",
							" Description This macro provides the default instance to be used by SYS_CONSOLE_PRINT and SYS_CONSOLE_MESSAGE to print the messages ",
							" Remarks None ",
							" SYS_CONSOLE_MESSAGE Macro ",
							" C # define SYS_CONSOLE_MESSAGE(message) SYS_CONSOLE_Message(SYS_CONSOLE_DEFAULT_INSTANCE message)  ",
							" Summary Prints message on the default console instance ",
							" Description This macro calls SYS_Console_Message() to print message on the default console instance set by SYS_CONSOLE_DEFAULT_INSTANCE ",
							" Remarks None ",
							" SYS_CONSOLE_PRINT Macro ",
							" C # define SYS_CONSOLE_PRINT(fmt ) SYS_CONSOLE_Print(SYS_CONSOLE_DEFAULT_INSTANCE fmt ##__VA_ARGS__)  ",
							" Summary Prints formatted message on the default console instance ",
							" Description This macro calls SYS_Console_Print() to print formatted message on the default console instance set by SYS_CONSOLE_DEFAULT_INSTANCE ",
							" Remarks None ",
							" SYS_CONSOLE_STATUS Enum ",
							" C typedef  enum  { SYS_CONSOLE_STATUS_NOT_CONFIGURED  SYS_CONSOLE_STATUS_CONFIGURED  SYS_CONSOLE_STATUS_BUSY  SYS_CONSOLE_STATUS_ERROR } SYS_CONSOLE_STATUS ;  ",
							" Summary System Console Status ",
							" Description This enumeration lists the current status/state of a system console module ",
							" Remarks None ",
							" SYS_CONSOLE_DEVICE Enum ",
							" C typedef  enum  { SYS_CONSOLE_DEV_USART  SYS_CONSOLE_DEV_USB_CDC  SYS_CONSOLE_DEV_MAX   } SYS_CONSOLE_DEVICE ;  ",
							" Summary Lists the available console devices ",
							" Description This enumeration lists all of the available console devices A console device is a physical peripheral used by the console service to send and receive data ",
							" Remarks None ",
							" SYS_CONSOLE_HANDLE Typedef ",
							" C typedef uintptr_t SYS_CONSOLE_HANDLE ;  ",
							" Summary Handle to an instance of the console system service ",
							" Description This data type is a handle to a specific instance of the console system service ",
							" Remarks Code outside of a specific module should consider this as an opaque type (much like a void *) Do not make any assumptions about base type as it may change in the future or about the value stored in a variable of this type ",
							" SYS_CONSOLE_HANDLE_INVALID Macro ",
							" C # define SYS_CONSOLE_HANDLE_INVALID ((SYS_CONSOLE_HANDLE) -1 )  ",
							" Summary Invalid console handle ",
							" Description This is handle value is returned in case of an unsuccessful console operation ",
							" Remarks Do not rely on the actual value of this constant It may change in future implementations ",
							" Debug System Service The Debug System Service provides a set of functions that allow the developer to output debug and/or error messages based on a global error level The messages are sent to the System Console Service where they are routed to a console device The Debug System Service maintains a global error level which may be set during initialization and changed dynamically at run-time Both formatted and unformatted messages can be output or not depending on the current global error level ",
							" How the Library Works The Debug System Service provides APIs for the application developer to send formatted or unformatted messages to a system console Abstraction Model sys_debug_abstraction_model The console core layer_provides a POSIX-like read/write API to applications and middleware libraries to send and receive data to and from the console device Data and message buffering along with the details of the data transfer are contained within the console device and peripheral library (PLIB) layers Working Flow Debug Messages and Error Reporting The following macros are available to output debug and error messages The default implementation of these macros resolves to nothing by the preprocessor This is to allow the developer to leave debug messaging in the released code without impacting code size or performance Typically the developer would define SYS_DEBUG_USE_CONSOLE macro through MHC configuration for debug builds to map these macros to appropriate debug service implementation SYS_DEBUG_MESSAGE(level message) prints a debug message to the console device if the global error level is equal to or lower than that specified by the \"level\" argument SYS_DEBUG_PRINT(level fmt ) prints formatted messages to the console if the global error level is equal to or lower than that specified by the \"level\" argument The message formatting is the same as printf Changing the System Error Level Two functions are provided to manipulate the global system error level at runtime This may be useful when you want to increase the debug verbosity for a particular section of code but not for the entire program SYS_DEBUG_ErrorLevelGet() returns the current global system error level SYS_DEBUG_ErrorLevelSet(level) sets the current global system error level ",
							" Using The Library When the Debug System Service is initialized it sets the global system error level to the specified level This level determines the threshold at which debug and error messages are sent to the console This allows different debug and error reporting verbosity depending on the needs of the developer The Debug System Service also provides APIs to dynamically set the error level during program execution This allows the developer to increase or decrease debug verbosity to specific areas of interest within the program Example Application to Send different messages on UART Console SYS_DEBUG_MESSAGE ( SYS_ERROR_INFO   \"***This is Info message on UART console*** n r\" ) ;  SYS_DEBUG_MESSAGE ( SYS_ERROR_DEBUG   \"***This is Debug message on UART console*** n r\" ) ;  SYS_DEBUG_PRINT ( SYS_ERROR_INFO   \"***This is %s on UART console*** n r\"   \"Info Print\" ) ;  SYS_DEBUG_PRINT ( SYS_ERROR_ERROR   \"***This is %s on UART console*** n r\"   \"Error Print\" ) ;  /* Change the error level to only print the debug messages with error value set to SYS_ERROR_ERROR or lower */  SYS_DEBUG_ErrorLevelSet ( SYS_ERROR_ERROR ) ;  /* The below message should not get printed as \"SYS_ERROR_DEBUG\" is higher than \"SYS_ERROR_ERROR\" */  SYS_DEBUG_MESSAGE ( SYS_ERROR_DEBUG   \" n rThis message should not be printed \" ) ;  /* Set the error level back to SYS_ERROR_DEBUG */  SYS_DEBUG_ErrorLevelSet ( SYS_ERROR_DEBUG ) ;  ",
							" Configuring The Library Debug System Service Library should be configured via MHC The following figures show the MHC configuration window for Debug System Service and brief description The Debug System uses the services provided by the Console System Service which in turn depends on the UART peripheral library or USB CDC device Debug System Service connected to UART based Console sys_debug_mhc_config_uart_console Debug System Service connected to USB based Console sys_debug_mhc_config_usb_console Configuration Options Device Used: Indicates the console instance that the Debug System Service will use Debug Level: Indicates the global error level set during initialization Application can change the global error level during runtime using an API Use Console for Debug : Check this option to map the debug macros to debug implementation Un-checking this option maps the debug macros to nothing ",
							" Library Interface Debug System Service library provides the following interfaces: Functions Name Description SYS_DEBUG_Initialize Initializes the global error level and specific module instance SYS_DEBUG_Status Returns status of the specific instance of the debug service module SYS_DEBUG_ErrorLevelSet Sets the global system error reporting level SYS_DEBUG_ErrorLevelGet Returns the global system Error reporting level SYS_DEBUG_Redirect Allows re-direction of debug system service to another console instance SYS_DEBUG_ConsoleInstanceGet Returns console instance used by debug system service Data types and constants Name Type Description SYS_ERROR_LEVEL Enum System error message priority levels SYS_DEBUG_INDEX_0 Macro Debug System Service index SYS_DEBUG_MESSAGE Macro Prints a debug message if the system error level is defined at or lower than the level specified SYS_DEBUG_PRINT Macro Formats and prints an error message if the system error level is defined at or lower than the level specified SYS_DEBUG_BreakPoint Macro Inserts a software breakpoint instruction when building in Debug mode ",
							" SYS_DEBUG_Initialize Function ",
							" C SYS_MODULE_OBJ SYS_DEBUG_Initialize (  const SYS_MODULE_INDEX index   const SYS_MODULE_INIT *  const init ) ",
							" Summary Initializes the global error level and specific module instance ",
							" Description This function initializes the global error level It also initializes any internal system debug module data structures ",
							" Precondition None ",
							" Parameters Param Description index Index for the instance to be initialized init Pointer to a data structure containing any data necessary to initialize the debug service This pointer may be null if no data is required because static overrides have been provided ",
							" Returns If successful returns SYS_MODULE_OBJ_STATIC Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example SYS_MODULE_OBJ objectHandle ; SYS_DEBUG_INIT debugInit =  {   moduleInit =  { 0 }    errorLevel = SYS_DEBUG_GLOBAL_ERROR_LEVEL    consoleIndex =  0   } ; objectHandle =  SYS_DEBUG_Initialize ( SYS_DEBUG_INDEX_0   ( SYS_MODULE_INIT * )  debugInit ) ;  if  ( objectHandle == SYS_MODULE_OBJ_INVALID )  {  // Handle error  } ",
							" Remarks This routine should only be called once during system initialization ",
							" SYS_DEBUG_Status Function ",
							" C SYS_STATUS SYS_DEBUG_Status ( SYS_MODULE_OBJ object ) ",
							" Summary Returns status of the specific instance of the debug service module ",
							" Description This function returns the status of the specific debug service module instance ",
							" Precondition The SYS_DEBUG_Initialize function should have been called before calling this function ",
							" Parameters Param Description object Debug module object handle returned from SYS_DEBUG_Initialize ",
							" Returns SYS_STATUS_READY - Indicates that the module is running and ready to service requests Any value greater than SYS_STATUS_READY is also a normal running state in which the module is ready to accept new operations SYS_STATUS_BUSY - Indicates that the module is busy with a previous system level operation SYS_STATUS_ERROR - Indicates that the module is in an error state Any value less than SYS_STATUS_ERROR is also an error state SYS_STATUS_UNINITIALIZED - Indicates that the module has not been initialized ",
							" Example SYS_MODULE_OBJ object ;  // Returned from SYS_CONSOLE_Initialize SYS_STATUS debugStatus ; debugStatus = SYS_DEBUG_Status ( object ) ;  if  ( debugStatus == SYS_STATUS_READY )  {  // Debug service is initialized and ready to accept requests  } ",
							" Remarks None ",
							" SYS_DEBUG_ErrorLevelSet Function ",
							" C void  SYS_DEBUG_ErrorLevelSet ( SYS_ERROR_LEVEL level ) ",
							" Summary Sets the global system error reporting level ",
							" Description This function sets the global system error reporting level ",
							" Precondition SYS_DEBUG_Initialize must have returned a valid object handle ",
							" Parameters Param Description level The desired system error level ",
							" Returns None ",
							" Example SYS_DEBUG_ErrorLevelSet ( SYS_ERROR_WARNING ) ; ",
							" Remarks None ",
							" SYS_DEBUG_ErrorLevelGet Function ",
							" C SYS_ERROR_LEVEL SYS_DEBUG_ErrorLevelGet ( void ) ",
							" Summary Returns the global system Error reporting level ",
							" Description This function returns the global System Error reporting level ",
							" Precondition SYS_DEBUG_Initialize must have returned a valid object handle ",
							" Parameters None ",
							" Returns The global System Error Level ",
							" Example SYS_ERROR_LEVEL level ; level =  SYS_DEBUG_ErrorLevelGet ( ) ; ",
							" Remarks None ",
							" SYS_DEBUG_Redirect Function ",
							" C bool SYS_DEBUG_Redirect ( const SYS_MODULE_INDEX index ) ",
							" Summary Allows re-direction of debug system service to another console instance ",
							" Description This function re-directs calls to the Debug Service APIs to a different console instance ",
							" Precondition None ",
							" Parameters Param Description index The index of the console to re-direct the debug system service calls to ",
							" Returns True - If operation is successful False - In case of failure ",
							" Example // Re-direct debug system service calls to console index 1  if  ( SYS_DEBUG_Redirect ( SYS_CONSOLE_INDEX_1 )  == true )  {  // SYS Debug output will now be re-directed to SYS Console Instance - 1  } ",
							" Remarks None ",
							" SYS_DEBUG_ConsoleInstanceGet Function ",
							" C SYS_MODULE_INDEX SYS_DEBUG_ConsoleInstanceGet ( void ) ",
							" Summary Returns console instance used by debug system service ",
							" Description This function returns console instance used by debug system service ",
							" Precondition None ",
							" Parameters None ",
							" Returns SYS_MODULE_INDEX - Instance of console system service ",
							" Example uint32_t index ; index =  SYS_DEBUG_ConsoleInstanceGet ( ) ;  ",
							" Remarks None ",
							" SYS_ERROR_LEVEL Enum ",
							" C typedef  enum  {  /* Errors that have the potential to cause a system crash */ SYS_ERROR_FATAL =  0   /* Errors that have the potential to cause incorrect behavior */ SYS_ERROR_ERROR =  1   /* Warnings about potentially unexpected behavior or side effects */ SYS_ERROR_WARNING =  2   /* Information helpful to understanding potential errors and warnings */ SYS_ERROR_INFO =  3   /* Verbose information helpful during debugging and testing */ SYS_ERROR_DEBUG =  4  } SYS_ERROR_LEVEL ;  ",
							" Summary System error message priority levels ",
							" Description This enumeration defines the supported system error message priority values ",
							" Remarks Used by debug message macros to compare individual message priority against a global system-wide error message priority level to determine if an individual message should be displayed ",
							" SYS_DEBUG_INDEX_0 Macro ",
							" C # define SYS_DEBUG_INDEX_0 0  ",
							" Summary Debug System Service index ",
							" Description This constant defines a symbolic name for the debug system service index ",
							" Remarks There can only be a single debug system service instance in the system ",
							" SYS_DEBUG_MESSAGE Macro ",
							" C # define SYS_DEBUG_MESSAGE(level message)  SYS_DEBUG_MESSAGE(SYS_ERROR_LEVEL level const char* message ) ",
							" Summary Prints a debug message if the system error level is defined at or lower than the level specified ",
							" Description This function prints a debug message if the system error level is defined at or lower than the level specified If mapped to the SYS_DEBUG_Message function then the system debug service must be initialized and running ",
							" Precondition If mapped to the SYS_DEBUG_Message function then the system debug service must be initialized and running ",
							" Parameters Param Description level The current error level threshold for displaying the message message Pointer to a buffer containing the message to be displayed ",
							" Returns None ",
							" Example // In configuration h file: #define SYS_DEBUG_USE_CONSOLE  // In sys_debug h file: #define SYS_DEBUG_MESSAGE(level message) _SYS_DEBUG_MESSAGE(level message)  SYS_DEBUG_ErrorLevelSet ( SYS_ERROR_DEBUG ) ;  SYS_DEBUG_MESSAGE ( SYS_ERROR_WARNING   \"System Debug Message r n\" ) ;  ",
							" Remarks By default this macro is defined as nothing effectively removing all code generated by calls to it To process SYS_DEBUG_MESSAGE calls this macro must be defined in a way that maps calls to it to the desired implementation (see example above) This macro can be mapped to the system console service (along with other system debug macros) by defining SYS_DEBUG_USE_CONSOLE in the system configuration (configuration h) instead of defining it individually ",
							" SYS_DEBUG_PRINT Macro ",
							" C # define SYS_DEBUG_PRINT(level fmt )  ",
							" Summary Formats and prints an error message if the system error level is defined at or lower than the level specified ",
							" Description This macro formats and prints an error message if the system error level is defined at or lower than the level specified ",
							" Precondition If mapped to the SYS_DEBUG_Print function then the system debug service must be initialized and running ",
							" Parameters Param Description level The current error level threshold for displaying the message format Pointer to a buffer containing the format string for the message to be displayed  Zero or more optional parameters to be formated as defined by the format string ",
							" Returns None ",
							" Example // In configuration h file: #define SYS_DEBUG_USE_CONSOLE 1  // In sys_debug h: #define SYS_DEBUG_PRINT(level fmt ) _SYS_DEBUG_PRINT(level fmt ##__VA_ARGS__)  // In source code  int result ; result =  SomeOperation ( ) ;  if  ( result  MAX_VALUE )  {  SYS_DEBUG_PRINT ( SYS_ERROR_WARNING   \"Result of %d exceeds max value r n\"  result ) ;  // Take appropriate action  } ",
							" Remarks The format string and arguments follow the printf convention By default this macro is defined as nothing effectively removing all code generated by calls to it To process SYS_DEBUG_PRINT calls this macro must be defined in a way that maps calls to it to the desired implementation (see example above) This macro can be mapped to the system console service (along with other system debug macros) by defining SYS_DEBUG_USE_CONSOLE in the system configuration (configuration h) instead of defining it individually ",
							" SYS_DEBUG_BreakPoint Macro ",
							" C # if defined(__DEBUG)  // For PIC32M based Devices  # define SYS_DEBUG_BreakPoint() __asm__ volatile (\" sdbbp 0\")  // For ARM based Devices  # define SYS_DEBUG_BreakPoint() __asm__ __volatile__ (\"bkpt #0\");  # else  # define SYS_DEBUG_BreakPoint()  # endif  ",
							" Summary Inserts a software breakpoint instruction when building in Debug mode ",
							" Description This macro inserts a software breakpoint instruction when building in Debug mode ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example if  ( myDebugTestFailed )  {  SYS_DEBUG_BreakPoint ( ) ;  } ",
							" Remarks Compiles out if not built for debugging ",
							" Direct Memory Access (DMA) System Service The Direct Memory Access (DMA) controller is a bus master module that is useful for data transfers between different peripherals without intervention from the CPU The source and destination of a DMA transfer can be any of the memory-mapped modules For example memory or one of the Peripheral Bus (PBUS) devices such as the SPI UART and so on Library Interface DMA System Service provides the following interfaces: Functions Name Description SYS_DMA_ChannelCallbackRegister This function allows a DMA client to set an event handler SYS_DMA_ChannelTransfer Adds a data transfer to a DMA channel and enables the channel to start data transfer SYS_DMA_ChannelIsBusy Returns the busy status of a specific DMA Channel SYS_DMA_ChannelDisable Disables the specified channel SYS_DMA_AddressingModeSetup Setup addressing mode of selected DMA channel SYS_DMA_DataWidthSetup Setup data width of selected DMA channel Data types and constants Name Type Description SYS_DMA_CHANNEL Enum This lists the set of channels available for data transfer using DMA SYS_DMA_TRANSFER_EVENT Enum Enumeration of possible DMA transfer events SYS_DMA_SOURCE_ADDRESSING_MODE Enum Enumeration of possible DMA source addressing modes SYS_DMA_DESTINATION_ADDRESSING_MODE Enum Enumeration of possible DMA destination addressing modes SYS_DMA_WIDTH Enum Enumeration of possible DMA data width SYS_DMA_CHANNEL_CALLBACK Typedef Pointer to a DMA Transfer Event handler function ",
							" SYS_DMA_ChannelCallbackRegister Function ",
							" C void SYS_DMA_ChannelCallbackRegister ( SYS_DMA_CHANNEL channel   const SYS_DMA_CHANNEL_CALLBACK eventHandler   const uintptr_t contextHandle ) ",
							" Summary This function allows a DMA client to set an event handler ",
							" Description This function allows a client to set an event handler The client may want to receive transfer related events in cases when it submits a DMA transfer request The event handler should be set before the client intends to perform operations that could generate events This function accepts a contextHandle parameter This parameter could be set by the client to contain (or point to) any client specific data object that should be associated with this DMA channel ",
							" Precondition DMA Controller should have been initialized ",
							" Parameters Param Description channel A specific DMA channel from which the events are expected eventHandler Pointer to the event handler function contextHandle Value identifying the context of the application/driver/middleware that registered the event handling function ",
							" Returns None ",
							" Example MY_APP_OBJ myAppObj ;  void  APP_DMA_TransferEventHandler ( SYS_DMA_TRANSFER_EVENT event  uintptr_t contextHandle )  {  switch ( event )  {  case SYS_DMA_TRANSFER_COMPLETE :  // This means the data was transferred  break ;  case SYS_DMA_TRANSFER_ERROR :  // Error handling here  break ;  default :  break ;  }  }  // User registers an event handler with DMA channel This is done once  SYS_DMA_ChannelCallbackRegister ( channel  APP_DMA_TransferEventHandler  ( uintptr_t )  myAppObj ) ; ",
							" Remarks None ",
							" SYS_DMA_ChannelTransfer Function ",
							" C bool SYS_DMA_ChannelTransfer ( SYS_DMA_CHANNEL channel   const  void  * srcAddr   const  void  * destAddr  size_t blockSize ) ",
							" Summary Adds a data transfer to a DMA channel and enables the channel to start data transfer ",
							" Description This function adds a single block data transfer characteristics for a specific DMA channel id it is not busy already It also enables the channel to start data transfer If the requesting client registered an event callback with the PLIB the PLIB will issue a SYS_DMA_TRANSFER_COMPLETE event if the transfer was processed successfully and SYS_DMA_TRANSFER_ERROR event if the transfer was not processed successfully ",
							" Precondition DMA Controller should have been initialized ",
							" Parameters Param Description channel A specific DMA channel srcAddr Source of the DMA transfer destAddr Destination of the DMA transfer blockSize Size of the transfer block ",
							" Returns - True - If transfer request is accepted - False - If previous transfer is in progress and the request is rejected ",
							" Example // Transfer 10 bytes of data to UART TX using DMA channel 1  // DMA Channel has been configured and initialized by appropriate PLIB call MY_APP_OBJ myAppObj ; uint8_t buf [ 10 ]  =  { 0  1  2  3  4  5  6  7  8  9 } ;  void  * srcAddr =  ( uint8_t * ) buf ;  void  * destAddr =  ( uin8_t * )   U1TXREG ; size_t size =  10 ;  // User registers an event handler with PLIB This is done once  SYS_DMA_ChannelCallbackRegister ( APP_DMA_TransferEventHandler  ( uintptr_t )  myAppObj ) ;  if  ( SYS_DMA_ChannelTransfer ( SYS_DMA_CHANNEL_1  srcAddr  destAddr  size )  == true )  {  // do something else  }  else  {  // try again  } ",
							" Remarks When DMA transfer buffers are placed in cacheable memory cache maintenance operation must be performed by cleaning and invalidating cache for DMA buffers located in cacheable SRAM region using CMSIS APIs The buffer start address must be aligned to cache line and buffer size must be multiple of cache line Refer to device documentation to find the cache line size Invalidate cache lines having received buffer before using it to load the latest data in the actual memory to the cache SCB_InvalidateDCache_by_Addr((uint32_t *) readBuffer sizeof(readBuffer)); Clean cache lines having source buffer before submitting a transfer request to DMA to load the latest data in the cache to the actual memory SCB_CleanDCache_by_Addr((uint32_t *) writeBuffer sizeof(writeBuffer)); ",
							" SYS_DMA_ChannelIsBusy Function ",
							" C bool SYS_DMA_ChannelIsBusy ( SYS_DMA_CHANNEL channel ) ",
							" Summary Returns the busy status of a specific DMA Channel ",
							" Description This function returns the busy status of the DMA channel DMA channel will be busy if any transfer is in progress This function can be used to check the status of the channel prior to submitting a transfer request And this can also be used to check the status of the submitted request if callback mechanism is not preferred ",
							" Precondition DMA Controller should have been initialized ",
							" Parameters Param Description channel A specific DMA channel ",
							" Returns Busy status of the specific channel - True - Channel is busy - False - Channel is free ",
							" Example // Transfer 10 bytes of data to UART TX using DMA channel 1  // DMA Channel has been configured and initialized by appropriate PLIB call uint8_t buf [ 10 ]  =  { 0  1  2  3  4  5  6  7  8  9 } ;  void  * srcAddr =  ( uint8_t * ) buf ;  void  * destAddr =  ( uin8_t * )   U1TXREG ; size_t size =  10 ;  if ( false ==  SYS_DMA_ChannelIsBusy ( SYS_DMA_CHANNEL_1 ) )  {  SYS_DMA_ChannelTransfer ( SYS_DMA_CHANNEL_1  srcAddr  destAddr  size ) ;  } ",
							" Remarks None ",
							" SYS_DMA_ChannelDisable Function ",
							" C void SYS_DMA_ChannelDisable ( SYS_DMA_CHANNEL channel ) ",
							" Summary Disables the specified channel ",
							" Description This function disables the specified channel and resets it Ongoing transfer will be aborted ",
							" Precondition DMA Controller should have been initialized by appropriate PLIB initialize function ",
							" Parameters Param Description channel A specific DMA channel ",
							" Returns None ",
							" Example SYS_DMA_ChannelDisable ( SYS_DMA_CHANNEL_1 ) ; ",
							" Remarks None ",
							" SYS_DMA_AddressingModeSetup Function ",
							" C void  SYS_DMA_AddressingModeSetup ( SYS_DMA_CHANNEL channel  SYS_DMA_SOURCE_ADDRESSING_MODE sourceAddrMode  SYS_DMA_DESTINATION_ADDRESSING_MODE destAddrMode ) ; ",
							" Summary Setup addressing mode of selected DMA channel ",
							" Description This function sets the addressing mode of selected DMA channel Any ongoing transaction of the specified DMA channel will be aborted when this function is called ",
							" Precondition DMA Controller should have been initialized ",
							" Parameters Param Description channel A specific DMA channel sourceAddrMode Source addressing mode of type SYS_DMA_SOURCE_ADDRESSING_MODE destAddrMode Destination addressing mode of type SYS_DMA_DESTINATION_ADDRESSING_MODE ",
							" Returns None ",
							" Example SYS_DMA_AddressingModeSetup ( SYS_DMA_CHANNEL_1  SYS_DMA_SOURCE_ADDRESSING_MODE_FIXED  SYS_DMA_DESTINATION_ADDRESSING_MODE_FIXED ) ; ",
							" Remarks None ",
							" SYS_DMA_DataWidthSetup Function ",
							" C void  SYS_DMA_DataWidthSetup ( SYS_DMA_CHANNEL channel  SYS_DMA_WIDTH dataWidth ) ; ",
							" Summary Setup data width of selected DMA channel ",
							" Description This function sets data width of selected DMA channel Any ongoing transaction of the specified DMA channel will be aborted when this function is called ",
							" Precondition DMA Controller should have been initialized ",
							" Parameters Param Description channel A specific DMA channel dataWidth Data width of DMA transfer of type SYS_DMA_WIDTH ",
							" Returns None ",
							" Example SYS_DMA_DataWidthSetup ( SYS_DMA_CHANNEL_1  SYS_DMA_WIDTH_16_BIT ) ; ",
							" Remarks None ",
							" SYS_DMA_CHANNEL Enum ",
							" C The DMA Channels vary based on device family Refer to the generated header file for the actual values ",
							" Summary This lists the set of channels available for data transfer using DMA ",
							" Description Lists the channels available for data transfer using DMA The number of channels may vary based on the device ",
							" Remarks None ",
							" SYS_DMA_TRANSFER_EVENT Enum ",
							" C typedef  enum  {  /* Data was transferred successfully */ SYS_DMA_TRANSFER_COMPLETE   /* Error while processing the request */ SYS_DMA_TRANSFER_ERROR } SYS_DMA_TRANSFER_EVENT ;  ",
							" Summary Enumeration of possible DMA transfer events ",
							" Description This data type provides an enumeration of all possible DMA transfer events ",
							" Remarks None ",
							" SYS_DMA_SOURCE_ADDRESSING_MODE Enum ",
							" C typedef  enum  {  /* Source address is always fixed */ SYS_DMA_SOURCE_ADDRESSING_MODE_FIXED   /* Source address is incremented after every transfer */ SYS_DMA_SOURCE_ADDRESSING_MODE_INCREMENTED   /* Used when Addressing mode is not supported */ SYS_DMA_SOURCE_ADDRESSING_MODE_NONE =  - 1  } SYS_DMA_SOURCE_ADDRESSING_MODE ;  ",
							" Summary Enumeration of possible DMA source addressing modes ",
							" Description This data type provides an enumeration of all possible DMA source addressing modes ",
							" Remarks Some of the enum elements may not be applicable for particular device check MCC generated code before using them ",
							" SYS_DMA_DESTINATION_ADDRESSING_MODE Enum ",
							" C typedef  enum  {  /* Destination address is always fixed */ SYS_DMA_DESTINATION_ADDRESSING_MODE_FIXED   /* Destination address is incremented after every transfer */ SYS_DMA_DESTINATION_ADDRESSING_MODE_INCREMENTED   /* Used when Addressing mode is not supported */ SYS_DMA_DESTINATION_ADDRESSING_MODE_NONE =  - 1  } SYS_DMA_DESTINATION_ADDRESSING_MODE ;  ",
							" Summary Enumeration of possible DMA destination addressing modes ",
							" Description This data type provides an enumeration of all possible DMA destination addressing modes ",
							" Remarks Some of the enum elements may not be applicable for particular device check MCC generated code before using them ",
							" SYS_DMA_WIDTH Enum ",
							" C typedef  enum  {  /* DMA data width 8 bit */ SYS_DMA_WIDTH_8_BIT   /* DMA data width 16 bit */ SYS_DMA_WIDTH_16_BIT   /* DMA data width 32 bit */ SYS_DMA_WIDTH_32_BIT   /* USed when DMA Width is not supported */ SYS_DMA_WIDTH_NONE =  - 1  } SYS_DMA_WIDTH ;  ",
							" Summary Enumeration of possible DMA data width ",
							" Description This data type provides an enumeration of all possible DMA data width ",
							" Remarks Some of the enum elements may not be applicable for particular device check MCC generated code before using them ",
							" SYS_DMA_CHANNEL_CALLBACK Typedef ",
							" C typedef  void  ( * SYS_DMA_CHANNEL_CALLBACK )  ( SYS_DMA_TRANSFER_EVENT event  uintptr_t contextHandle ) ;  ",
							" Summary Pointer to a DMA Transfer Event handler function ",
							" Description This data type defines a DMA Transfer Event Handler Function A DMA client must register a transfer event handler function of this type to receive transfer related events from the DMA System Service If the event is SYS_DMA_TRANSFER_COMPLETE this means that the data was transferred successfully If the event is SYS_DMA_TRANSFER_ERROR this means that the data was not transferred successfully The contextHandle parameter contains the context handle that was provided by the client at the time of registering the event handler This context handle can be anything that the client consider helpful or necessary to identify the client context object associated with the channel of the DMA that generated the event The event handler function executes in an interrupt context of DMA It is recommended to the application not to perform process intensive operations with in this function ",
							" Remarks None ",
							" File System Service The MPLAB Harmony File System Service (SYS_FS) provides an application programming interface (API) through which a utility or user program requests services of a file system Some file system APIs may also include interfaces for maintenance operations such as creating or initializing a file system and verifying the file system for integrity The File System service is really a framework designed to support multiple file systems (native file system) and multiple media in the same application Examples of native file systems are FAT12 FAT16 FAT32 exFAT the Microchip File System (MPFS) and littleFS MPFS is a read-only file system which is used to store the files that do not change for example Web pages images etc Each of these native file systems have a common set of APIs that can be used to access the files of that particular native file system File system features include the following: Support for multiple file system (FAT MPFS littleFS) Supports multiple physical media (NVM SPI/QSPI FLASH SPI/I2C EEPROM SD card eMMC USB Host MSD RAM) More physical media can be interfaced with the FS once the driver is available for the media Modular and Layered architecture ",
							" How the Library Works The MPLAB Harmony File System Service (SYS_FS) provides embedded application developers with a file system framework for retrieving and storing data from various media The File System Service abstracts the native file system calls and provides a common interface to the user/application layer For example while the application layer requests for a file read or write from a disk due to the presence of the this abstraction the application need not be bothered about the native file system implemented on that disk Instead the application can call the read/write API of the File System service which in turn translates to the read/write command of the native file system used on the required disk This simplifies the implementation of the higher application layer and also provides a mechanism to add more native file system to the File System framework in the future Abstraction Model The File System framework features a modular and layered architecture as shown in the following figure sys_fs_abstraction_model The Media Block Driver for the physical media has to be included as a part of the FS Framework This layer provides a mechanism to access the media as \"sectors\" Sectors are the smallest storage element accessed by a file system and are contiguous memory locations Typically each sector has 512 bytes It can directly provide low-level interface to access the physical media or an interface to access the intermediate media device drivers This layer also enables multiple instances of media It depends on below drivers for accessing the media Memory Driver if media is NVM SPI/QSPI Flash SPI/I2C EEPROM RAM SDMMC or SDSPI Driver if media is a SD Card or eMMC USB Host MSD driver if media is a USB thumb drive The Media manager implements a disk and sector based media access mechanism It also performs disk allocate/deallocate on media attach/detach events Due to the implementation of this layer the FS Framework can support multiple disks The media manager detects and analyzes a media based on its Master Boot Record (MBR) Therefore it is mandatory for the media to have a MBR for it to work with the FS The Native file system implements support for the media file system format Below are the examples of native file systems currently supported However more native file systems can be included FAT12 FAT16 FAT32 and exFAT MPFS littleFS The Virtual file system (or SYS_FS ) layer provides a file system independent file system operation interface This layer translates virtual file systems calls to native file system calls Due to this layer applications can now support multiple file systems Commonly used interfaces provided by this layer but not limited to include: SYS_FS_mount SYS_FS_unmount SYS_FS_open SYS_FS_read SYS_FS_write SYS_FS_close ",
							" Using The Library The File System Service (SYS_FS) provides an application programming interface (API) through which a utility or user program requests services of a file system Refer to the Library Interface section or the generated sys_fs h file for all the supported API's Application Flow The application must first mount the media drive for the FS Framework to access the media Unless the mounting process returns successfully the application should continue trying to mount the drive If the drive is not attached the mounting process will fail In such a situation the application should not proceed further unless the mounting is success Mounting a Formatted Drive sys_fs_mount_formatted Mounting a Un-Formatted Drive If the Drive to be mounted is Un-formatted (No File system) then the application needs to format the drive using SYS_FS_DriveFormat() once the SYS_FS_Mount() returns success The application can make use of SYS_FS_Error() API to check if the mount was successful with no file system on the drive sys_fs_mount_unformatted Once the drive is mounted the application code can then open the file from the drive with different attributes (such as read/write/append) If the file open returns a valid handle the application can proceed further Otherwise the application can keep trying to open the file The reason for an invalid handle could be that the application was trying to open a file in read mode from the drive that does not exist Another reason for an invalid handle is when the application tries to open a file in write mode but the drive is write-protected Once the file is opened the valid file handle is further used to read/write data to the file Once the required operation is performed on the file the file can then be closed by the application by passing the file handle sys_fs_open_read_write_close Example Application to create and write to a file on SD Card SYS_FS_HANDLE fileHandle ; APP_STATES state ;  void APP_Initialize (  void  )  {  /* Initialize the app state to wait for media attach */ state = APP_MOUNT_DISK ;  }  void  App_Task ( void )  {  switch ( state )  {  case APP_MOUNT_DISK :  {  if  ( SYS_FS_Mount ( \"/dev/mmcblka1\"   \"/mnt/mydrive\"  FAT   0   NULL )  == SYS_FS_RES_SUCCESS )  { state = APP_FILE_OPEN ;  }  break ;  }  case APP_FILE_OPEN :  {  /* Will open a file in write mode It creates the file if it does not exist */ fileHandle =  SYS_FS_FileOpen ( \"/mnt/mydrive/file txt\"  SYS_FS_FILE_OPEN_WRITE ) ;  if  ( fileHandle = SYS_FS_HANDLE_INVALID )  { state = APP_FILE_WRITE ;  }  break ;  }  case APP_FILE_WRITE :  {  if  ( SYS_FS_FileWrite ( fileHandle   \"HELLO WORLD\"   sizeof ( \"HELLO WORLD\" ) )  ==  - 1 )  {  /* Write Failed Error Out */ state = APP_FILE_ERROR ;  }  else  { state = APP_FILE_CLOSE ;  }  break ;  }  case APP_FILE_CLOSE :  {  SYS_FS_FileClose ( fileHandle ) ; state = APP_FILE_UNMOUNT ;  break ;  }  case APP_FILE_UNMOUNT :  {  SYS_FS_UnMount ( \"/mnt/mydrive\" ) ; state = APP_IDLE ;  break  }  case APP_IDLE :  {  break ;  }  case APP_ERROR :  {  /* The application comes here when the demo has failed Close the opened file */ SYS_FS_FileClose ( fileHandle ) ;  break ;  }  default :  {  break ;  }  }  }  ",
							" Configuring The Library File System Service Library should be configured via MHC The following figures show the MHC configuration window for File System Service and brief description File System configurations with Auto Mount disabled sys_fs_mhc_config_automount_disabled File System configurations with Auto Mount Enabled sys_fs_mhc_config_automount_enabled Configuration Options Maximum Simultaneous File Access: Maximum Number of files which can be accessed/opened by application Size Of Block: Block Size used by File System layer to chunk the application data and to send to attached media Size Of Media Manager Buffer: Media Manager Buffer size to store Block Data Use File System Auto Mount Feature: Enables auto mount feature for all the media's Total Number Of Media: Number of media to be attached to file system Total Number Of File System Clients: Number of clients to file system registered when Auto mount is enabled Each of these client will receive a notfication on mount/unmount event for any media Total Number Of Volumes: Number of volumes to be created for each media MediaX: Media details to be configured when Auto mount feature is enabled These options will be used to populate the sysfsMountTable in initialization c Media ConfigurationX: Media Type: Specifies the media type to be mounted File System Type: Specifies the file system to be mounted for the selected media Number Of Volumes Number of volumes to be created for the selected media VolumeX: Volume ConfigurationX: Volume details to be configured Device Name: Specifies the device name to be used for the media Each media type has fixed names and will be auto-populated Should always start with /dev/ Media Mount Name: Specifies the unique volume mount name This should be used by application while opening the file Should always start with /mnt/ File System Types: Number of file systems used in the application FAT File System: When Selected FAT File system will be used Fat File System Version: Specifies Fat-FS version currently Supported Make FAT File System Read-Only: When selected Fat-FS code is compiled with Read Only option enabled OEM Code Page to be Used: Code page configuration to be used Refer to ffconf h for more details Enable exFAT File System Support: When selected exFAT support will be enabled in native file system code Microchip File System: When Selected MPFS File system will be used LittleFS File System: When Selected littleFS File system will be used Make LittleFS File System Read-Only: When selected littleFS code is compiled with Read only option enabled Size Of LFS image (in KB): Specifies the size of the LFS image to be used Enable Long File Name Support: When selected Long file name support is enabled This option is selected by default If disabled the file name length should follow the 8 3 format (Short file name) File Name Length: Max file name length to be supported Current Working Directory Scratch buffer length in Bytes: Buffer size to store the current directory path Enable Cache Line Aligned Buffer for Cache Management when enabled file system will use this aligned buffer to submit the request to Media if the input buffer for the read/Write operations is not aligned to Cache Line Size Aligned Buffer Length in Multiple of 512 Bytes: Specifies the length of the internal file system aligned buffer Increasing the length of the buffer will increase the write throughput but consume more RAM memory RTOS Settings: These options will be enabled when any of the RTOS is added in MHC Stack Size (in Bytes): Specifies the stack size for the File system task/thread The size can vary based on RTOS and should be configured based on application requirement Task Priority: Specifies the priority for the File system task/thread The value can vary based on RTOS used Use Task Delay When enabled the File system task will be scheduled out voluntarily after every run based on the delay configured Task Delay: Specifies the duration the task has to go to sleep after every run Should be configured carefully based on the application need and number of task running along in the system RTOS Settings For MicriumOS-III RTOS Below additional options are visible in File Systems RTOS settings when the MicriumOS-III is added into project graph rtos_settings_micrium_os_iii Maximum Message Queue Size: This argument specifies the maximum number of messages that the task can receive through internal message queue A MicriumOS-III task contains an optional internal message queue (if OS_CFG_TASK_Q_EN is set to DEF_ENABLED in os_cfg h) The user may specify that the task is unable to receive messages by setting this argument to 0 Task Time Quanta: The amount of time (in clock ticks) for the time quanta when Round Robin is enabled If you specify 0 then the default time quanta will be used which is the tick rate divided by 10 Task Specific Options: Contains task-specific options Each option consists of one bit The option is selected when the bit is set The current version of MicriumOS-III supports the following options: Stack checking is allowed for the task: Specifies whether stack checking is allowed for the task Stack needs to be cleared: Specifies whether the stack needs to be cleared Floating-point registers needs to be saved: Specifies whether floating-point registers are saved This option is only valid if the processor has floating-point hardware and the processor-specific code saves the floating-point registers TLS (Thread Local Storage) support needed for the task: If the caller doesn�t want or need TLS (Thread Local Storage) support for the task being created If you do not include this option TLS will be supported by default TLS support was added in V3 03 00 ",
							" Library Interface File System Service library provides the following interfaces: SYS FS Functions These API's should be used from application layer to perform any file operation Name Description SYS_FS_Initialize Initializes the file system abstraction layer (sys_fs layer) SYS_FS_Tasks Maintains the File System tasks and functionalities SYS_FS_Mount Mounts the disk/volume with specified file system SYS_FS_Unmount Unmounts the disk/volume for the file system SYS_FS_EventHandlerSet Sets the pointer to the function (and it's context) to be called when mount/unmount event has occurred SYS_FS_FileOpen Opens a file SYS_FS_FileClose Closes a file SYS_FS_FileRead Read data from the file SYS_FS_FileStat Gets file status SYS_FS_FileSeek Moves the file pointer by the requested offset SYS_FS_FileTell Obtains the file pointer position SYS_FS_FileSize Returns the size of the file in bytes SYS_FS_FileEOF Checks for end of file SYS_FS_FileNameGet Reads the file name SYS_FS_Error Returns the last error SYS_FS_FileError Returns the file specific error SYS_FS_FileStringGet Reads a string from the file into a buffer SYS_FS_FileStringPut Writes a string to a file SYS_FS_FileWrite Writes data to the file SYS_FS_FileSync Flushes the cached information when writing to a file SYS_FS_FileTruncate Truncates a file SYS_FS_FileCharacterPut Writes a character to a file SYS_FS_FilePrintf Writes a formatted string into a file SYS_FS_FileTestError Checks for errors in the file SYS_FS_DirOpen Open a directory SYS_FS_DirClose Closes an opened directory SYS_FS_DirRead Reads the files and directories of the specified directory SYS_FS_DirRewind Rewinds to the beginning of the directory SYS_FS_DirSearch Searches for a file or directory SYS_FS_DirectoryMake Creates a directory SYS_FS_DirectoryChange Changes to a the directory specified SYS_FS_CurrentWorkingDirectoryGet Gets the current working directory SYS_FS_FileDirectoryRemove Removes a file or directory SYS_FS_FileDirectoryRenameMove Renames or moves a file or directory SYS_FS_FileDirectoryModeSet Sets the mode for the file or directory SYS_FS_FileDirectoryTimeSet Sets or changes the time for a file or directory SYS_FS_CurrentDriveGet Gets the current drive SYS_FS_CurrentDriveSet Sets the drive SYS_FS_DriveLabelGet Gets the drive label SYS_FS_DriveLabelSet Sets the drive label SYS_FS_DriveFormat Formats a drive SYS_FS_DrivePartition Partitions a physical drive (media) SYS_FS_DriveSectorGet Obtains total number of sectors and number of free sectors for the specified drive SYS FS Data types and constants Name Type Description SYS_FS_HANDLE Typedef This type defines the file handle SYS_FS_HANDLE_INVALID Macro Invalid file handle SYS_FS_FILE_SYSTEM_TYPE Enum Enumerated data type identifying native file systems supported SYS_FS_FILE_DIR_ATTR Enum Enumerated data type identifying the various attributes for file/directory SYS_FS_FILE_SEEK_CONTROL Enum Lists the various modes of file seek SYS_FS_RESULT Enum Lists the various results of a file operation SYS_FS_FORMAT Macros Specifes the partitioning rule SYS_FS_FORMAT_PARAM Struct SYS FS Drive Format parameter structure SYS_FS_FILE_OPEN_ATTRIBUTES Enum Lists the various attributes (modes) in which a file can be opened SYS_FS_ERROR Enum Lists the various error cases SYS_FS_EVENT Enum Identifies the possible file system events SYS_FS_FUNCTIONS Struct SYS FS Function signature structure for native file systems SYS_FS_REGISTRATION_TABLE Struct The initialization members for File system layer SYS_FS_FSTAT Struct File System status SYS_FS_TIME Union The Union to specify the time for a file or directory SYS_FS_EVENT_HANDLER Typedef Pointer to the File system Handler function SYS FS Media Manager Functions These API's should not be direclty used from application layer These can be used internally by media drivers and other clients within Harmony framework if needed Name Description SYS_FS_MEDIA_MANAGER_AddressGet Gets the starting media address based on a disk number SYS_FS_MEDIA_MANAGER_CommandStatusGet Gets the command status SYS_FS_MEDIA_MANAGER_Register Function to register media drivers with the media manager SYS_FS_MEDIA_MANAGER_DeRegister Function to De-register media drivers with the media manager SYS_FS_MEDIA_MANAGER_Read Gets data from a specific media address SYS_FS_MEDIA_MANAGER_SectorRead Reads a specified media sector SYS_FS_MEDIA_MANAGER_SectorWrite Writes a sector to the specified media SYS_FS_MEDIA_MANAGER_VolumePropertyGet Gets the volume property SYS_FS_MEDIA_MANAGER_MediaStatusGet Gets the media status SYS_FS_MEDIA_MANAGER_EventHandlerSet Register the event handler for Mount/Un-Mount events SYS_FS_MEDIA_MANAGER_RegisterTransferHandler Register the event handler for data transfer events SYS_FS_MEDIA_MANAGER_GetMediaGeometry Gets the media geometry information SYS_FS_MEDIA_MANAGER_TransferTask Media manager transfer task function SYS_FS_MEDIA_MANAGER_Tasks Media manager task function SYS FS Media Manager Data types and constants Name Type Description SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE Typedef Handle identifying block commands of the media SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID Macro Defines the invalid media block command handle SYS_FS_MEDIA_HANDLE Typedef Handle identifying the media registered with the media manager SYS_FS_MEDIA_HANDLE_INVALID Macro Defines the invalid media handle SYS_FS_MEDIA_BLOCK_EVENT Enum Identifies the possible events that can result from a request SYS_FS_MEDIA_PROPERTY Enum Contains information of property of a media SYS_FS_MEDIA_STATUS Enum The status of media SYS_FS_MEDIA_STATE Enum The enumeration for state of media SYS_FS_MEDIA_TYPE Enum The enumeration for type of media SYS_FS_MEDIA_COMMAND_STATUS Enum The enumeration for status of buffer SYS_FS_MEDIA_REGION_GEOMETRY Typedef Contains information of a sys media region SYS_FS_MEDIA_GEOMETRY Typedef Contains all the geometrical information of a media device SYS_FS_MEDIA_MOUNT_DATA Struct Structure to obtain the device and mount name of media SYS_FS_VOLUME_PROPERTY Struct Structure to obtain the property of volume SYS_FS_MEDIA_FUNCTIONS Struct Structure of function pointers for media driver SYS_FS_MEDIA_EVENT_HANDLER Typedef Pointer to the Media Event Handler function ",
							" SYS_FS_Initialize Function ",
							" C SYS_FS_RESULT SYS_FS_Initialize (  const  void * initData ) ; ",
							" Summary Initializes the file system abstraction layer (sys_fs layer) ",
							" Description This function initializes the abstraction layer (sys_fs layer) and sets up the necessary parameters ",
							" Precondition This is the first function to be called during usage of sys_fs Calling other functions of sys_fs without initializing the sys_fs will cause unpredictable behavior ",
							" Parameters Param Description initData Pointer to an array of type SYS_FS_REGISTRATION_TABLE The number of elements of array is decided by the definition SYS_FS_MAX_FILE_SYSTEM_TYPE If the application uses one file system (say only FAT FS) SYS_FS_MAX_FILE_SYSTEM_TYPE is defined to be 1 Otherwise if the application uses 2 file systems (say FAT FS and MPFS2) SYS_FS_MAX_FILE_SYSTEM_TYPE is defined to be 2 ",
							" Returns SYS_FS_RES_SUCCESS - SYS FS Layer was initialized successfully SYS_FS_RES_FAILURE - SYS FS Layer initialization failed The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example // This code shows an example of how the SYS FS is initialized  // Only one file system is used  # define SYS_FS_MAX_FILE_SYSTEM_TYPE 1  // Function pointer table for FAT FS  const SYS_FS_FUNCTIONS FatFsFunctions =  {   mount = FATFS_mount    unmount = FATFS_unmount    open = FATFS_open    read = FATFS_read    write = FATFS_write    close = FATFS_close    seek = FATFS_lseek    tell = FATFS_tell    eof = FATFS_eof    size = FATFS_size    fstat = FATFS_stat   } ;  const SYS_FS_REGISTRATION_TABLE sysFSInit [ SYS_FS_MAX_FILE_SYSTEM_TYPE ]  =  {  {   nativeFileSystemType = FAT    nativeFileSystemFunctions =   FatFsFunctions }  } ;  SYS_FS_Initialize ( ( const  void  * ) sysFSInit ) ;  ",
							" SYS_FS_Tasks Function ",
							" C void  SYS_FS_Tasks (  void  ) ; ",
							" Summary Maintains the File System tasks and functionalities ",
							" Description This function is used to run the various tasks and functionalities of sys_fs layer ",
							" Precondition The SYS_FS_Initialize routine must have been called before running the tasks ",
							" Parameters None ",
							" Returns None ",
							" Example void SYS_Tasks (  void  )  { SYS_FS_Tasks ( ) ;  // Do other tasks  } ",
							" Remarks This function is not called directly by an application It is called by the system's Tasks routine (SYS_Tasks) ",
							" SYS_FS_Mount Function ",
							" C SYS_FS_RESULT SYS_FS_Mount (  const  char  * devName   const  char  * mountName  SYS_FS_FILE_SYSTEM_TYPE filesystemtype   unsigned  long mountflags   const  void  * data ) ; ",
							" Summary Mounts the disk/volume with specified file system ",
							" Description The mount command attaches the file system specified to a volume The call to the mount should be non blocking in nature The application code has to allow the SYS_FS_Tasks to run periodically while calling the SYS_FS_Mount function If the SYS_FS_Mount is called in a blocking mode then the SYS_FS_Tasks() never gets a chance to run and therefore the media will not be analyzed and finally the SYS_FS_Mount will never succeed This will result in a deadlock There is no mechanism available for the application to know if the specified volume (devName) is really attached or not The only available possibility is to keep trying to mount the volume (with the devname) until success is achieved or use the Automount feature It is prudent that the application code implements a time-out mechanism while trying to mount a volume (by calling SYS_FS_Mount) The trial for mount should continue at least 10 times before assuming that the mount will never succeed This has to be done for every new volume to be mounted Once the mount is successful the application needs to use SYS_FS_Error() API to know if the mount was successful with valid filesystem on media or not If SYS_FS_ERROR_NO_FILESYSTEM is returned application needs to Format the media using the SYS_FS_DriveFormat() API before performing any operations The standard names for volumes (devName) used in the MPLAB Harmony file system is as follows: NVM - \"nvm\" \"media number\" \"volume number\" SD card - \"mmcblk\" \"media number\" \"volume number\" MSD - \"sd\" \"media number\" \"volume number\" Flash - \"mtd\" \"media number\" \"volume number\" Where \"media number\" a b c depends on the number of the type of connected media \"volume number\" 1 2 3 depends on the number of partitions in that media The convention for assigning names to volumes is further described below with examples: If a SD card (with four partitions) is attached to the system and assuming all four partitions are recognized there will be four devNames: mmcblka1 mmcblka2 mmcblka3 and mmcblka4 Subsequently if NVM media is attached that has only one partition the devname will be: nvma1 Later if another SD card is attached to the system that has one partition the devname will be mmcblkb1 Finally there will be six volume names (or devNames) which are available for the application to be mounted and used for the file system ",
							" Precondition The \"devName\" name for the volume has to be known The file system type with which each of the volumes are formatted has to be known Trying to mount a volume with a file system which is different from what the volume is actually formatted will cause mount failure ",
							" Parameters Param Description devName The device name (name of volume) which needs to be mounted The devName has to be preceded by the string \"/dev/\" mountName Mount name for the device to be mounted This is a name provided by the user In future while accessing the mounted volume (say during SYS_FS_FileOpen operation) the mountName is used to refer the path for file The mount name has to be preceded by the string \"/mnt/\" filesystemtype Native file system of SYS_FS_FILE_SYSTEM_TYPE type mountflags Mounting control flags This parameter is reserved for future enhancements Therefore always pass zero data The data argument is interpreted by the different file systems This parameter is reserved for future enhancements Therefore always pass NULL ",
							" Returns SYS_FS_RES_SUCCESS - Mount was successful SYS_FS_RES_FAILURE - Mount was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example switch ( appState )  {  case TRY_MOUNT :  {  if ( SYS_FS_Mount ( \"/dev/mmcblka1\"   \"/mnt/myDrive\"  FAT   0   NULL )  = SYS_FS_RES_SUCCESS )  {  // Failure try mounting again  }  else  {  // Mount was successful Check for File System  if  ( SYS_FS_Error ( )  == SYS_FS_ERROR_NO_FILESYSTEM )  {  //Perform Driver Format operation as there is no filesystem on media  SYS_FS_DriveFormat (    ) ;  } appState = DO_FURTHER_STUFFS ;  }  }  break ;  } ",
							" Remarks None ",
							" SYS_FS_Unmount Function ",
							" C SYS_FS_RESULT SYS_FS_Unmount (  const  char  * mountName ) ; ",
							" Summary Unmounts the disk/volume for the file system ",
							" Description This function removes (unmounts) the attachment of the volume from the file system ",
							" Precondition The volume name has to be know in order to pass as input to Unmount The specified volume name to be unmounted should have been already mounted ",
							" Parameters Param Description mountName Mount name for the volume to be unmounted The mount name has to be preceded by the string \"/mnt/\" ",
							" Returns SYS_FS_RES_SUCCESS - Unmount was successful SYS_FS_RES_FAILURE - Unmount was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example if ( SYS_FS_Unmount ( \"/mnt/myDrive\" )  = SYS_FS_RES_SUCCESS )  {  // Failure try unmounting again  }  else  {  // Unmount was successful  } ",
							" SYS_FS_EventHandlerSet Function ",
							" C void SYS_FS_EventHandlerSet (  const  void  * eventHandler   const uintptr_t context ) ; ",
							" Summary Sets the pointer to the function (and it's context) to be called when mount/unmount event has occurred ",
							" Description This function allows a client to identify an event handling function for the File System to call back when mount/unmount operation has completed The file system will pass mount name back to the client by calling \"eventHandler\" when AutoMount feature is enabled for File system ",
							" Precondition The SYS_FS_Initialize() routine must have been called ",
							" Parameters Param Description eventHandler Pointer to the event handler function implemented by the user context The value of parameter will be passed back to the client unchanged when the eventHandler function is called It can be used to identify any client specific data object that identifies the instance of the client module (for example it may be a pointer to the client module's state structure) ",
							" Returns None ",
							" Example // Client registers an event handler with file system This is done once  SYS_FS_EventHandlerSet ( APP_SysFSEventHandler   ( uintptr_t ) NULL ) ;  // Event Processing Technique Event is received when operation is done  void APP_SysFSEventHandler ( SYS_FS_EVENT event   void * eventData  uintptr_t context )  {  switch ( event )  {  case SYS_FS_EVENT_MOUNT :  {  if ( strcmp ( ( const  char  * ) eventData  \"/mnt/myDrive1\" )  ==  0 )  { gSDCardMountFlag = true ;  }  else  if ( strcmp ( ( const  char  * ) eventData  \"/mnt/myDrive2\" )  ==  0 )  { gNVMMountFlag = true ;  }  break ;  }  case SYS_FS_EVENT_MOUNT_WITH_NO_FILESYSTEM :  {  if ( strcmp ( ( const  char  * ) eventData  \"/mnt/myDrive1\" )  ==  0 )  { gSDCardFormatRequired = true ;  }  else  if ( strcmp ( ( const  char  * ) eventData  \"/mnt/myDrive2\" )  ==  0 )  { gNVMFormatRequired = true ;  }  break ;  }  case SYS_FS_EVENT_UNMOUNT :  {  if ( strcmp ( ( const  char  * ) eventData  \"/mnt/myDrive1\" )  ==  0 )  { gSDCardMountFlag = false ;  }  else  if ( strcmp ( ( const  char  * ) eventData  \"/mnt/myDrive2\" )  ==  0 )  { gNVMMountFlag = false ;  }  break ;  }  case SYS_FS_EVENT_ERROR :  default :  {  break ;  }  }  } ",
							" Remarks On Mount/Un-Mount of a volume all the registered clients will be notified The client should check if the mount name passed when event handler is called is the one it is expecting and then proceed as demonstrated in above example If the client does not want to be notified when the mount/unmount operation has completed it does not need to register a callback Note: This API is Available only when SYS_FS_AUTOMOUNT_ENABLE is set to true ",
							" SYS_FS_FileOpen Function ",
							" C SYS_FS_HANDLE SYS_FS_FileOpen (  const  char * fname  SYS_FS_FILE_OPEN_ATTRIBUTES attributes ) ; ",
							" Summary Opens a file ",
							" Description This function opens a file with the requested attributes ",
							" Precondition Prior to opening a file the name of the volume on which the file resides should be known and the volume should be mounted ",
							" Parameters Param Description fname The name of the file to be opened along with the path The fname format is as follows: \"/mnt/volumeName/dirName/fileName\" volumeName is the name of the volume/drive dirName is the name of the directory under which the file is located fileName is the name of the file to be opened The \"/mnt/volumeName\" portion from the fName can be omitted if the SYS_FS_CurrentDriveSet () has been invoked to set the current drive/volume attributes Access mode of the file of type SYS_FS_FILE_OPEN_ATTRIBUTES ",
							" Returns On success - A valid file handle will be returned On failure - SYS_FS_HANDLE_INVALID The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_HANDLE fileHandle ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_READ ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open succeeded  }  else  {  // File open failed  } // Using SYS_FS_CurrentDriveSet () function SYS_FS_HANDLE fileHandle ;  SYS_FS_CurrentDriveSet ( \"/mnt/myDrive\" ) ; fileHandle =  SYS_FS_FileOpen ( \"FILE txt\"   ( SYS_FS_FILE_OPEN_READ ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open succeeded  }  else  {  // File open failed  } ",
							" Remarks None ",
							" SYS_FS_FileClose Function ",
							" C SYS_FS_RESULT SYS_FS_FileClose ( SYS_FS_HANDLE handle ) ; ",
							" Summary Closes a file ",
							" Description This function closes an opened file Before closing the file it performs a force sync to write any pending data to the file ",
							" Precondition A valid file handle must be obtained before closing a file ",
							" Parameters Param Description handle A valid handle which was obtained while opening the file ",
							" Returns SYS_FS_RES_SUCCESS - File close operation was successful SYS_FS_RES_FAILURE - File close operation failed The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_HANDLE fileHandle ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_READ ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }  SYS_FS_FileClose ( fileHandle ) ; ",
							" Remarks None ",
							" SYS_FS_FileRead Function ",
							" C size_t SYS_FS_FileRead ( SYS_FS_HANDLE handle   void  * buf  size_t nbyte ) ; ",
							" Summary Read data from the file ",
							" Description This function attempts to read nbyte bytes of data from the file associated with the file handle into the buffer pointed to by buf ",
							" Precondition A valid file handle must be obtained before reading a file ",
							" Parameters Param Description handle File handle obtained during file open buf Pointer to buffer into which data is read nbyte Number of bytes to be read ",
							" Returns On success - returns the number of bytes read successfully(0 or positive number) On failure - returns -1 The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example     char CACHE_ALIGN buf [ 256 ] ; size_t nbytes ; size_t bytes_read ; SYS_FS_HANDLE fileHandle ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_READ ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  } nbytes =  sizeof ( buf ) ; bytes_read =  SYS_FS_FileRead ( fileHandle  buf  nbytes ) ;  ",
							" Remarks None ",
							" SYS_FS_FileStat Function ",
							" C SYS_FS_RESULT SYS_FS_FileStat (  const  char  * fname  SYS_FS_FSTAT * buf ) ",
							" Summary Gets file status ",
							" Description This function obtains information about a file associated with the file name and populates the information in the structure pointed to by buf This function can read the status of file regardless of whether a file is opened or not The file system supports 8 3 file name(Short File Name) and also long file name 8 3 filenames are limited to at most eight characters followed optionally by a filename extension consisting of a period and at most three further characters If the file name fits within the 8 3 limits then generally there will be no valid LFN for it For FAT File system If LFN is used the stat structure's altname field will contain the short file name and fname will contain the long file name The \"lfname\" member of the SYS_FS_FSTAT is not applicable for FAT It has to be initialized to NULL before calling the API If \"lfname\" is not NULL then first byte of lfname will be set to zero indicating no file found For other File systems based on thier implementation -If LFN is used then the \"lfname\" member of the SYS_FS_FSTAT structure should be initialized with the address of a suitable buffer and the \"lfsize\" should be initialized with the size of the buffer Once the function returns the buffer whose address is held in \"lfname\" will have the file name(long file name) The stat structure's fname field will contain the SFN and if there is a valid LFN entry for the file then the long file name will be copied into lfname member of the structure ",
							" Precondition Prior to opening a file the name of the volume on which the file resides should be known and the volume should be mounted ",
							" Parameters Param Description fname Name of the file with the path and the volume name The string of volume and file name has to be preceded by \"/mnt/\" Also the volume name and file name has to be separated by a slash \"/\" buf pointer to SYS_FS_FSTAT structure ",
							" Returns SYS_FS_RES_SUCCESS - File stat operation was successful SYS_FS_RES_FAILURE - File stat operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_fStat fileStat ;  if ( SYS_FS_FileStat ( \"/mnt/myDrive/FILE TXT\"    fileStat )  == SYS_FS_RES_SUCCESS )  {  // Successfully read the status of file \"FILE TXT\"  } ",
							" Remarks None ",
							" SYS_FS_FileSeek Function ",
							" C int32_t SYS_FS_FileSeek ( SYS_FS_HANDLE handle  int32_t offset  SYS_FS_FILE_SEEK_CONTROL whence ) ; ",
							" Summary Moves the file pointer by the requested offset ",
							" Description This function sets the file pointer for a open file associated with the file handle as follows: whence = SYS_FS_SEEK_SET - File offset is set to offset bytes from the beginning whence = SYS_FS_SEEK_CUR - File offset is set to its current location plus offset whence = SYS_FS_SEEK_END - File offset is set to the size of the file plus offset The offset specified for this option should be negative for the file pointer to be valid Trying to move the file pointer using SYS_FS_FileSeek beyond the range of file will only cause the pointer to be moved to the last location of the file ",
							" Precondition A valid file handle must be obtained before seeking a file ",
							" Parameters Param Description handle A valid file handle obtained during file open offset The number of bytes which act as file offset This value could be a positive or negative value whence Type of File Seek operation as specified in SYS_FS_FILE_SEEK_CONTROL ",
							" Returns On success - The number of bytes by which file pointer is moved (0 or positive number) On Failure - (-1) If the chosen offset value was (-1) the success or failure can be determined with SYS_FS_Error ",
							" Example SYS_FS_HANDLE fileHandle ;  int status ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_READ ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }         status =  SYS_FS_FileSeek ( fileHandle   5  SYS_FS_SEEK_CUR ) ;  if ( ( status =  - 1 )    ( status ==  5 ) )  {  // Success  } ",
							" Remarks None ",
							" SYS_FS_FileTell Function ",
							" C int32_t SYS_FS_FileTell ( SYS_FS_HANDLE handle ) ; ",
							" Summary Obtains the file pointer position ",
							" Description Obtains the current value of the file position indicator for the file pointed to by handle ",
							" Precondition A valid file handle must be obtained before performing a file tell ",
							" Parameters Param Description handle File handle obtained during file Open ",
							" Returns On success - returns the current file position On failure - returns -1 The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_HANDLE fileHandle ; int32_t tell ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE JPG\"   ( SYS_FS_FILE_OPEN_READ ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }         tell =  SYS_FS_FileTell ( fileHandle ) ;  if ( tell =  - 1 )  {  // Success  } ",
							" Remarks None ",
							" SYS_FS_FileSize Function ",
							" C int32_t SYS_FS_FileSize ( SYS_FS_HANDLE handle ) ; ",
							" Summary Returns the size of the file in bytes ",
							" Description This function returns the size of the file as pointed by the handle ",
							" Precondition A valid file handle must be obtained before knowing a file size ",
							" Parameters Param Description handle File handle obtained during file Open ",
							" Returns On success - returns the size of the file in bytes On failure - returns -1 The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_HANDLE fileHandle ;  long fileSize ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_READ ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }         fileSize =  SYS_FS_FileSize ( fileHandle ) ;  if ( fileSize =  - 1 )  {  // Success  } ",
							" Remarks None ",
							" SYS_FS_FileEOF Function ",
							" C bool SYS_FS_FileEOF ( SYS_FS_HANDLE handle ) ; ",
							" Summary Checks for end of file ",
							" Description Checks whether or not the file position indicator is at the end of the file ",
							" Precondition A valid file handle must be obtained before knowing a EOF ",
							" Parameters Param Description handle file handle obtained during file Open ",
							" Returns On success - returns true indicating that the file pointer has reached the end of the file On failure - returns false This could be due to file pointer having not reached the end of the file Or due to an invalid file handle The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_HANDLE fileHandle ; bool eof ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_READ ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }         eof =  SYS_FS_FileEOF ( fileHandle ) ;  if ( eof == false )  {  // Check the error state using SYS_FS_FileError  } ",
							" Remarks None ",
							" SYS_FS_FileNameGet Function ",
							" C bool SYS_FS_FileNameGet ( SYS_FS_HANDLE handle  uint8_t * cName  uint16_t wLen ) ; ",
							" Summary Reads the file name ",
							" Description This function reads the file name of a file that is already open ",
							" Precondition The file handle referenced by handle is already open ",
							" Parameters Param Description handle File handle obtained during file Open cName Where to store the name of the file wLen The maximum length of data to store in cName ",
							" Returns true - if the file name was read successfully false - if the file name was not read successfully The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_HANDLE fileHandle ; bool stat ; uint8_t fileName [ 255 ] ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_READ ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }         stat =  SYS_FS_FileNameGet ( fileHandle  fileName   8  ) ;  if ( stat == false )  {  // file not located based on handle passed  // Check the error state using SYS_FS_FileError  } ",
							" Remarks None ",
							" SYS_FS_Error Function ",
							" C SYS_FS_ERROR SYS_FS_Error (  void  ) ; ",
							" Summary Returns the last error ",
							" Description When a file system operation fails the application can know the reason of failure by calling the SYS_FS_Error This function only reports the errors which are not file (or file handle) specific For example for functions such as SYS_FS_Mount and SYS_FS_FileOpen which do not take handle any errors happening inside such function calls could be reported using SYS_FS_Error function Even for functions which take handle as its input parameters the SYS_FS_Error function can be used to report the type of error for cases where the passed handle itself is invalid ",
							" Precondition This function has to be called immediately after a failure is observed while doing a file operation Any subsequent failure will overwrite the cause of previous failure ",
							" Parameters None ",
							" Returns Error code of type SYS_FS_ERROR ",
							" Example SYS_FS_HANDLE fileHandle ; SYS_FS_ERROR err ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_READ ) ) ;  if ( fileHandle == SYS_FS_HANDLE_INVALID )  {  // If failure now know the specific reason for failure err =  SYS_FS_Error ( ) ;  } ",
							" Remarks None ",
							" SYS_FS_FileError Function ",
							" C SYS_FS_ERROR SYS_FS_FileError ( SYS_FS_HANDLE handle ) ; ",
							" Summary Returns the file specific error ",
							" Description For file system functions which accepts valid handle any error happening in those functions could be retrieved with SYS_FS_FileError This function returns errors which are file specific Please note that if an invalid handle is passed to a file system function in such a case SYS_FS_FileError will not return the correct type of error as the handle was invalid Therefore it would be prudent to check the errors using the SYS_FS_Error function ",
							" Precondition This function has to be called immediately after a failure is observed while doing a file operation Any subsequent failure will overwrite the cause of previous failure ",
							" Parameters Param Description handle A valid file handle ",
							" Returns Error code of type SYS_FS_ERROR ",
							" Example    SYS_FS_HANDLE fileHandle ;  const  char  * buf =  \"Hello World\" ; size_t nbytes ; size_t bytes_written ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_WRITE ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }  // Write data to the file bytes_written =  SYS_FS_FileWrite ( fileHandle   ( const  void  * ) buf  nbytes ) ;  if ( bytes_written ==  - 1 )  {  // error while writing file  // find the type (reason) of error err =  SYS_FS_FileError ( fd ) ;  } ",
							" Remarks None ",
							" SYS_FS_FileStringGet Function ",
							" C SYS_FS_RESULT SYS_FS_FileStringGet ( SYS_FS_HANDLE handle   char * buff  uint32_t len ) ; ",
							" Summary Reads a string from the file into a buffer ",
							" Description This function reads a string of specified length from the file into a buffer The read operation continues until ' n' is stored reached end of the file or the buffer is filled with len - 1 characters The read string is terminated with a ' 0' ",
							" Precondition The file from which a string has to be read has to be present and should have been opened ",
							" Parameters Param Description handle Handle of the file from which string is to be read buff Buffer in which the string is to be stored len length of string to be read ",
							" Returns SYS_FS_RES_SUCCESS - String read operation was successful SYS_FS_RES_FAILURE - String read operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_RESULT res ; SYS_FS_HANDLE fileHandle ;  char CACHE_ALIGN buffer [ 100 ] ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_WRITE_PLUS ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }  // Read a string from the file res =  SYS_FS_FileStringGet ( fileHandle  buffer   50 ) ;  if ( res = SYS_FS_RES_SUCCESS )  {  //String read operation failed  } ",
							" Remarks None ",
							" SYS_FS_FileStringPut Function ",
							" C SYS_FS_RESULT SYS_FS_FileStringPut ( SYS_FS_HANDLE handle   const  char  * string ) ; ",
							" Summary Writes a string to a file ",
							" Description This function writes a string into a file The string to be written should be NULL terminated The terminator character will not be written ",
							" Precondition The file into which a string has to be written has to be present and should have been opened ",
							" Parameters Param Description handle File handle to which string is to be written string Pointer to the null terminated string which has to be written into file ",
							" Returns SYS_FS_RES_SUCCESS - String write operation was successful SYS_FS_RES_FAILURE - String write operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_RESULT res ; SYS_FS_HANDLE fileHandle ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"  SYS_FS_FILE_OPEN_WRITE_PLUS ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }  // Write a string res =  SYS_FS_FileStringPut ( fileHandle   \"Hello World\" ) ;  if ( res = SYS_FS_RES_SUCCESS )  {  // String write operation failed  } ",
							" Remarks None ",
							" SYS_FS_FileWrite Function ",
							" C size_t SYS_FS_FileWrite ( SYS_FS_HANDLE handle   const  void  * buf  size_t nbyte ) ; ",
							" Summary Writes data to the file ",
							" Description This function attempts to write nbyte bytes from the buffer pointed to by buf to the file associated with the file handle ",
							" Precondition A valid file handle must be obtained before writing a file ",
							" Parameters Param Description handle File handle obtained during file open buf Pointer to buffer from which data is to be written nbyte Number of bytes to be written ",
							" Returns On success - returns the number of bytes written successfully(0 or positive number) On failure - returns -1 The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_HANDLE fileHandle ;  const  char  * buf =  \"Hello World\" ; size_t nbytes ; size_t bytes_written ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_WRITE ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }  // Write data to the file bytes_written =  SYS_FS_FileWrite ( fileHandle   ( const  void  * ) buf  nbytes ) ; ",
							" Remarks None ",
							" SYS_FS_FileSync Function ",
							" C SYS_FS_RESULT SYS_FS_FileSync ( SYS_FS_HANDLE handle ) ; ",
							" Summary Flushes the cached information when writing to a file ",
							" Description This function flushes the cached information when writing to a file The SYS_FS_FileSync function performs the same process as SYS_FS_FileClose function; however the file is left open and can continue read/write/seek operations to the file ",
							" Precondition A valid file handle has to be passed as input to the function The file which has to be flushed has to be present and should have been opened in write mode ",
							" Parameters Param Description handle valid file handle ",
							" Returns SYS_FS_RES_SUCCESS - File sync operation was successful SYS_FS_RES_FAILURE - File sync operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_RESULT res ; SYS_FS_HANDLE fileHandle ;  const  char  * buf =  \"Hello World\" ; size_t nbytes ; size_t bytes_written ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_WRITE ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }  // Write data to the file bytes_written =  SYS_FS_FileWrite ( fileHandle   ( const  void  * ) buf  nbytes ) ;  // Flush the file res =  SYS_FS_FileSync ( fileHandle ) ;  if ( res = SYS_FS_RES_SUCCESS )  {  // Sync failed  } ",
							" Remarks None ",
							" SYS_FS_FileTruncate Function ",
							" C SYS_FS_RESULT SYS_FS_FileTruncate ( SYS_FS_HANDLE handle ) ; ",
							" Summary Truncates a file ",
							" Description This function truncates the file size to the current file read/write pointer This function has no effect if the file read/write pointer is already pointing to end of the file ",
							" Precondition A valid file handle has to be passed as input to the function The file has to be opened in a mode where writes to file is possible (such as read plus or write mode) ",
							" Parameters Param Description handle A valid handle which was obtained while opening the file ",
							" Returns SYS_FS_RES_SUCCESS - File truncate operation was successful SYS_FS_RES_FAILURE - File truncate operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_HANDLE fileHandle ; size_t nbytes ; size_t bytes_read ; SYS_FS_RESULT res ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE JPG\"   ( SYS_FS_FILE_OPEN_READ ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }  // Read the file content nbytes =  sizeof ( buf ) ; bytes_read =  SYS_FS_FileRead ( fileHandle  buf  nbytes ) ;  // Truncate the file res =  SYS_FS_FileTruncate ( fileHandle ) ;  if ( res = SYS_FS_RES_SUCCESS )  {  // Truncation failed  }  SYS_FS_FileClose ( fileHandle ) ;  ",
							" Remarks None ",
							" SYS_FS_FileCharacterPut Function ",
							" C SYS_FS_RESULT SYS_FS_FileCharacterPut ( SYS_FS_HANDLE handle   char data ) ; ",
							" Summary Writes a character to a file ",
							" Description This function writes a character to a file ",
							" Precondition The file into which a character has to be written has to be present and should have been opened ",
							" Parameters Param Description handle file handle to which the character is to be written data character to be written to the file ",
							" Returns SYS_FS_RES_SUCCESS - Write operation was successful SYS_FS_RES_FAILURE - Write operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_RESULT res ; SYS_FS_HANDLE fileHandle ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_WRITE_PLUS ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }  // Write a character to the file res =  SYS_FS_FileCharacterPut ( fileHandle   'c' ) ;  if ( res = SYS_FS_RES_SUCCESS )  {  // Character write operation failed  } ",
							" Remarks None ",
							" SYS_FS_FilePrintf Function ",
							" C SYS_FS_RESULT SYS_FS_FilePrintf ( SYS_FS_HANDLE handle   const  char  * string       ) ; ",
							" Summary Writes a formatted string into a file ",
							" Description This function writes a formatted string into a file ",
							" Precondition The file into which a string has to be written must exist and should be open ",
							" Parameters Param Description handle File handle to which formatted string is to be written string Pointer to formatted string which has to be written into file ",
							" Returns SYS_FS_RES_SUCCESS - Formatted string write operation was successful SYS_FS_RES_FAILURE - Formatted string write operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_RESULT res ; SYS_FS_HANDLE fileHandle ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE txt\"   ( SYS_FS_FILE_OPEN_WRITE_PLUS ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }  // Write a string res =  SYS_FS_FilePrintf ( fileHandle   \"Hello World %d\"   1234 ) ;  if ( res = SYS_FS_RES_SUCCESS )  {  // write operation failed  } ",
							" Remarks None ",
							" SYS_FS_FileTestError Function ",
							" C bool SYS_FS_FileTestError ( SYS_FS_HANDLE handle ) ; ",
							" Summary Checks for errors in the file ",
							" Description This function checks whether or not file has any errors ",
							" Precondition A valid file handle must be obtained before passing to the function ",
							" Parameters Param Description handle file handle obtained during file Open ",
							" Returns On success returns false indicating that the file has no errors On failure returns true The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_HANDLE fileHandle ; bool err ; fileHandle =  SYS_FS_FileOpen ( \"/mnt/myDrive/FILE JPG\"   ( SYS_FS_FILE_OPEN_READ ) ) ;  if ( fileHandle = SYS_FS_HANDLE_INVALID )  {  // File open is successful  }         err =  SYS_FS_FileTestError ( fileHandle ) ;  if ( err == true )  {  // either file has error or there  // was an error in working with the \"SYS_FS_FileTestError\" function  }  ",
							" Remarks None ",
							" SYS_FS_DirOpen Function ",
							" C SYS_FS_HANDLE SYS_FS_DirOpen (  const  char * path ) ; ",
							" Summary Open a directory ",
							" Description This function opens the requested directory ",
							" Precondition The volume on which the directory is present should be mounted ",
							" Parameters Param Description path Path to the directory along with the volume name The string of volume and directory name has to be preceded by \"/mnt/\" Also the volume name and directory name has to be separated by a slash \"/\" If the directory specified is only the root directory the path has to be ended with \"/\" ",
							" Returns On success - a valid handle to the directory will be returned On failure - SYS_FS_HANDLE_INVALID will be returned The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_HANDLE dirHandle ; dirHandle =  SYS_FS_DirOpen ( \"/mnt/myDrive/Dir1\" ) ;  // For root directory end with a \"/\"  // dirHandle = SYS_FS_DirOpen(\"/mnt/myDrive/\");  if ( dirHandle = SYS_FS_HANDLE_INVALID )  {  // Directory open is successful  } ",
							" Remarks None ",
							" SYS_FS_DirClose Function ",
							" C SYS_FS_RESULT SYS_FS_DirClose ( SYS_FS_HANDLE handle ) ; ",
							" Summary Closes an opened directory ",
							" Description This function closes a directory that was opened earlier opened with the SYS_FS_DirOpen function ",
							" Precondition A valid directory handle must be obtained before closing the directory ",
							" Parameters Param Description handle directory handle obtained during directory open ",
							" Returns SYS_FS_RES_SUCCESS - Directory close operation was successful SYS_FS_RES_FAILURE - Directory close operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_HANDLE dirHandle ; dirHandle =  SYS_FS_DirOpen ( \"/mnt/myDrive/Dir1\" ) ;  if ( dirHandle = SYS_FS_HANDLE_INVALID )  {  // Directory open is successful  }  // Perform required operation on the directory  // Close the directory  if ( SYS_FS_DirClose ( dirHandle )  == SYS_FS_RES_FAILURE )  {  // Close operation failed  } ",
							" Remarks None ",
							" SYS_FS_DirRead Function ",
							" C SYS_FS_RESULT SYS_FS_DirRead ( SYS_FS_HANDLE handle  SYS_FS_FSTAT * stat ) ; ",
							" Summary Reads the files and directories of the specified directory ",
							" Description This function reads the files and directories specified in the open directory The file system supports 8 3 file name(Short File Name) and also long file name 8 3 filenames are limited to at most eight characters followed optionally by a filename extension consisting of a period and at most three further characters If the file name fits within the 8 3 limits then generally there will be no valid LFN for it For FAT File system If LFN is used the stat structure's altname field will contain the short file name and fname will contain the long file name The \"lfname\" member of the SYS_FS_FSTAT is not applicable for FAT It has to be initialized to NULL before calling the API If \"lfname\" is not NULL then first byte of lfname will be set to zero indicating no file found For other File systems based on thier implementation -If LFN is used then the \"lfname\" member of the SYS_FS_FSTAT structure should be initialized with the address of a suitable buffer and the \"lfsize\" should be initialized with the size of the buffer Once the function returns the buffer whose address is held in \"lfname\" will have the file name(long file name) The stat structure's fname field will contain the SFN and if there is a valid LFN entry for the file then the long file name will be copied into lfname member of the structure ",
							" Precondition A valid directory handle must be obtained before reading a directory ",
							" Parameters Param Description handle Directory handle obtained during directory open stat Pointer to SYS_FS_FSTAT where the properties of the open directory will be populated after the SYS_FS_DirRead function returns successfully ",
							" Returns SYS_FS_RES_SUCCESS - Indicates that the directory read operation was successful End of the directory condition is indicated by setting the fname and lfname(if lfname is used) fields of the SYS_FS_FSTAT structure to ' 0' SYS_FS_RES_FAILURE - Indicates that the directory read operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example // For FAT File System SYS_FS_HANDLE dirHandle ; SYS_FS_FSTAT stat ; dirHandle =  SYS_FS_DirOpen ( \"/mnt/myDrive/Dir1\" ) ;  if ( dirHandle = SYS_FS_HANDLE_INVALID )  {  // Directory open is successful  }  if ( SYS_FS_DirRead ( dirHandle    stat )  == SYS_FS_RES_FAILURE )  {  // Directory read failed  }  else  {  // Directory read succeeded  if  ( stat  fname [ 0 ]  ==  ' 0' )  {  // reached the end of the directory  }  else  {  // continue reading the directory  }  } // For other File Systems with LFN support SYS_FS_HANDLE dirHandle ; SYS_FS_FSTAT stat ;  char CACHE_ALIGN longFileName [ 512 ] ; dirHandle =  SYS_FS_DirOpen ( \"/mnt/myDrive/Dir1\" ) ;  if ( dirHandle = SYS_FS_HANDLE_INVALID )  {  // Directory open is successful  }  // If long file name is used the following elements of the \"stat\"  // structure needs to be initialized with address of proper buffer stat  lfname = longFileName ; stat  lfsize =  512 ;  if ( SYS_FS_DirRead ( dirHandle    stat )  == SYS_FS_RES_FAILURE )  {  // Directory read failed  }  else  {  // Directory read succeeded  if  ( ( stat  lfname [ 0 ]  ==  ' 0' )    ( stat  fname [ 0 ]  ==  ' 0' ) )  {  // reached the end of the directory  }  else  {  // continue reading the directory  }  } ",
							" Remarks None ",
							" SYS_FS_DirRewind Function ",
							" C SYS_FS_RESULT SYS_FS_DirRewind ( SYS_FS_HANDLE handle ) ; ",
							" Summary Rewinds to the beginning of the directory ",
							" Description This function rewinds the directory to the start Once a search of directory or directory read is completed the rewind function is used to begin searching the directory from the start ",
							" Precondition A valid directory handle must be obtained before reading a directory ",
							" Parameters Param Description handle directory handle obtained during directory open ",
							" Returns SYS_FS_RES_SUCCESS - Directory rewind operation was successful SYS_FS_RES_FAILURE - Directory rewind operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_HANDLE dirHandle ; SYS_FS_FSTAT stat ; dirHandle =  SYS_FS_DirOpen ( \"/mnt/myDrive/Dir1\" ) ;  if ( dirHandle = SYS_FS_HANDLE_INVALID )  {  // Directory open is successful  }  if ( SYS_FS_DirRead ( dirHandle    stat )  == SYS_FS_RES_FAILURE )  {  // Directory read operation failed  }  // Do more search  // Do some more search  // Now rewind the directory to begin search from start  if ( SYS_FS_DirRewind ( dirHandle )  == SYS_FS_RES_FAILURE )  {  // Directory rewind failed  } ",
							" Remarks None ",
							" SYS_FS_DirSearch Function ",
							" C SYS_FS_RESULT SYS_FS_DirSearch ( SYS_FS_HANDLE handle   const  char  * name  SYS_FS_FILE_DIR_ATTR attr  SYS_FS_FSTAT * stat ) ; ",
							" Summary Searches for a file or directory ",
							" Description This function searches for the requested file or directory The file or directory is specified in the attr parameter which is of type SYS_FS_FILE_DIR_ATTR The file system supports 8 3 file name(Short File Name) and also long file name 8 3 filenames are limited to at most eight characters followed optionally by a filename extension consisting of a period and at most three further characters If the file name fits within the 8 3 limits then generally there will be no valid LFN for it For FAT File system If LFN is used the stat structure's altname field will contain the short file name and fname will contain the long file name The \"lfname\" member of the SYS_FS_FSTAT is not applicable for FAT It has to be initialized to NULL before calling the API If \"lfname\" is not NULL then first byte of lfname will be set to zero indicating no file found For other File systems based on thier implementation -If LFN is used then the \"lfname\" member of the SYS_FS_FSTAT structure should be initialized with the address of a suitable buffer and the \"lfsize\" should be initialized with the size of the buffer Once the function returns the buffer whose address is held in \"lfname\" will have the file name(long file name) The stat structure's fname field will contain the SFN and if there is a valid LFN entry for the file then the long file name will be copied into lfname member of the structure ",
							" Precondition A valid directory handle must be obtained before searching the directory ",
							" Parameters Param Description handle directory handle obtained during directory open name name of file or directory needed to be searched The file name can have wild card entries as follows: * Indicates the rest of the filename or extension can vary (e g FILE *)  Indicates that one character in a filename can vary (e g F LE T T) attr Attribute of the name of type SYS_FS_FILE_DIR_ATTR This attribute specifies whether to search a file or a directory Other attribute types could also be specified stat Pointer to SYS_FS_FSTAT where the properties of the directory/file will be populated after the SYS_FS_DirSearch function returns successfully ",
							" Returns SYS_FS_RES_SUCCESS - Indicates that the file or directory was found The stat parameter will contain information about the file or directory SYS_FS_RES_FAILURE - Indicates that the file or directory was not found The reason for the failure can be retrieved with SYS_FS_Error or SYS_FS_FileError ",
							" Example SYS_FS_HANDLE dirHandle ; SYS_FS_FSTAT stat ; dirHandle =  SYS_FS_DirOpen ( \"/mnt/myDrive/Dir1\" ) ;  if ( dirHandle = SYS_FS_HANDLE_INVALID )  {  // Directory open is successful  }  if ( SYS_FS_DirSearch ( dirHandle   \"FIL* *\"  SYS_FS_ATTR_ARC    stat )  == SYS_FS_RES_FAILURE )  {  // Specified file not found or reached end of directory  }  else  {  // File found Read the complete file name from \"stat fname\" or \"stat lfname\" and  // other file parameters from the \"stat\" structure  } ",
							" Remarks None ",
							" SYS_FS_DirectoryMake Function ",
							" C SYS_FS_RESULT SYS_FS_DirectoryMake (  const  char * path ) ; ",
							" Summary Creates a directory ",
							" Description This function creates a new directory as per the specified path ",
							" Precondition The disk has to be mounted before a directory could be made ",
							" Parameters Param Description path Path of the new directory ",
							" Returns SYS_FS_RES_SUCCESS - Indicates that the creation of the directory was successful SYS_FS_RES_FAILURE - Indicates that the creation of the directory was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_RESULT res ; res =  SYS_FS_DirectoryMake ( \"/mnt/mydrive/Dir1\" ) ;  if ( res == SYS_FS_RES_FAILURE )  {  // Directory make failed  }  ",
							" Remarks None ",
							" SYS_FS_DirectoryChange Function ",
							" C SYS_FS_RESULT SYS_FS_DirectoryChange (  const  char * path ) ; ",
							" Summary Changes to a the directory specified ",
							" Description This function changes the present directory to a new directory ",
							" Precondition The disk has to be mounted and the directory to be changed must exist ",
							" Parameters Param Description path Path of the directory to be changed to ",
							" Returns SYS_FS_RES_SUCCESS - Indicates that the directory change operation was successful SYS_FS_RES_FAILURE - Indicates that the directory change operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_RESULT res ; res =  SYS_FS_DirectoryChange ( \"Dir1\" ) ;  if ( res == SYS_FS_RES_FAILURE )  {  // Directory change failed  }  ",
							" Remarks None ",
							" SYS_FS_CurrentWorkingDirectoryGet Function ",
							" C SYS_FS_RESULT SYS_FS_CurrentWorkingDirectoryGet (  char  * buff  uint32_t len ) ; ",
							" Summary Gets the current working directory ",
							" Description This function gets the current working directory path along with the working drive ",
							" Precondition At least one disk must be mounted ",
							" Parameters Param Description buff Pointer to a buffer which will contain the name of the current working directory and drive once the function completes len Size of the buffer ",
							" Returns SYS_FS_RES_SUCCESS - Get current working directory operation was successful SYS_FS_RES_FAILURE - Get current working directory operation was unsucessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_RESULT res ;  char buffer [ 16 ] ;  switch ( appState )  {  case TRY_MOUNT :  {  if ( SYS_FS_Mount ( \"/dev/mmcblka1\"   \"/mnt/myDrive\"  FAT   0   NULL )  = SYS_FS_RES_SUCCESS )  {  // Failure try mounting again  }  else  {  // Mount was successful Create a directory appState = CREATE_DIR ;  }  break ;  }  case CREATE_DIR :  { res =  SYS_FS_DirectoryMake ( \"Dir1\" ) ;  if ( res == SYS_FS_RES_FAILURE )  {  // Directory creation failed appState = ERROR ;  }  else  {  // Directory creation was successful Change to the new  // directory appState = CHANGE_DIR ;  }  break ;  }  case CHANGE_DIR :  { res =  SYS_FS_DirectoryChange ( \"Dir1\" ) ;  if ( res == SYS_FS_RES_FAILURE )  {  // Directory change failed appState = ERROR ;  }  else  {  // Directory change was successful Get current working  // directory appState = GET_CWD ;  }  break ;  }  case GET_CWD :  { res =  SYS_FS_CurrentWorkingDirectoryGet ( buffer   15 ) ;  if ( res == SYS_FS_RES_FAILURE )  {  // Get current directory operation failed appState = ERROR ;  }  break ;  }  }  ",
							" Remarks None ",
							" SYS_FS_FileDirectoryRemove Function ",
							" C SYS_FS_RESULT SYS_FS_FileDirectoryRemove (  const  char * path ) ; ",
							" Summary Removes a file or directory ",
							" Description This function removes a file or directory as specified by the path ",
							" Precondition The disk has to be mounted before a directory could be removed The file or directory to be removed has to present The file/sub-directory must not have read-only attribute (AM_RDO) or the function will be rejected with FR_DENIED The sub-directory must be empty and must not be current directory or the function will be rejected with FR_DENIED The file/sub-directory must not be opened ",
							" Parameters Param Description path Path of the File or directory to be removed ",
							" Returns SYS_FS_RES_SUCCESS - Indicates that the file or directory remove operation was successful SYS_FS_RES_FAILURE - Indicates that the file or directory remove operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_RESULT res ; res =  SYS_FS_FileDirectoryRemove ( \"Dir1\" ) ;  if ( res == SYS_FS_RES_FAILURE )  {  // Directory remove operation failed  } ",
							" Remarks None ",
							" SYS_FS_FileDirectoryRenameMove Function ",
							" C SYS_FS_RESULT SYS_FS_FileDirectoryRenameMove (  const  char  * oldPath   const  char  * newPath ) ; ",
							" Summary Renames or moves a file or directory ",
							" Description This function renames or moves a file or directory ",
							" Precondition The file or directory to be renamed or moved must exist This function cannot move files or directories from one drive to another Do not rename or move files that are open ",
							" Parameters Param Description oldPath Path for the file/directory which has to be renamed/moved newPath New Path for the file/directory ",
							" Returns SYS_FS_RES_SUCCESS - Rename/move operation was successful SYS_FS_RES_FAILURE - Rename/move operation was unsucessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_RESULT res ;  // rename \"file txt\" to \"renamed_file txt\" res =  SYS_FS_FileDirectoryRenameMove ( \"file txt\"   \"renamed_file txt\" ) ;  if ( res = SYS_FS_RES_SUCCESS )  {  // Rename operation failed  }  // Now move \"renamed_file txt\" inside directory \"Dir1\" res =  SYS_FS_FileDirectoryRenameMove ( \"renamed_file txt\"   \"Dir1/renamed_file txt\" ) ;  if ( res = SYS_FS_RES_SUCCESS )  {  // File move operation failed  } ",
							" Remarks This function cannot move files/ directory from one drive to another Do not rename/ move files which are open ",
							" SYS_FS_FileDirectoryModeSet Function ",
							" C SYS_FS_RESULT SYS_FS_FileDirectoryModeSet (  const  char * path  SYS_FS_FILE_DIR_ATTR attr  SYS_FS_FILE_DIR_ATTR mask ) ; ",
							" Summary Sets the mode for the file or directory ",
							" Description This function sets the mode for a file or directory from the specified list of attributes ",
							" Precondition The file or directory for which the mode is to be set must exist ",
							" Parameters Param Description path Path for the file/directory for which the mode is to be set attr Attribute flags to be set in one or more combination of the type SYS_FS_FILE_DIR_ATTR The specified flags are set and others are cleared mask Attribute mask of type SYS_FS_FILE_DIR_ATTR that specifies which attribute is changed The specified attributes are set or cleared ",
							" Returns SYS_FS_RES_SUCCESS - Mode set operation was successful SYS_FS_RES_FAILURE - Mode set operation was unsucessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example // Set read-only flag clear archive flag and others are retained  SYS_FS_FileDirectoryModeSet ( \"file txt\"  SYS_FS_ATTR_RDO  SYS_FS_ATTR_RDO | SYS_FS_ATTR_ARC ) ; ",
							" Remarks None ",
							" SYS_FS_FileDirectoryTimeSet Function ",
							" C SYS_FS_RESULT SYS_FS_FileDirectoryTimeSet (  const  char * path  SYS_FS_TIME * time ) ; ",
							" Summary Sets or changes the time for a file or directory ",
							" Description This function sets or change the time for a file or directory ",
							" Precondition The file/directory for which time is to be set must exist ",
							" Parameters Param Description path A path for the file/directory for which the time is to be set ptr Pointer to the structure of type SYS_FS_TIME which contains the time data to be set ",
							" Returns SYS_FS_RES_SUCCESS - Set time operation was successful SYS_FS_RES_FAILURE - Set time operation was unsucessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example void  setTime ( void )  { SYS_FS_RESULT res ; SYS_FS_TIME time ; time  packedTime =  0 ;  // All FAT FS times are calculated based on 0 = 1980 time  discreteTime  year =  ( 2021  -  1980 ) ;  // Year is 2021 time  discreteTime  month =  8 ;  // Month (August) time  discreteTime  day =  9 ;  // Day (9) time  discreteTime  hour =  15 ;  // 3 PM time  discreteTime  minute =  06 ;  // 06 minutes time  discreteTime  second =  00 ;  // 00 seconds res =  SYS_FS_FileDirectoryTimeSet ( \"file txt\"    time ) ;  if ( res = SYS_FS_RES_SUCCESS )  {  // time change has gone wrong  }  } ",
							" Remarks None ",
							" SYS_FS_CurrentDriveGet Function ",
							" C SYS_FS_RESULT SYS_FS_CurrentDriveGet (  char * buffer ) ; ",
							" Summary Gets the current drive ",
							" Description This function gets the present drive being used The drive information is populated in the buffer ",
							" Precondition The disk has to be mounted ",
							" Parameters Param Description buffer Pointer to buffer which will hold the name of present drive being used ",
							" Returns SYS_FS_RES_SUCCESS - Current drive get operation was successful SYS_FS_RES_FAILURE - Current drive get operation was unsucessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_RESULT res ;  char buffer [ 255 ] ; res =  SYS_FS_CurrentDriveGet ( buffer ) ;  if ( res == SYS_FS_RES_FAILURE )  {  // Operation failed  } ",
							" Remarks None ",
							" SYS_FS_CurrentDriveSet Function ",
							" C SYS_FS_RESULT SYS_FS_CurrentDriveSet (  const  char * path ) ; ",
							" Summary Sets the drive ",
							" Description This function sets the present drive to the one as specified by the path By default the drive mounted last becomes the current drive for the system This is useful for applications where only one drive (volume) is used In such an application there is no need to call the SYS_FS_CurrentDriveSet function However in the case of an application where there are multiple volumes the user can select the current drive for the application by calling this function ",
							" Precondition The disk has to be mounted ",
							" Parameters Param Description path Path for the drive to be set ",
							" Returns SYS_FS_RES_SUCCESS - Current drive set operation was successful SYS_FS_RES_FAILURE - Current drive set operation was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_RESULT res ; res =  SYS_FS_CurrentDriveSet ( \"/mnt/myDrive\" ) ;  if ( res == SYS_FS_RES_FAILURE )  {  // Drive change failed  } ",
							" Remarks None ",
							" SYS_FS_DriveLabelGet Function ",
							" C SYS_FS_RESULT SYS_FS_DriveLabelGet (  const  char * drive   char  * buff  uint32_t * sn ) ; ",
							" Summary Gets the drive label ",
							" Description This function gets the label for the drive specified If no drive is specified the label for the current drive is obtained ",
							" Precondition At least one disk must be mounted ",
							" Parameters Param Description drive Pointer to buffer which will hold the name of drive being for which the label is requested If this string is NULL then then label of the current drive is obtained by using this function buff Buffer which will hold the string of label sn Serial number of the drive If this information is not needed it can be set as NULL ",
							" Returns SYS_FS_RES_SUCCESS - Drive label information retrieval was successful SYS_FS_RES_FAILURE - Drive label information retrieval was unsucessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_RESULT res ;  char buffer [ 255 ] ; uint32_t serialNo ;  switch ( appState )  {  case TRY_MOUNT :  {  if ( SYS_FS_Mount ( \"/dev/mmcblka1\"   \"/mnt/myDrive\"  FAT   0   NULL )  = SYS_FS_RES_SUCCESS )  {  // Failure try mounting again  }  else  {  // Mount was successful Get label now appState = GET_LABEL ;  }  break ;  }  case GET_LABEL :  { res =  SYS_FS_DriveLabelGet ( \"/mnt/myDrive\"  buffer    serialNo ) ;  if ( res == SYS_FS_RES_FAILURE )  {  // Fetching drive label information failed  }  break ;  }  } ",
							" Remarks None ",
							" SYS_FS_DriveLabelSet Function ",
							" C SYS_FS_RESULT SYS_FS_DriveLabelSet (  const  char * drive   const  char  * label ) ; ",
							" Summary Sets the drive label ",
							" Description This function sets the label for the drive specified If no drive is specified the label for the current drive is set ",
							" Precondition At least one disk must be mounted ",
							" Parameters Param Description drive Pointer to string that holds the name of drive being for which the label is to be set If this string is NULL the label of the current drive is set by using this function label Pointer to string which contains the label to be set ",
							" Returns SYS_FS_RES_SUCCESS - Drive label set operation was successful SYS_FS_RES_FAILURE - Drive label set operation was unsucessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_RESULT res ;  switch ( appState )  {  case TRY_MOUNT :  {  if ( SYS_FS_Mount ( \"/dev/mmcblka1\"   \"/mnt/myDrive\"  FAT   0   NULL )  = SYS_FS_RES_SUCCESS )  {  // Failure try mounting again  }  else  {  // Mount was successful Get label now appState = SET_LABEL ;  }  break ;  }  case SET_LABEL :  { res =  SYS_FS_DriveLabelSet ( \"/mnt/myDrive\"   \"MY_LABEL\" ) ;  if ( res == SYS_FS_RES_FAILURE )  {  // Drive label get failed  }  break ;  }  } ",
							" Remarks None ",
							" SYS_FS_DriveFormat Function ",
							" C SYS_FS_RESULT SYS_FS_DriveFormat (  const  char  * drive   const SYS_FS_FORMAT_PARAM * opt   void * work  uint32_t len ) ; ",
							" Summary Formats a drive ",
							" Description This function formats a logic drive (create a FAT file system on the logical drive) as per the format specified If the logical drive that has to be formatted has been bound to any partition (1-4) by multiple partition feature the FAT volume is created into the specified partition The physical drive must have been partitioned prior to using this function ",
							" Precondition At least one disk must be mounted The physical drive must have already been partitioned ",
							" Parameters Param Description drive Pointer to buffer which will hold the name of drive being for which the format is to be done If this string is NULL then then current drive will be formatted It is important to end the drive name with a \"/\" opt Specifies the structure holding format options If a null pointer is given fat code gives the function all options in default value work Pointer to the working buffer used for the format process len Size of the working buffer in unit of byte It needs to be the sector size of the corresponding physical drive at least Plenty of working buffer reduces number of write transactions to the drive and the format process will finish quickly ",
							" Returns SYS_FS_RES_SUCCESS - Drive format was successful SYS_FS_RES_FAILURE - Drive format was unsucessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example SYS_FS_RESULT res ; SYS_FS_FORMAT_PARAM opt =  {  0  } ; uint8_t CACHE_ALIGN work [ 512 ] ;  switch ( appState )  {  case TRY_MOUNT :  {  if ( SYS_FS_Mount ( \"/dev/mmcblka1\"   \"/mnt/myDrive\"  FAT   0   NULL )  = SYS_FS_RES_SUCCESS )  {  // Failure try mounting again  }  else  {  // Mount was successful Format now  if  ( SYS_FS_Error ( )  == SYS_FS_ERROR_NO_FILESYSTEM )  { appState = FORMAT_DRIVE ;  }  else  { appState = OTHER_TASK ;  }  }  break ;  }  case FORMAT_DRIVE :  { opt  fmt = SYS_FS_FORMAT_FAT ; opt  au_size =  0 ; res =  SYS_FS_DriveFormat ( \"/mnt/myDrive\"    opt   ( void  * ) work   512 ) ;  if ( res == SYS_FS_RES_FAILURE )  {  // Format of the drive failed  }  break ;  }  } ",
							" Remarks None ",
							" SYS_FS_DrivePartition Function ",
							" C SYS_FS_RESULT SYS_FS_DrivePartition (  const  char  * path   const uint32_t partition [ ]   void  * work ) ; ",
							" Summary Partitions a physical drive (media) ",
							" Description This function partitions a physical drive (media) into requested partition sizes This function will alter the MBR of the physical drive and make it into multi partitions Windows operating systems do not support multi partitioned removable media Maximum 4 partitions can be created on a media ",
							" Precondition Prior to partitioning the media the media should have a valid MBR and it should be mounted as a volume with the file system ",
							" Parameters Param Description path Path to the volume with the volume name The string of volume name has to be preceded by \"/mnt/\" Also the volume name and directory name has to be separated by a slash \"/\" partition Array with 4 items where each items mentions the sizes of each partition in terms of number of sector 0th element of array specifies the number of sectors for first partition and 3rd element of array specifies the number of sectors for fourth partition work Pointer to the buffer for function work area The size must be at least FAT_FS_MAX_SS bytes ",
							" Returns SYS_FS_RES_SUCCESS - Partition was successful SYS_FS_RES_FAILURE - Partition was unsuccessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example //============================================================================  // Initially consider the case of a SD card that has only one partition  //============================================================================ SYS_FS_RESULT res ;  // Following 4 element array specifies the size of 2 partitions as  // 256MB (=524288 sectors) The 3rd and 4th partition are not created  // since the sizes of those are zero uint32_t plist [ ]  =  { 524288   524288   0   0 } ;  // Work area for function SYS_FS_DrivePartition  char work [ FAT_FS_MAX_SS ] ;  switch ( appState )  {  case TRY_MOUNT :  {  if ( SYS_FS_Mount ( \"/dev/mmcblka1\"   \"/mnt/myDrive\"  FAT   0   NULL )  = SYS_FS_RES_SUCCESS )  {  // Failure try mounting again  }  else  {  // Mount was successful Partition now appState = PARTITION_DRIVE ;  }  break ;  }  case PARTITION_DRIVE :  { res =  SYS_FS_DrivePartition ( \"/mnt/myDrive\"  plist  work ) ;  if ( res == SYS_FS_RES_FAILURE )  {  // Drive partition went wrong  }  else  {  // Partition was successful Power cycle the board so that  // all partitions are recognized Then try mounting both  // partitions  }  break ;  }  default :  {  break ;  }  }  //============================================================================  //The following code is after the SD card is partitioned and then  //powered ON  //============================================================================ SYS_FS_RESULT res ;  switch ( appState )  {  case TRY_MOUNT_1ST_PARTITION :  {  if ( SYS_FS_Mount ( \"/dev/mmcblka1\"   \"/mnt/myDrive1\"  FAT   0   NULL )  = SYS_FS_RES_SUCCESS )  {  // Failure try mounting again appState = TRY_MOUNT_1ST_PARTITION ;  }  else  {  // Mount was successful Mount second partition appState = TRY_MOUNT_2ND_PARTITION ;  }  break ;  }  case TRY_MOUNT_2ND_PARTITION :  {  if ( SYS_FS_Mount ( \"/dev/mmcblka2\"   \"/mnt/myDrive2\"  FAT   0   NULL )  = SYS_FS_RES_SUCCESS )  {  // Failure try mounting again appState = TRY_MOUNT_2ND_PARTITION ;  }  else  {  // Mount was successful Try formating first partition appState = TRY_FORMATING_1ST_PARTITION ;  }  break ;  }  case TRY_FORMATING_1ST_PARTITION :  {  if ( SYS_FS_DriveFormat ( \"/mnt/myDrive1/\"  SYS_FS_FORMAT_FDISK   0 )  == SYS_FS_RES_FAILURE )  {  // Failure  }  else  {  // Try formating second partitions appState = TRY_FORMATING_2ND_PARTITION ;  }  break ;  }  case TRY_FORMATING_2ND_PARTITION :  {  if ( SYS_FS_DriveFormat ( \"/mnt/myDrive2/\"  SYS_FS_FORMAT_FDISK   0 )  == SYS_FS_RES_FAILURE )  {  // Failure  }  else  {  // Use both partitions as 2 separate volumes  }  break ;  }  default :  {  break ;  }  } ",
							" Remarks None ",
							" SYS_FS_DriveSectorGet Function ",
							" C SYS_FS_RESULT SYS_FS_DriveSectorGet (  const  char * path  uint32_t * totalSectors  uint32_t * freeSectors ) ; ",
							" Summary Obtains total number of sectors and number of free sectors for the specified drive ",
							" Description Function to obtain the total number of sectors and number of free sectors in a drive (media) ",
							" Precondition The drive for which the information is to be retrieved should be mounted ",
							" Parameters Param Description path Path to the volume with the volume name The string of volume name must be preceded by \"/mnt/\" Also the volume name and directory name must be separated by a slash \"/\" totalSectors Pointer to a variable passed to the function which will contain the total number of sectors available in the drive (media) freeSectors Pointer to a variable passed to the function which will contain the free number of sectors available in the drive (media) ",
							" Returns SYS_FS_RES_SUCCESS - Sector information get operation was successful SYS_FS_RES_FAILURE - Sector information get operation was unsucessful The reason for the failure can be retrieved with SYS_FS_Error ",
							" Example uint32_t totalSectors  freeSectors ; SYS_FS_RESULT res ;  if ( SYS_FS_Mount ( \"/dev/mmcblka1\"   \"/mnt/myDrive\"  FAT   0   NULL )  = SYS_FS_RES_SUCCESS )  {  // Failure try mounting again  }  else  {  // Mount was successful  // Do other FS stuffs  }  // Perform usual FS tasks  //  //  // Now determine the total sectors and free sectors res =  SYS_FS_DriveSectorGet ( \"/mnt/myDrive\"    totalSectors    freeSectors ) ;  if ( res == SYS_FS_RES_FAILURE )  {  //Sector information get operation failed  } ",
							" Remarks None ",
							" SYS_FS_HANDLE Typedef ",
							" C typedef uintptr_t SYS_FS_HANDLE ; ",
							" Summary This type defines the file handle ",
							" Description This type defines the file handle File handle is returned by the File Open function ",
							" Remarks None ",
							" SYS_FS_HANDLE_INVALID Macro ",
							" C # define SYS_FS_HANDLE_INVALID ((SYS_FS_HANDLE)(-1)) ",
							" Summary Invalid file handle ",
							" Description This value defines the invalid file handle Invalid file handle is returned on an unsuccessful File Open operation ",
							" Remarks None ",
							" SYS_FS_FILE_SYSTEM_TYPE Enum ",
							" C typedef  enum  {  /* Unsupported File System */ UNSUPPORTED_FS =  0   /* FAT FS native File system */ FAT   /* MPFS2 native File system */ MPFS2   /* LittleFS native File system */ LITTLEFS } SYS_FS_FILE_SYSTEM_TYPE ;  ",
							" Summary Enumerated data type identifying native file systems supported ",
							" Description These enumerated values identify the native file system supported by the SYS FS ",
							" Remarks None ",
							" SYS_FS_FILE_DIR_ATTR Enum ",
							" C typedef  enum  {  /* Normal File Should not be combined with other attributes */ SYS_FS_ATTR_FILE =  0x00   /* Read only */ SYS_FS_ATTR_RDO =  0x01   /* Hidden */ SYS_FS_ATTR_HID =  0x02   /* System */ SYS_FS_ATTR_SYS =  0x04   /* Volume label */ SYS_FS_ATTR_VOL =  0x08   /* LFN entry */ SYS_FS_ATTR_LFN =  0x0F   /* Directory */ SYS_FS_ATTR_DIR =  0x10   /* Archive */ SYS_FS_ATTR_ARC =  0x20   /* Mask of defined bits */ SYS_FS_ATTR_MASK =  0x3F  } SYS_FS_FILE_DIR_ATTR ;  ",
							" Summary Enumerated data type identifying the various attributes for file/directory ",
							" Description These enumerated values are the possible attributes for a file or directory ",
							" Remarks None ",
							" SYS_FS_FILE_SEEK_CONTROL Enum ",
							" C typedef  enum  {  /* Set file offset to input number of bytes from the start of file */ SYS_FS_SEEK_SET   /* Set file offset to its current location plus input number of bytes */ SYS_FS_SEEK_CUR   /* Set file offset to size of the file plus input number of bytes */ SYS_FS_SEEK_END   } SYS_FS_FILE_SEEK_CONTROL ;  ",
							" Summary Lists the various modes of file seek ",
							" Description This enumeration lists the various modes of file seek When the application calls the SYS_FS_FileSeek function it specifies the kind of seek that needs to be performed ",
							" Remarks None ",
							" SYS_FS_RESULT Enum ",
							" C typedef  enum  {  /* Operation succeeded */ SYS_FS_RES_SUCCESS =  0   /* Operation failed */ SYS_FS_RES_FAILURE =  - 1  } SYS_FS_RESULT ;  ",
							" Summary Lists the various results of a file operation ",
							" Description This enumeration lists the various results of a file operation When a file operation function is called from the application and if the return type of the function is SYS_FS_RESULT then the enumeration below specifies the possible values returned by the function ",
							" Remarks None ",
							" SYS_FS_FORMAT Macros ",
							" C // The Values mentioned below should be aligned with values in ff h  # define SYS_FS_FORMAT_FAT 0x01  # define SYS_FS_FORMAT_FAT32 0x02  # define SYS_FS_FORMAT_EXFAT 0x04  # define SYS_FS_FORMAT_ANY 0x07  # define SYS_FS_FORMAT_SFD 0x08 ",
							" Summary Specifes the partitioning rule ",
							" Description This type specifies the partitioning rule When SYS_FS_FORMAT_FAT is specified a primary partition occupying the entire disk space is created and then an FAT volume is created on the partition It is usually used for hard disk MMC SDC CFC and U Disk It can divide a physical drive into one or more partitions with a partition table on the MBR However Windows does not support multiple partition on the removable media When SYS_FS_FORMAT_SFD format is specified the FAT volume starts from the first sector of the physical drive It is non-partitioned method The FAT volume starts from the first sector on the physical drive without partition table It is usually used for floppy disk micro drive optical disk and super-floppy media When SYS_FS_FORMAT_ANY format is specified FAT FS code decides on the format ",
							" SYS_FS_FORMAT_PARAM Struct ",
							" C typedef  struct  {  /* Specifies combination of FAT type flags SYS_FS_FORMAT_XXX * These flags specify which FAT type to be created on the volume * If two or more types are specified one out of them will be * selected depends on the volume size and au_size * The default value is FM_ANY */ uint8_t fmt ;  /* Specifies number of FAT copies on the FAT/FAT32 volume * Valid value for this member is 1 or 2 If the FAT type is exFAT * this member has no effect */ uint8_t n_fat ;  /* Specifies alignment of the volume data area (file allocation pool * usually erase block boundary of flash media) in unit of sector * When a zero is given alignment is decided on the block size */ uint32_t align ;  /* Specifies number of root directory entries on the FAT volume * Valid value for this member is up to 32768 and aligned to * sector size / 32 If the FAT type is FAT32 or exFAT this member * has no effect */ uint32_t n_root ;  /* Specifies size of the allocation unit (cluster) in unit of byte * The valid value is power of 2 between sector size and * 128 * sector size inclusive for FAT/FAT32 volume and up to 16 MB * When a zero is given the cluster size depends on the volume size */ uint32_t au_size ;  } SYS_FS_FORMAT_PARAM ;  ",
							" Summary SYS FS Drive Format parameter structure ",
							" Description Specifies the structure holding format options This structure has to be filled and passed to SYS_FS_DriveFormat() API ",
							" Remarks None ",
							" SYS_FS_FILE_OPEN_ATTRIBUTES Enum ",
							" C typedef  enum  {  /* reading the file = possible if file exists reading the file = file open returns error if file does not exist writing to the file = not possible Write operation returns error */ SYS_FS_FILE_OPEN_READ =  0   /* reading the file = not possible Read operation returns error writing to the file = possible If file exists write happens from the beginning of the file overwriting the existing content of the file writing to the file = If file does not exist a new file will be created and data will be written into the newly created file */ SYS_FS_FILE_OPEN_WRITE   /* reading the file = not possible Read operation returns error writing to the file = possible If file exists write happens from the end of the file preserving the existing content of the file writing to the file = If file does not exist a new file will be created and data will be written into the newly created file */ SYS_FS_FILE_OPEN_APPEND   /* reading the file = possible if file exists reading the file = file open returns error if file does not exist writing to the file = possible if file exists staring from the beginning of the file (overwriting) writing to the file = file open returns error if file does not exist */ SYS_FS_FILE_OPEN_READ_PLUS   /* reading the file = possible if file exists reading the file = If file does not exist a new file will be created writing to the file = possible If file exists write happens from the beginning of the file overwriting the existing content of the file writing to the file = If file does not exist a new file will be created and data will be written into the newly created file */ SYS_FS_FILE_OPEN_WRITE_PLUS   /* reading the file = possible if file exists File read pointer will be moved to end of the file in this mode reading the file = If file does not exist a new file will be created writing to the file = possible If file exists write happens from the end of the file preserving the existing content of the file writing to the file = If file does not exist a new file will be created and data will be written into the newly created file */ SYS_FS_FILE_OPEN_APPEND_PLUS } SYS_FS_FILE_OPEN_ATTRIBUTES ;  ",
							" Summary Lists the various attributes (modes) in which a file can be opened ",
							" Description This enumeration lists the various attributes (modes) in which a file can be opened ",
							" Remarks None ",
							" SYS_FS_ERROR Enum ",
							" C typedef  enum  {  /* Success */ SYS_FS_ERROR_OK =  0   /* (1) A hard error occurred in the low level disk I/O layer */ SYS_FS_ERROR_DISK_ERR   /* (2) Assertion failed */ SYS_FS_ERROR_INT_ERR   /* (3) The physical drive cannot work */ SYS_FS_ERROR_NOT_READY   /* (4) Could not find the file */ SYS_FS_ERROR_NO_FILE   /* (5) Could not find the path */ SYS_FS_ERROR_NO_PATH   /* (6) The path name format is invalid */ SYS_FS_ERROR_INVALID_NAME   /* (7) Access denied due to prohibited access or directory full */ SYS_FS_ERROR_DENIED   /* (8) Access denied due to prohibited access */ SYS_FS_ERROR_EXIST   /* (9) The file/directory object is invalid */ SYS_FS_ERROR_INVALID_OBJECT   /* (10) The physical drive is write protected */ SYS_FS_ERROR_WRITE_PROTECTED   /* (11) The logical drive number is invalid */ SYS_FS_ERROR_INVALID_DRIVE   /* (12) The volume has no work area */ SYS_FS_ERROR_NOT_ENABLED   /* (13) There is no valid volume */ SYS_FS_ERROR_NO_FILESYSTEM   /* (14) The Format() aborted due to any parameter error */ SYS_FS_ERROR_FORMAT_ABORTED   /* (15) Could not get a grant to access the volume within defined period */ SYS_FS_ERROR_TIMEOUT   /* (16) The operation is rejected according to the file sharing policy */ SYS_FS_ERROR_LOCKED   /* (17) LFN working buffer could not be allocated */ SYS_FS_ERROR_NOT_ENOUGH_CORE   /* (18) Number of open files */ SYS_FS_ERROR_TOO_MANY_OPEN_FILES   /* (19) Given parameter is invalid */ SYS_FS_ERROR_INVALID_PARAMETER   /* (20) Too many mounts requested Not enough free volume available */ SYS_FS_ERROR_NOT_ENOUGH_FREE_VOLUME   /* (21) Requested native file system is not supported */ SYS_FS_ERROR_FS_NOT_SUPPORTED   /* (22) Requested native file system does not match the format of volume */ SYS_FS_ERROR_FS_NOT_MATCH_WITH_VOLUME   /* (23) Function not supported in native file system layer */ SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS   /* Below enumerations constants are generated for littleFS only */  /* (24) Error during device operation*/ SYS_FS_ERROR_IO   /* (25) Corrupted*/ SYS_FS_ERROR_CORRUPT   /* (26) No directory entry*/ SYS_FS_ERROR_NOENT   /* (27) Entry already exists*/ SYS_FS_ERROR_ALREADY_EXIST   /* (28) Entry is not a dir*/ SYS_FS_ERROR_NOTDIR   /* (29) Entry is a dir*/ SYS_FS_ERROR_ISDIR   /* (30) Dir is not empty*/ SYS_FS_ERROR_NOTEMPTY   /* (31) Bad file number*/ SYS_FS_ERROR_BADF   /* (32) File too large*/ SYS_FS_ERROR_FBIG   /* (33) Invalid parameter*/ SYS_FS_ERROR_INVAL   /* (34) No space left on device*/ SYS_FS_ERROR_NOSPC   /* (35) No more memory available*/ SYS_FS_ERROR_NOMEM   /* (36) No data/attr available*/ SYS_FS_ERROR_NOATTR   /* (37) File name too long*/ SYS_FS_ERROR_NAMETOOLONG } SYS_FS_ERROR ;  ",
							" Summary Lists the various error cases ",
							" Description This enumeration lists the various error cases When the application calls for a file system function which has a return type of SYS_FS_RESULT and if the return value is SYS_FS_RES_FAILURE the application can know the specific reason for failure by calling the SYS_FS_FileError function The return value of SYS_FS_FileError function will be one of the enumeration of type SYS_FS_ERROR ",
							" Remarks None ",
							" SYS_FS_EVENT Enum ",
							" C typedef  enum  {  /* Media has been mounted successfully */ SYS_FS_EVENT_MOUNT   /* Media has been mounted successfully * Media has to be formatted as there is no filesystem present */ SYS_FS_EVENT_MOUNT_WITH_NO_FILESYSTEM   /* Media has been unmounted successfully */ SYS_FS_EVENT_UNMOUNT   /* There was an error during the operation */ SYS_FS_EVENT_ERROR } SYS_FS_EVENT ;  ",
							" Summary Identifies the possible file system events ",
							" Description This enumeration identifies the possible events that can result from a file system ",
							" Remarks One of these values is passed in the \"event\" parameter of the event handling callback function that client registered with the file system by setting the event handler when media mount or unmount is completed ",
							" SYS_FS_FUNCTIONS Struct ",
							" C typedef  struct  {  /* Function pointer of native file system for mounting a volume */  int  ( * mount )  ( uint8_t vol ) ;  /* Function pointer of native file system for unmounting a volume */  int  ( * unmount )  ( uint8_t vol ) ;  /* Function pointer of native file system for opening a file */  int  ( * open )  ( uintptr_t handle   const  char * path  uint8_t mode ) ;  /* Function pointer of native file system for reading a file */  int  ( * read )  ( uintptr_t fp   void * buff  uint32_t btr  uint32_t * br ) ;  /* Function pointer of native file system for writing to a file */  int  ( * write )  ( uintptr_t fp   const  void * buff  uint32_t btw  uint32_t * bw ) ;  /* Function pointer of native file system for closing a file */  int  ( * close )  ( uintptr_t fp ) ;  /* Function pointer of native file system for moving the file pointer by a * desired offset */  int  ( * seek )  ( uintptr_t handle  uint32_t offset ) ;  /* Function pointer of native file system for finding the position of the * file pointer */ uint32_t ( * tell )  ( uintptr_t handle ) ;  * reached * / bool ( * eof )  ( uintptr_t handle ) ;  /* Function pointer of native file system to know the size of file */ uint32_t ( * size )  ( uintptr_t handle ) ;  /* Function pointer of native file system to know the status of file */  int  ( * fstat )  ( const  char * path  uintptr_t fno ) ;  /* Function pointer of native file system to create a directory */  int  ( * mkdir ) ( const  char  * path ) ;  /* Function pointer of native file system to change a directory */  int  ( * chdir ) ( const  char  * path ) ;  /* Function pointer of native file system to remove a file or directory */  int  ( * remove ) ( const  char  * path ) ;  /* Function pointer of native file system to get the volume label */  int  ( * getlabel ) ( const  char  * path   char  * buff  uint32_t * sn ) ;  /* Function pointer of native file system to set the volume label */  int  ( * setlabel ) ( const  char  * label ) ;  /* Function pointer of native file system to truncate the file */  int  ( * truncate ) ( uintptr_t handle ) ;  /* Function pointer of native file system to obtain the current working * directory */  int  ( * currWD ) ( char * buff  uint32_t len ) ;  /* Function pointer of native file system to set the current drive */  int ( * chdrive ) ( uint8_t drive ) ;  /* Function pointer of native file system to change the attribute for file * or directory */  int ( * chmode ) ( const  char * path  uint8_t attr  uint8_t mask ) ;  /* Function pointer of native file system to change the time for a file or * directory */  int ( * chtime ) ( const  char * path  uintptr_t ptr ) ;  /* Function pointer of native file system to rename a file or directory */  int ( * rename ) ( const  char  * oldPath   const  char  * newPath ) ;  /* Function pointer of native file system to flush file */  int ( * sync ) ( uintptr_t fp ) ;  /* Function pointer of native file system to read a string from a file */  char  * ( * getstrn ) ( char * buff   int len  uintptr_t handle ) ;  /* Function pointer of native file system to write a character into a file * */  int ( * putchr ) ( char c  uintptr_t handle ) ;  /* Function pointer of native file system to write a string into a file */  int ( * putstrn ) ( const  char * str  uintptr_t handle ) ;  /* Function pointer of native file system to print a formatted string to * file */  int ( * formattedprint ) ( uintptr_t handle   const  char  * str  va_list argList ) ;  /* Function pointer of native file system to test an error in a file */  bool ( * testerror ) ( uintptr_t handle ) ;  /* Function pointer of native file system to format a disk */  int ( * formatDisk ) ( uint8_t vol   const SYS_FS_FORMAT_PARAM * opt   void * work  uint32_t len )  /* Function pointer of native file system to open a directory */  int ( * openDir ) ( uintptr_t handle   const  char  * path ) ;  /* Function pointer of native file system to read a directory */  int ( * readDir ) ( uintptr_t handle  uintptr_t stat ) ;  /* Function pointer of native file system to close an opened directory */  int ( * closeDir ) ( uintptr_t handle ) ;  /* Function pointer of native file system to partition a physical drive */  int ( * partitionDisk ) ( uint8_t pdrv   const uint32_t szt [ ]   void * work ) ;  /* Function pointer of native file system to get total sectors and free * sectors */  int ( * getCluster ) ( const  char  * path  uint32_t * tot_sec  uint32_t * free_sec ) ;  } SYS_FS_FUNCTIONS ;  ",
							" Summary SYS FS Function signature structure for native file systems ",
							" Description The SYS FS layer supports functions from each native file system layer This structure specifies the signature for each function from native file system (parameter that needs to be passed to each function and return type for each function) If a new native file system is to be integrated with the SYS FS layer the functions should follow the signature The structure of function pointer for the supported native file systems is already populated in the initialization c file Hence the following structure is not immediately useful for the user But the explanation for the structure is still provided for advanced users who would wish to integrate a new native file system to the MPLAB Harmony File System framework ",
							" Remarks None ",
							" SYS_FS_REGISTRATION_TABLE Struct ",
							" C typedef  struct  {  /* Native file system of type SYS_FS_FILE_SYSTEM_TYPE */ SYS_FS_FILE_SYSTEM_TYPE nativeFileSystemType ;  /* Pointer to the structure of type SYS_FS_FUNCTIONS which has the list of * function-pointers for the native file system */  const SYS_FS_FUNCTIONS * nativeFileSystemFunctions ;  } SYS_FS_REGISTRATION_TABLE ;  ",
							" Summary The initialization members for File system layer ",
							" Description When the SYS FS layer is initialized it has to know the type of native file system it has to support and the list of functions for native file system The members of this structure can be initialized with suitable values and then passed on to SYS_FS_Initialize initialization function Please refer to the example code provided for SYS_FS_Initialize ",
							" Remarks None ",
							" SYS_FS_FSTAT Struct ",
							" C typedef  struct  {  /* File size */ uint32_t fsize ;  /* Last modified date */ uint16_t fdate ;  /* Last modified time */ uint16_t ftime ;  /* Attribute */ uint8_t fattrib ;  /* Alternate/Short file name (8 3 format) */  char altname [ 13 ] ;  /* Primary/Long file name */  char fname [ SYS_FS_FILE_NAME_LEN +  1 ] ;  /* Retaining below members for portability * For FAT-FS lfname[0] will always be ' 0' * Use fname instead /* Pointer to the LFN buffer */  char  * lfname ;  /* Size of LFN buffer */ uint32_t lfsize ;  } SYS_FS_FSTAT ;  ",
							" Summary File System status ",
							" Description This structure holds the various status of a file The SYS_FS_FileStat () populates the contents of this structure ",
							" Remarks None ",
							" SYS_FS_TIME Union ",
							" C typedef  union  {  struct  discreteTime  {  /* Second / 2 (0 29) */  unsigned second :  5 ;  /* Minute (0 59) */  unsigned minute :  6 ;  /* Hour (0 23) */  unsigned hour :  5 ;  /* Day in month(1 31) */  unsigned day :  5 ;  /* Month (1 12) */  unsigned month :  4 ;  /* Year from 1980 (0 127) */  unsigned year :  7 ;  } discreteTime ;  struct  timeDate  {  /* Time (hour min seconds) */ uint16_t time ;  /* Date (year month day) */ uint16_t date ;  } timeDate ;  /* Combined time information in a 32-bit value */ uint32_t packedTime ;  } SYS_FS_TIME ;  ",
							" Summary The structure to specify the time for a file or directory ",
							" Description This structure holds the date and time to be used to set for a file or directory bits 31-25: Year from 1980 (0 127) bits 24-21: Month (1 12) bits 20-16: Day in month(1 31) bits 15-11: Hour (0 23) bits 10-5 : Minute (0 59) bits 4-0 : Seconds / 2 (0 29) ",
							" Remarks None ",
							" SYS_FS_EVENT_HANDLER Typedef ",
							" C typedef  void  ( * SYS_FS_EVENT_HANDLER )  ( SYS_FS_EVENT event   void * eventData  uintptr_t context ) ; ",
							" Summary Pointer to the File system Handler function ",
							" Description This data type defines the required function signature for the file system event handling callback function A client must register a pointer to an event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive event call backs from the file system ",
							" Parameters Param Description event Identifies the type of event eventData Handle returned from the media operation requests context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Remarks None ",
							" SYS_FS_MEDIA_MANAGER_AddressGet Function ",
							" C uintptr_t SYS_FS_MEDIA_MANAGER_AddressGet ( uint16_t diskNo ) ; ",
							" Summary Gets the starting media address based on a disk number ",
							" Description This function gets the starting address of a media This function is intended to work only with MPFS2 which does byte addressing and needs a memory address (not disk number) ",
							" Precondition None ",
							" Parameters Param Description diskNo media number ",
							" Returns Memory address of type uintptr_t ",
							" SYS_FS_MEDIA_MANAGER_CommandStatusGet Function ",
							" C SYS_FS_MEDIA_COMMAND_STATUS SYS_FS_MEDIA_MANAGER_CommandStatusGet ( uint16_t diskNo  SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE bufferHandle ) ",
							" Summary Gets the command status ",
							" Description This function gets the command status The sector read and sector write are non-blocking functions Therefore this interface is provided where the code should periodically poll for the buffer status If status is completed the read/write operation is considered to be complete ",
							" Precondition None ",
							" Parameters Param Description diskNo media number bufferHandle the command handle which was obtained during sector read/ write ",
							" Returns Command status of type SYS_FS_MEDIA_COMMAND_STATUS ",
							" SYS_FS_MEDIA_MANAGER_Register Function ",
							" C SYS_FS_MEDIA_HANDLE SYS_FS_MEDIA_MANAGER_Register ( SYS_MODULE_OBJ obj  SYS_MODULE_INDEX index   const SYS_FS_MEDIA_FUNCTIONS * mediaFunctions  SYS_FS_MEDIA_TYPE mediaType ) ",
							" Summary Function to register media drivers with the media manager ",
							" Description This function is called by the media driver to register the functionalities with the media manager For static media such as NVM or a SD card the media drivers register with this function at the time of initialization For dynamic media such as MSD this register function is called dynamically once the MSD media is connected ",
							" Precondition None ",
							" Parameters Param Description obj driver object (of type SYS_MODULE_OBJ value returned when driver is initialized) index driver index (of type SYS_MODULE_INDEX value passed during driver initialization and opening) mediaFunctions List of media driver functions mediaType Type of media ",
							" Returns Valid handle of type SYS_FS_MEDIA_HANDLE on successful registration of the media driver Invalid handle of type SYS_FS_MEDIA_HANDLE_INVALID on unsuccessful registration of the media driver ",
							" Remarks None ",
							" SYS_FS_MEDIA_MANAGER_DeRegister Function ",
							" C void SYS_FS_MEDIA_MANAGER_DeRegister ( SYS_FS_MEDIA_HANDLE handle ) ",
							" Summary Function to De-register media drivers with the media manager ",
							" Description Function called by a media to deregister itself to the media manager For static media (like NVM or SD card) this \"deregister function\" is never called since static media never gets deregistered once they are initialized For dynamic media (like MSD) this register function is called dynamically once the MSD media is connected ",
							" Precondition None ",
							" Parameters Param Description handle Handle of type SYS_FS_MEDIA_HANDLE received when the media was registered ",
							" Returns None ",
							" SYS_FS_MEDIA_MANAGER_Read Function ",
							" C SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE SYS_FS_MEDIA_MANAGER_Read ( uint16_t diskNo  uint8_t * destination  uint8_t * source   const  unsigned  int nBytes ) ; ",
							" Summary Gets data from a specific media address ",
							" Description This function gets data from a specific address of media This function is intended to work with NVM media only which can have byte level addressing For other media such as a SD card byte addressing is not possible and this function will not work Also this function is intended to work with the MPFS2 file system only which uses byte addressing ",
							" Precondition None ",
							" Parameters Param Description diskNo media number destination pointer to buffer where data to be placed after read source pointer from where data to be read nBytes Number of bytes to be read ",
							" Returns Buffer handle of type SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE ",
							" SYS_FS_MEDIA_MANAGER_SectorRead Function ",
							" C SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE SYS_FS_MEDIA_MANAGER_SectorRead ( uint16_t diskNo  uint8_t * dataBuffer  uint32_t sector  uint32_t noSectors ) ; ",
							" Summary Reads a specified media sector ",
							" Description This function reads a specified media (disk) sector This is the function in the media manager layer This function in turn calls the specific sector read function from the list of function pointers of the media driver ",
							" Precondition None ",
							" Parameters Param Description diskNo Media number dataBuffer Pointer to buffer where data to be placed after read sector Sector numer to be read noSectors Number of sectors to read ",
							" Returns Buffer handle of type SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE ",
							" SYS_FS_MEDIA_MANAGER_SectorWrite Function ",
							" C SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE SYS_FS_MEDIA_MANAGER_SectorWrite ( uint16_t diskNo  uint32_t sector  uint8_t * dataBuffer  uint32_t noSectors ) ; ",
							" Summary Writes a sector to the specified media ",
							" Description This function writes to a sector of the specified media (disk) This is the function in the media manager layer This function in turn calls the specific sector write function from the list of function pointers of the media driver ",
							" Precondition None ",
							" Parameters Param Description diskNo media number sector Sector # to which data to be written dataBuffer pointer to buffer which holds the data to be written noSectors Number of sectors to be written ",
							" Returns Buffer handle of type SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE ",
							" SYS_FS_MEDIA_MANAGER_VolumePropertyGet Function ",
							" C bool SYS_FS_MEDIA_MANAGER_VolumePropertyGet (  const  char  * devName SYS_FS_VOLUME_PROPERTY * str ) ; ",
							" Summary Gets the volume property ",
							" Description This function gets the property of the volume This function is used by higher layers (sys_fs layer) to know the property of the volume as specified in the SYS_FS_VOLUME_PROPERTY structure ",
							" Precondition None ",
							" Parameters Param Description *devName String name of the media *str Pointer to structure of type SYS_FS_VOLUME_PROPERTY ",
							" Returns True or false ",
							" SYS_FS_MEDIA_MANAGER_MediaStatusGet Function ",
							" C bool SYS_FS_MEDIA_MANAGER_MediaStatusGet (  const  char  * devName ) ; ",
							" Summary Gets the media status ",
							" Description This function gets the media status This function is used by higher layers (sys_fs layer) to know the status of the media whether the media is attached or detached ",
							" Precondition None ",
							" Parameters Param Description *devName string name of the media ",
							" Returns Media attach/detach status of type bool ",
							" SYS_FS_MEDIA_MANAGER_EventHandlerSet Function ",
							" C void SYS_FS_MEDIA_MANAGER_EventHandlerSet (  const  void  * eventHandler   const uintptr_t context ) ; ",
							" Summary Register the event handler for Mount/Un-Mount events ",
							" Description This function is used to register a FS client event handler for notifying the Mount/Un-Mount events when AutoMount feature is enabled for File system On Mount/Un-Mount of a volume all the registered clients will be notified The client should check if the mount name passed when event handler is called is the one it is expecting and then proceed ",
							" Parameters Param Description eventHandler FS Client event handler pointer context FS Client context ",
							" Returns None ",
							" Remarks This API should not be called directly from Application Application should use SYS_FS_EventHandlerSet() instead This API is Available only when SYS_FS_AUTOMOUNT_ENABLE is set to true See sys_fs h for usage information ",
							" SYS_FS_MEDIA_MANAGER_RegisterTransferHandler Function ",
							" C void SYS_FS_MEDIA_MANAGER_RegisterTransferHandler (  const  void  * eventHandler ) ; ",
							" Summary Register the event handler for data transfer events ",
							" Description This function is used to send the command status for the disk operation ",
							" Precondition None ",
							" Parameters Param Description eventHandler Event handler pointer ",
							" Returns None ",
							" SYS_FS_MEDIA_MANAGER_GetMediaGeometry Function ",
							" C SYS_FS_MEDIA_GEOMETRY * SYS_FS_MEDIA_MANAGER_GetMediaGeometry ( uint16_t diskNum ) ; ",
							" Summary Gets the media geometry information ",
							" Description This function gets the media geometry information ",
							" Precondition None ",
							" Parameters Param Description diskNum Media disk number ",
							" Returns Pointer to the media geometry on Success else NULL ",
							" SYS_FS_MEDIA_MANAGER_TransferTask Function ",
							" C void SYS_FS_MEDIA_MANAGER_TransferTask ( uint8_t mediaIndex ) ; ",
							" Summary Media manager transfer task function ",
							" Description This is the media manager transfer task function This task is repeatedly called by the disk io layer of the native file system for driving the current disk read/write operation to completion ",
							" Precondition None ",
							" Parameters Param Description mediaIndex disk number of the media ",
							" Returns None ",
							" SYS_FS_MEDIA_MANAGER_Tasks Function ",
							" C void  SYS_FS_MEDIA_MANAGER_Tasks (  void  ) ; ",
							" Summary Media manager task function ",
							" Description This is the media manager task function This task must be called repeatedly from the main loop ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE Typedef ",
							" C typedef SYS_MEDIA_BLOCK_COMMAND_HANDLE SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE ;  ",
							" Summary Handle identifying block commands of the media ",
							" Description A block command handle is returned by a call to the Read Write or Erase functions This handle allows the application to track the completion of the operation The handle is returned back to the client by the \"event handler callback\" function registered with the driver The handle assigned to a client request expires when the client has been notified of the completion of the operation (after event handler function that notifies the client returns) or after the buffer has been retired by the driver if no event handler callback was set ",
							" Remarks Refer to sys_media h for actual definition ",
							" SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID Macro ",
							" C # define SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID SYS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID  ",
							" Summary Defines the invalid media block command handle ",
							" Description This value defines invalid handle for the media block command It is returned by read/write/erase routines when the request could not be taken ",
							" Remarks Refer to sys_media h for actual definition ",
							" SYS_FS_MEDIA_HANDLE Typedef ",
							" C typedef uintptr_t SYS_FS_MEDIA_HANDLE ;  ",
							" Summary Handle identifying the media registered with the media manager ",
							" Description The media drivers register the media services with the media manager by calling the SYS_FS_MEDIA_MANAGER_Register function On successful registration a media handle is returned which can be used by the media driver to deregister the services from the media manager layer ",
							" Remarks None ",
							" SYS_FS_MEDIA_HANDLE_INVALID Macro ",
							" C # define SYS_FS_MEDIA_HANDLE_INVALID DRV_HANDLE_INVALID ",
							" Summary Defines the invalid media handle ",
							" Description This value defines invalid media handle It is returned when the media registration is not successful ",
							" Remarks None ",
							" SYS_FS_MEDIA_BLOCK_EVENT Enum ",
							" C typedef  enum  {  /* Block operation has been completed successfully */ SYS_FS_MEDIA_EVENT_BLOCK_COMMAND_COMPLETE = SYS_MEDIA_EVENT_BLOCK_COMMAND_COMPLETE   /* There was an error during the block operation */ SYS_FS_MEDIA_EVENT_BLOCK_COMMAND_ERROR = SYS_MEDIA_EVENT_BLOCK_COMMAND_ERROR } SYS_FS_MEDIA_BLOCK_EVENT ;  ",
							" Summary Identifies the possible events that can result from a request ",
							" Description This enumeration identifies the possible events that can result from a media One of these values is passed in the \"event\" parameter of the event handling callback function that client registered with the driver by setting the event handler when a block request is completed ",
							" Remarks Refer to sys_media h for actual enumerations ",
							" SYS_FS_MEDIA_PROPERTY Enum ",
							" C typedef  enum  {  /* Media supports Byte Write */ SYS_FS_MEDIA_SUPPORTS_BYTE_WRITES = SYS_MEDIA_SUPPORTS_BYTE_WRITES   /* Media supports only Read operation */ SYS_FS_MEDIA_SUPPORTS_READ_ONLY = SYS_MEDIA_SUPPORTS_READ_ONLY   /* Media supports OTP (One Time Programming) */ SYS_FS_MEDIA_SUPPORTS_ONE_TIME_PROGRAMING = SYS_MEDIA_SUPPORTS_ONE_TIME_PROGRAMING   /* Read in blocking */ SYS_FS_MEDIA_READ_IS_BLOCKING = SYS_MEDIA_READ_IS_BLOCKING   /* Write is blocking */ SYS_FS_MEDIA_WRITE_IS_BLOCKING = SYS_MEDIA_WRITE_IS_BLOCKING   } SYS_FS_MEDIA_PROPERTY ;  ",
							" Summary Contains information of property of a media ",
							" Description This structure contains the information of property of a media device For a device if multiple properties are applicable they can be ORed together and used ",
							" Remarks Refer to sys_media h for actual enumerations ",
							" SYS_FS_MEDIA_STATUS Enum ",
							" C typedef  enum  {  /* Media is detached */ SYS_FS_MEDIA_DETACHED = SYS_MEDIA_DETACHED   /* Media is attached */ SYS_FS_MEDIA_ATTACHED = SYS_MEDIA_ATTACHED } SYS_FS_MEDIA_STATUS ;  ",
							" Summary The status of media ",
							" Description This enumeration states if the media is attached or not ",
							" Remarks None ",
							" SYS_FS_MEDIA_STATE Enum ",
							" C typedef  enum  {  /* Media is de registered with the media manager */ SYS_FS_MEDIA_STATE_DEREGISTERED =  0   /* Media is registered with the media manager */ SYS_FS_MEDIA_STATE_REGISTERED   /* Check the attach/detach status of the Media */ SYS_FS_MEDIA_CHECK_ATTACH_STATUS   /* Read the first sector of the media */ SYS_FS_MEDIA_READ_FIRST_SECTOR   /* Analyze the FS */ SYS_FS_MEDIA_ANALYZE_FS   } SYS_FS_MEDIA_STATE ;  ",
							" Summary The enumeration for state of media ",
							" Description The media manager task picks a disk for analysis and takes it through a number of states This enumeration mentions the state of the media ",
							" Remarks None ",
							" SYS_FS_MEDIA_TYPE Enum ",
							" C typedef  enum  {  /* Media is of type NVM (internal flash (non volatile) memory)*/ SYS_FS_MEDIA_TYPE_NVM   /* Media is of type mass storage device */ SYS_FS_MEDIA_TYPE_MSD   /* Media is of type SD card */ SYS_FS_MEDIA_TYPE_SD_CARD   /* Media is of type RAM */ SYS_FS_MEDIA_TYPE_RAM   /* Media is of type SPI/QSPI Flash SPI/I2C EEPROM */ SYS_FS_MEDIA_TYPE_SPIFLASH } SYS_FS_MEDIA_TYPE ;  ",
							" Summary The enumeration for type of media ",
							" Description This enumeration is for the type of media registered with the media manager ",
							" Remarks None ",
							" SYS_FS_MEDIA_COMMAND_STATUS Enum ",
							" C typedef  enum  {  /*Done OK and ready */ SYS_FS_MEDIA_COMMAND_COMPLETED = SYS_MEDIA_COMMAND_COMPLETED   /*Scheduled but not started */ SYS_FS_MEDIA_COMMAND_QUEUED = SYS_MEDIA_COMMAND_QUEUED   /*Currently being in transfer */ SYS_FS_MEDIA_COMMAND_IN_PROGRESS = SYS_MEDIA_COMMAND_IN_PROGRESS   /*Unknown buffer */ SYS_FS_MEDIA_COMMAND_UNKNOWN = SYS_MEDIA_COMMAND_UNKNOWN   } SYS_FS_MEDIA_COMMAND_STATUS ;  ",
							" Summary The enumeration for status of buffer ",
							" Description This enumeration contains the various status of buffer ",
							" Remarks Refer to sys_media h for actual enumerations ",
							" SYS_FS_MEDIA_REGION_GEOMETRY Typedef ",
							" C typedef SYS_MEDIA_REGION_GEOMETRY SYS_FS_MEDIA_REGION_GEOMETRY ; ",
							" Summary Contains information of a sys media region ",
							" Description This structure contains the information of a sys media region A media can have multiple regions Sum of size of all the regions is the total memory size of the media Each region is further divided into blocks of identical size ",
							" Remarks Refer to sys_media h for actual definition ",
							" SYS_FS_MEDIA_GEOMETRY Typedef ",
							" C typedef SYS_MEDIA_GEOMETRY SYS_FS_MEDIA_GEOMETRY ; ",
							" Summary Contains all the geometrical information of a media device ",
							" Description This structure contains all the geometrical information of a media device the structure also has property of the media like media is one time programmable (OTP) or Read Only etc A memory device can have multiple erase block regions Sum of all the regions is the total memory size of the device ",
							" Remarks Refer to sys_media h for actual definition ",
							" SYS_FS_MEDIA_MOUNT_DATA Struct ",
							" C typedef  struct  {  /* Media Mount Name */  const  char * mountName ;  /* Media Device Name */  const  char * devName ;  /* Media Type */ SYS_FS_MEDIA_TYPE mediaType ;  /* File system type on Media */ SYS_FS_FILE_SYSTEM_TYPE fsType ;  } SYS_FS_MEDIA_MOUNT_DATA ;  ",
							" Summary Structure to obtain the device and mount name of media ",
							" Description This structure is an input for the media manager to auto mount the media when the auto mount feature is enabled ",
							" Remarks None ",
							" SYS_FS_VOLUME_PROPERTY Struct ",
							" C typedef  struct  _SYS_FS_VOLUME_PROPERTY  {  /* Volume # */  unsigned  int volNumber ;  /* File system type */ SYS_FS_FILE_SYSTEM_TYPE fsType ;  } SYS_FS_VOLUME_PROPERTY ;  ",
							" Summary Structure to obtain the property of volume ",
							" Description This structure is passed by sys_fs layer to know the property of a volume The function \"SYS_FS_MEDIA_MANAGER_VolumePropertyGet\" is used for the call ",
							" Remarks None ",
							" SYS_FS_MEDIA_FUNCTIONS Struct ",
							" C typedef  struct  {  /* To obtains status of media */ bool ( * mediaStatusGet ) ( DRV_HANDLE handle ) ;  /* Function to get media geometry */ SYS_FS_MEDIA_GEOMETRY *  ( * mediaGeometryGet ) ( const DRV_HANDLE handle ) ;  /* Function for sector read */  void  ( * sectorRead ) ( DRV_HANDLE clientHandle  SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE * commandHandle   void  * buffer  uint32_t blockStart  uint32_t nBlock ) ;  /* Function for sector write */  void  ( * sectorWrite ) ( const DRV_HANDLE handle  SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE * commandHandle   void  * sourceBuffer  uint32_t blockStart  uint32_t nBlock ) ;  /* Function register the event handler with media */  void  ( * eventHandlerset ) ( DRV_HANDLE handle   const  void  * eventHandler   const uintptr_t context ) ;  /* Function to obtain the command status */ SYS_FS_MEDIA_COMMAND_STATUS ( * commandStatusGet ) ( DRV_HANDLE handle  SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE commandHandle ) ;  /* Function to read certain bytes from the media */  void  ( * Read )  ( DRV_HANDLE clientHandle  SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE * commandHandle   void  * buffer  uint32_t blockStart  uint32_t nBlock ) ;  /* Function to obtain the address of the media (to be used for NVM only) */ uintptr_t ( * addressGet )  (  const DRV_HANDLE hClient ) ;  void  ( * erase )  (  const DRV_HANDLE handle  SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE * commandHandle  uint32_t blockStart  uint32_t nBlock ) ;  /* Function to open the media driver */ DRV_HANDLE ( * open ) ( SYS_MODULE_INDEX index  DRV_IO_INTENT intent ) ;  /* Function to close the media */  void  ( * close ) ( DRV_HANDLE client ) ;  /* Task function of the media */  void  ( * tasks ) ( SYS_MODULE_OBJ obj ) ;  } SYS_FS_MEDIA_FUNCTIONS ;  ",
							" Summary Structure of function pointers for media driver ",
							" Description This structure contains the definition for functions of media driver which is registered with the media manager In future if any new driver needs to be registered with the media manager (say to act as a media for file system) the new driver should have implemented all these functions ",
							" Remarks None ",
							" SYS_FS_MEDIA_EVENT_HANDLER Typedef ",
							" C typedef SYS_MEDIA_EVENT_HANDLER SYS_FS_MEDIA_EVENT_HANDLER ; ",
							" Summary Pointer to the Media Event Handler function ",
							" Description This data type defines the required function signature for the media event handling callback function A client must register a pointer to an event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive event calls back from the driver ",
							" Parameters Param Description event Identifies the type of event commandHandle Handle returned from the media operation requests context Value identifying the context of the application that registered the event handling function ",
							" Returns None ",
							" Remarks Refer to sys_media h for actual definition ",
							" Interrupt System Service This library provides a low-level abstraction of the Interrupt System Service Library that is available on the Microchip family micro-controllers with a convenient C language interface It can be used to simplify low-level access to the module without the necessity of interacting directly with the module's registers/PLIB thereby hiding differences from one micro-controller variant to another Library Interface INT system service provides the following interfaces: Functions Name Description SYS_INT_Enable Enable Global Interrupt SYS_INT_Disable Disable Global Interrupt SYS_INT_IsEnabled Returns the interrupt controller's global enable/disable status SYS_INT_Restore Restores the interrupt controller to the state specified in the parameter SYS_INT_SourceEnable Enables the specified interrupt source SYS_INT_SourceDisable Disables the specified interrupt source SYS_INT_SourceRestore Restores an interrupt vector to the state specified in the parameter SYS_INT_SourceIsEnabled Gets the enable/disable status of the specified interrupt source SYS_INT_SourceStatusGet Gets the pending status of the specified interrupt source SYS_INT_SourceStatusSet Sets the pending status of the specified interrupt source manually SYS_INT_SourceStatusClear Clears the pending status of the specified interrupt source Data types and constants Name Type Description INT_SOURCE Typedef Defines the data type for all the interrupt sources associated with the interrupt controller of the device ",
							" SYS_INT_Enable Function ",
							" C void  SYS_INT_Enable (  void  ) ",
							" Summary Enable Global Interrupt ",
							" Description This function enables global interrupt ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example SYS_INT_Enable ( ) ; ",
							" Remarks None ",
							" SYS_INT_Disable Function ",
							" C bool SYS_INT_Disable (  void  ) ",
							" Summary Disable Global Interrupt ",
							" Description This function disables global interrupt and returns the state of the global interrupt prior to disabling it When global interrupt is disabled only NMI and HardFault exceptions are allowed This may be used to disable global interrupt during critical section and restore the global interrupt state after the critical section ",
							" Precondition None ",
							" Parameters None ",
							" Returns This function disables the global interrupt and return the state of global interrupt prior to disabling it The state information will be used to restore the global interrupt to the original state after the critical section - true - Global Interrupt is enabled - false - Global Interrupt is disabled ",
							" Example bool interruptState ;  // Save global interrupt state and disable interrupt interruptState =  SYS_INT_Disable ( ) ;  // Critical Section  // Restore interrupt state  SYS_INT_Restore ( interruptState ) ",
							" Remarks Returned status can be passed to SYS_INT_Restore to restore the previous global interrupt status (whether it was enabled or disabled) ",
							" SYS_INT_IsEnabled Function ",
							" C bool SYS_INT_IsEnabled (  void  ) ",
							" Summary Returns the interrupt controller's global enable/disable status ",
							" Description This function returns global interrupt enable status ",
							" Precondition None ",
							" Parameters None ",
							" Returns - true - Global Interrupt is enabled - false - Global Interrupt is disabled ",
							" Example if ( true ==  SYS_INT_IsEnabled ( ) )  {  // Global Interrupt is enabled  } ",
							" Remarks None ",
							" SYS_INT_Restore Function ",
							" C void  SYS_INT_Restore ( bool state ) ",
							" Summary Restores the interrupt controller to the state specified in the parameter ",
							" Description This function restores the interrupt controller to the state specified in the parameters ",
							" Precondition SYS_INT_Disable must have been called to get previous state of the global interrupt ",
							" Parameters Param Description - true Enable Global Interrupt - false Disable Global Interrupt ",
							" Returns None ",
							" Example bool interruptState ;  // Save global interrupt state and disable interrupt interruptState =  SYS_INT_Disable ( ) ;  // Critical Section  // Restore interrupt state  SYS_INT_Restore ( interruptState ) ",
							" Remarks None ",
							" SYS_INT_SourceEnable Function ",
							" C void  SYS_INT_SourceEnable ( INT_SOURCE source ) ",
							" Summary Enables the specified interrupt source ",
							" Description This function enables the specified interrupt source/line at the interrupt controller level ",
							" Precondition None ",
							" Parameters Param Description source Interrupt source/line available at interrupt controller ",
							" Returns None ",
							" Example SYS_INT_SourceEnable ( USART0_IRQn ) ; ",
							" Remarks The corresponding module level interrupts must be enabled to trigger the specified interrupt source/line For example USART0 interrupt enable at interrupt controller level is not triggered unless USART0 module level interrupt for TXRDY or RXRDY or Error interrupts are not enabled ",
							" SYS_INT_SourceDisable Function ",
							" C bool SYS_INT_SourceDisable ( INT_SOURCE source ) ",
							" Summary Disables the specified interrupt source ",
							" Description This function returns the current interrupt enable/disable status and disables the specified interrupt source/line at the interrupt controller level ",
							" Precondition None ",
							" Parameters Param Description source Interrupt source/line available at interrupt controller ",
							" Returns - true - Interrupt line was enabled - false - Interrupt line was disabled ",
							" Example bool usart0Int = false ; usart0Int =  SYS_INT_SourceDisable ( USART0_IRQn ) ; ",
							" Remarks If the corresponding module level interrupts are enabled and triggered the triggers will be ignored at interrupt controller For example USART0 doesn't cause interrupt unless both the interrupt controller source/line and USART0 module level interrupt for TX or RX or Error are enabled ",
							" SYS_INT_SourceRestore Function ",
							" C void  SYS_INT_SourceRestore ( INT_SOURCE source  bool status ) ",
							" Summary Restores an interrupt vector to the state specified in the parameter ",
							" Description This function restores the interrupt vector to the state specified in the parameters ",
							" Precondition SYS_INT_SourceDisable must have been called previously to get the state value ",
							" Parameters Param Description - true Enable Interrupt Vector - false Disable Interrupt Vector ",
							" Returns None ",
							" Example bool status ;  // Save interrupt vector state and disable interrupt status =  SYS_INT_SourceDisable ( aSrcId ) ;  // Critical Section  // Restore interrupt vector state  SYS_INT_SourceRestore ( aSrcId  status ) ",
							" Remarks None ",
							" SYS_INT_SourceIsEnabled Function ",
							" C bool SYS_INT_SourceIsEnabled ( INT_SOURCE source ) ",
							" Summary Gets the enable/disable status of the specified interrupt source ",
							" Description This function returns the enable/disable status of the specified interrupt source/line at the interrupt controller level ",
							" Precondition None ",
							" Parameters Param Description source Interrupt source/line available at interrupt controller ",
							" Returns - true - Interrupt line is enabled - false - Interrupt line is disabled ",
							" Example bool usart0Int = false ; usart0Int =  SYS_INT_SourceIsEnabled ( USART0_IRQn ) ; ",
							" Remarks Unlike SYS_INT_Disable this function just returns the status and doesn't disable the interrupt line ",
							" SYS_INT_SourceStatusGet Function ",
							" C bool SYS_INT_SourceStatusGet ( INT_SOURCE source ) ",
							" Summary Gets the pending status of the specified interrupt source ",
							" Description This function returns the pending status of the specified interrupt source at the interrupt controller level ",
							" Precondition None ",
							" Parameters Param Description source Interrupt source/line available at interrupt controller ",
							" Returns - true - Interrupt status is pending - false - Interrupt status is not pending ",
							" Example bool usart0IntStatus =  SYS_INT_SourceStatusGet ( USART0_IRQn ) ; ",
							" Remarks Interrupt pending status may get cleared automatically once the corresponding interrupt vector executes on some devices ",
							" SYS_INT_SourceStatusSet Function ",
							" C void  SYS_INT_SourceStatusSet ( INT_SOURCE source ) ",
							" Summary Sets the pending status of the specified interrupt source manually ",
							" Description This function manually sets the pending status of the specified interrupt source at the interrupt controller level This triggers interrupt controller for a specified source even though the interrupt condition has not met at hardware ",
							" Precondition None ",
							" Parameters Param Description source Interrupt source/line available at interrupt controller ",
							" Returns None ",
							" Example //Trigger USART0 ISR handler manually  SYS_INT_SourceStatusSet ( USART0_IRQn ) ; ",
							" Remarks This feature may not be supported by some devices ",
							" SYS_INT_SourceStatusClear Function ",
							" C void  SYS_INT_SourceStatusClear ( INT_SOURCE source ) ",
							" Summary Clears the pending status of the specified interrupt source ",
							" Description This function clears the pending status of the specified interrupt source at the interrupt controller level It is ignored if the interrupt condition has already been cleared in hardware ",
							" Precondition None ",
							" Parameters Param Description source Interrupt source/line available at interrupt controller ",
							" Returns None ",
							" Example //Clear a pending interrupt  SYS_INT_SourceStatusClear ( USART0_IRQn ) ; ",
							" Remarks None ",
							" INT_SOURCE Typedef ",
							" C typedef IRQn_Type INT_SOURCE ; ",
							" Summary Defines the data type for all the interrupt sources associated with the interrupt controller of the device ",
							" Description This data type can be used with interface functions to enable disable set clear and to get status of any particular interrupt source ",
							" Remarks This data type is defined using the CMSIS data type that defines the interrupt sources set available ",
							" Ports System Service Ports System service abstract different general purpose input output (GPIO) modules present on Microchip family of devices it provides a common interface to use GPIO across all the 32 bit Microchip devices Library Interface Ports system service provides the following interfaces: Functions Name Description SYS_PORT_PinWrite Writes to the selected pin SYS_PORT_PinRead Read the selected pin value SYS_PORT_PinLatchRead Read the value driven on the selected pin SYS_PORT_PinToggle Toggles the selected pin SYS_PORT_PinSet Sets the selected pin SYS_PORT_PinClear Clears the selected pin SYS_PORT_PinInputEnable Enables selected IO pin as input SYS_PORT_PinOutputEnable Enables selected IO pin as output Data types and constants Name Type Description SYS_PORT Enum Identifies the available Port Channels SYS_PORT_PIN Enum Identifies the available port pins ",
							" SYS_PORT_PinWrite Function ",
							" C void  SYS_PORT_PinWrite ( SYS_PORT_PIN pin  bool value ) ",
							" Summary Writes to the selected pin ",
							" Description This function writes/drives the \"value\" on the selected I/O line/pin ",
							" Precondition Port Initialization must have been done using appropriate Initialize API call ",
							" Parameters Param Description pin One of the IO pins from the enum SYS_PORT_PIN value value to be written on the selected pin: true: set pin to high (1) false: clear pin to low (0) ",
							" Returns None ",
							" Example SYS_PORT_PinWrite ( SYS_PORT_PIN_PB3  true ) ; ",
							" Remarks None ",
							" SYS_PORT_PinRead Function ",
							" C bool SYS_PORT_PinRead ( SYS_PORT_PIN pin ) ",
							" Summary Read the selected pin value ",
							" Description This function reads the selected pin value it reads the value regardless of pin configuration whether uniquely as an input or driven by the PIO Controller or driven by peripheral ",
							" Precondition Reading the I/O line levels requires the clock of the PIO Controller to be enabled otherwise this API reads the levels present on the I/O line at the time the clock was disabled ",
							" Parameters Param Description pin One of the IO pins from the enum SYS_PORT_PIN ",
							" Returns Returns the read value of the selected I/O pin ",
							" Example bool value ; value =  SYS_PORT_PinRead ( SYS_PORT_PIN_PB3 ) ; ",
							" Remarks To read the latched value on this pin SYS_PORT_PinLatchRead API should be used ",
							" SYS_PORT_PinLatchRead Function ",
							" C bool SYS_PORT_PinLatchRead ( SYS_PORT_PIN pin ) ",
							" Summary Read the value driven on the selected pin ",
							" Description This function reads the data driven on the selected I/O line/pin Whatever data is written/driven on I/O line by using any of the PORTS APIs will be read by this API ",
							" Precondition None ",
							" Parameters Param Description pin One of the IO pins from the enum SYS_PORT_PIN ",
							" Returns Returns the value driven on the selected I/O pin ",
							" Example bool value ; value =  SYS_PORT_PinLatchRead ( SYS_PORT_PIN_PB3 ) ; ",
							" Remarks To read actual pin value SYS_PORT_PinRead API should be used ",
							" SYS_PORT_PinToggle Function ",
							" C void  SYS_PORT_PinToggle ( SYS_PORT_PIN pin ) ",
							" Summary Toggles the selected pin ",
							" Description This function toggles/inverts the value on the selected I/O line/pin ",
							" Precondition Port Initialization must have been done using appropriate Initialize API call ",
							" Parameters Param Description pin One of the IO pins from the enum SYS_PORT_PIN ",
							" Returns None ",
							" Example SYS_PORT_PinToggle ( SYS_PORT_PIN_PB3 ) ; ",
							" Remarks None ",
							" SYS_PORT_PinSet Function ",
							" C void  SYS_PORT_PinSet ( SYS_PORT_PIN pin ) ",
							" Summary Sets the selected pin ",
							" Description This function drives '1' on the selected I/O line/pin ",
							" Precondition None ",
							" Parameters Param Description pin One of the IO pins from the enum SYS_PORT_PIN ",
							" Returns None ",
							" Example SYS_PORT_PinSet ( SYS_PORT_PIN_PB3 ) ; ",
							" Remarks None ",
							" SYS_PORT_PinClear Function ",
							" C void  SYS_PORT_PinClear ( SYS_PORT_PIN pin ) ",
							" Summary Clears the selected pin ",
							" Description This function drives '0' on the selected I/O line/pin ",
							" Precondition None ",
							" Parameters Param Description pin One of the IO pins from the enum SYS_PORT_PIN ",
							" Returns None ",
							" Example SYS_PORT_PinClear ( SYS_PORT_PIN_PB3 ) ; ",
							" Remarks None ",
							" SYS_PORT_PinInputEnable Function ",
							" C void  SYS_PORT_PinInputEnable ( SYS_PORT_PIN pin ) ",
							" Summary Enables selected IO pin as input ",
							" Description This function enables selected IO pin as input ",
							" Precondition None ",
							" Parameters Param Description pin One of the IO pins from the enum SYS_PORT_PIN ",
							" Returns None ",
							" Example SYS_PORT_PinInputEnable ( SYS_PORT_PIN_PB3 ) ; ",
							" Remarks None ",
							" SYS_PORT_PinOutputEnable Function ",
							" C void  SYS_PORT_PinOutputEnable ( SYS_PORT_PIN pin ) ",
							" Summary Enables selected IO pin as output ",
							" Description This function enables selected IO pin as output ",
							" Precondition None ",
							" Parameters Param Description pin One of the IO pins from the enum SYS_PORT_PIN ",
							" Returns None ",
							" Example SYS_PORT_PinOutputEnable ( SYS_PORT_PIN_PB3 ) ; ",
							" Remarks None ",
							" SYS_PORT Enum ",
							" C The Port Channels vary based on device family Refer to the generated header file for the actual values ",
							" Summary Identifies the available Port Channels ",
							" Description This enumeration identifies the available Port Channels ",
							" Remarks The caller should not rely on the specific numbers assigned to any of these values as they may change from one processor to the next Not all ports are available on all devices Refer to the specific device data sheet to determine which ports are supported ",
							" SYS_PORT_PIN Enum ",
							" C The Port Pins vary based on device family Refer to the generated header file for the actual values ",
							" Summary Identifies the available port pins ",
							" Description This enumeration identifies the available port pins ",
							" Remarks The caller should not rely on the specific numbers assigned to any of these values as they may change from one processor to the next Not all pins are available on all devices Refer to the specific device data sheet to determine which pins are supported ",
							" Reset System Service This library provides an interface to manage and control Reset related features on Microchip families of micro-controllers Library Interface Reset System Service provides the following interfaces: Functions Name Description SYS_RESET_SoftwareReset Triggers a software reset ",
							" SYS_RESET_SoftwareReset Function ",
							" C void  SYS_RESET_SoftwareReset (  void  ) ",
							" Summary Triggers a software reset ",
							" Description This function triggers a software Reset ",
							" PreCondition: None ",
							" Parameters None ",
							" Returns None ",
							" Example SYS_RESET_SoftwareReset ( ) ; ",
							" Remarks None ",
							" Time System Service The Timer System Service Library is capable of providing periodic or one-shot alarm and delays to the user It uses a hardware timer peripheral library for providing it's timing services Key Features: Periodic notifications One-shot/single notification Delays Support for both tick-based and tickless modes Tick-less mode: Instead of getting interrupted from the hardware timer periodically the Time System Service manages the hardware timer so as to generate an interrupt only when required and at appropriate times Tick-based mode: A periodic interrupt is generated by the hardware timer The tick-rate is configurable by the user and defines the resolution for all the timers ",
							" How the Library Works The tick-less implementation reduces the overheads of servicing the unneeded hardware timer interrupt on every tick The tick-less implementation can also provide higher resolution compared to a tick based implementation as there is no fixed tick rate Abstraction Model The Time System Service library provides an abstraction to the hardware timer to provide following functionalities Periodic Callback One Shot/Single Callback Delays The following diagram depicts the Time System Service abstraction model Time System Service configured in tick-less mode sys_time_abstraction_model_tickless_working Time System Service configured in tick-based mode sys_time_abstraction_model_tickbased_working Execution Flow The Time System Service registers a callback with the underlying hardware timer peripheral library Depending on the alarm/delay time periods requested by various clients the implementation manages the hardware timer such that a compare interrupt is generated only when needed and at appropriate times This is achieved by maintaining a sorted list of timing requested by different clients such that the head of the list always indicates the time after which the hardware timer must interrupt and notify the Timer System Service Inside the Time System Service callback the list is updated and a callback is given to the client for which the alarm/delay has expired The following diagram shows how the tick-less implementation reduces the number of hardware interrupts In this example two clients - Client A and Client B requests a periodic alarm every 30 ms and 70 ms respectively sys_time_execution_flow_time_diagram ",
							" Using The Library The Time System Service provides alarm and delay functionalities to multiple clients In addition it also provides APIs to read the counter value which can be used to measure the time period between two events Alarm For single/one-shot alarms the application must register a callback Once the requested time period elapses the application is notified by calling the registered callback After the callback is given the internal timer object is destroyed by Time System Service making it available for application to request new alarms/delays For periodic alarms the application can either register a callback or can choose to poll the status of the alarm Once the requested time period elapses the application is notified by calling the callback if registered by the application In case the application wants to poll the status of the alarm it can do so by calling the status API provided by the library Application can use the delay functionality by using the delay related APIs and then polling the status of the requested delay Calling the status API after the delay has expired will destroy the internal timer object making it available for new alarms/delays The library also provides counter functionality that can be used by the application to measure the time elapsed between the two events The counter functionality does not require a dedicated timer object and is always available Example application demonstrating the multi-client system timer functionality This application demonstrates timer functionality (with two clients to the Time System Service) by periodically printing a message on console every two seconds and blinking an LED every one second # define LED_BLINK_RATE_MS 1000  # define CONSOLE_PRINT_RATE_MS 2000  # define SINGLE_SHOT_TIMER_MS 100  # define SWITCH_DELAY_MS 500  typedef  struct  {  /* The application's current state */ APP_STATES state ; SYS_TIME_HANDLE tmr1Handle ;  volatile bool tmr1Expired ; SYS_TIME_HANDLE tmr2Handle ;  volatile bool tmr2Expired ; SYS_TIME_HANDLE tmr3Handle ;  volatile bool tmr3Expired ; SYS_TIME_HANDLE tmr4Handle ; uint64_t prevCounterVal ;  } APP_DATA ; APP_DATA appData ;  void Timer1_Callback ( uintptr_t context )  { appData  tmr1Expired = true ;  }  void Timer2_Callback ( uintptr_t context )  { appData  tmr2Expired = true ;  }  void Timer3_Callback ( uintptr_t context )  { appData  tmr3Expired = true ;  }  void APP_Initialize (  void  )  {  /* Place the App state machine in its initial state */ appData  state = APP_STATE_INIT ; appData  state = APP_STATE_INIT ; appData  tmr1Handle = SYS_TIME_HANDLE_INVALID ; appData  tmr2Handle = SYS_TIME_HANDLE_INVALID ; appData  tmr3Handle = SYS_TIME_HANDLE_INVALID ; appData  tmr4Handle = SYS_TIME_HANDLE_INVALID ; appData  tmr1Expired = false ; appData  tmr2Expired = false ; appData  tmr3Expired = false ;  }  void APP_Tasks (  void  )  { uint64_t diffCount =  0 ;  /* Check the application's current state */  switch  ( appData  state )  {  /* Application's initial state */  case APP_STATE_INIT :  { appData  tmr1Handle =  SYS_TIME_CallbackRegisterMS ( Timer1_Callback   0  LED_BLINK_RATE_MS  SYS_TIME_PERIODIC ) ; appData  tmr2Handle =  SYS_TIME_CallbackRegisterMS ( Timer2_Callback   0  CONSOLE_PRINT_RATE_MS  SYS_TIME_PERIODIC ) ;  if  ( ( appData  tmr1Handle = SYS_TIME_HANDLE_INVALID )    ( appData  tmr2Handle = SYS_TIME_HANDLE_INVALID ) )  { appData  state = APP_STATE_SERVICE_TASKS ;  }  break ;  }  case APP_STATE_SERVICE_TASKS :  {  if ( appData  tmr1Expired == true )  {  /* Toggle LED periodically */ appData  tmr1Expired = false ;  LED_TOGGLE ( ) ;  }  if ( appData  tmr2Expired == true )  {  printf ( \"Message printed every %d ms r n\"  CONSOLE_PRINT_RATE_MS ) ; appData  tmr2Expired = false ;  }  if ( appData  tmr3Expired == true )  {  printf ( \"Single shot timer of %d ms expired r n\"  SINGLE_SHOT_TIMER_MS ) ; appData  tmr3Expired = false ;  }  if ( SWITCH_GET ( )  == SWITCH_STATUS_PRESSED )  {  /* Wait on delay */ appData  prevCounterVal =  SYS_TIME_Counter64Get ( ) ;  SYS_TIME_DelayMS ( SWITCH_DELAY_MS    appData  tmr4Handle ) ;  while ( SYS_TIME_DelayIsComplete ( appData  tmr4Handle )  == false ) ; diffCount =  ( SYS_TIME_Counter64Get ( )  - appData  prevCounterVal ) ;  printf ( \"Delay time = %d ms r n\"   ( int ) SYS_TIME_CountToMS ( diffCount ) ) ; appData  tmr3Handle =  SYS_TIME_CallbackRegisterMS ( Timer3_Callback   0  SINGLE_SHOT_TIMER_MS  SYS_TIME_SINGLE ) ;  }  break ;  }  /* The default state should never be executed */  default :  {  break ;  }  }  }  ",
							" Configuring The Library The Time System Service library should be configured through the MHC The following figure shows the MHC configuration window for configuring the Time System Service and a brief description of various configuration options Depending on the timer PLIB connected to the Time System Service the Time System Service provides options to setup the Time System Service in either Tick-less mode or Tick-based mode The Time System Service shows both Tick-less and Tick-based options for the timers that support for both compare and period modes The Time System Service shows only Tick-less mode for timers that only support compare mode The Time System Service shows only Tick-based mode for timers that support only period mode The Time System Service shows only Tick-based mode for Systick Time System Service Connected to TMR Peripheral (TC0) and configured in Tick-less mode sys_time_mhc_config_with_tmr_tickless Time System Service Connected to TMR Peripheral (TC0) and configured in Tick-based mode sys_time_mhc_config_with_tmr_tickbased Time System Service using Systick sys_time_mhc_config_with_systick Time System Service Configuration Options Use Systick This option is visible only in Bare-Metal environment When Enabled Time system service use the Systick peripheral Operating mode is fixed to TICK BASED PLIB Used: This option is visible only when a Timer peripheral library is connected Indicates the hardware Timer Peripheral Library instance used by the Time System Service Number of Clients: Indicates the maximum number of alarm/delay requests that can be active at any given time Operating Mode: Indicates the operating mode used If a timer PLIB is connected to it can be TICK BASED or/and TICKLESS mode If Systick is used then it is configured to TICK BASED mode Tick Rate (ms): This option is supported only in TICK BASED Operating mode Indicates the tick rate when the Time System Service is configured in TICK BASED mode Use Floating Point Calculations This option is supported only in TICK BASED Operating mode When Enabled Time system service uses floating point calculations TC0 Peripheral Configuration Options The hardware Timer Peripheral library is automatically configured for the correct mode of operation when it is connected to the Time System Service as shown in the below example snapshots for TC instance 0 Timer PLIB TC0 automatically configured by Time System Service when configured for tick-less mode sys_time_mhc_config_tc0_tickless Timer PLIB TC0 automatically configured by Time System Service when configured for tick-based mode sys_time_mhc_config_tc0_tickbased ",
							" Library Interface Time System Service library provides the following interfaces: Functions Name Description SYS_TIME_Initialize Initializes the System Time module SYS_TIME_Deinitialize Deinitializes the specific module instance of the SYS TIMER module SYS_TIME_Status Returns System Time status SYS_TIME_CallbackRegisterUS Registers a function with the time system service to be called back when the requested number of microseconds have expired (either once or repeatedly) SYS_TIME_CallbackRegisterMS Registers a function with the time system service to be called back when the requested number of milliseconds has expired (either once or repeatedly) SYS_TIME_DelayUS This function is used to generate a delay of a given number of microseconds SYS_TIME_DelayMS This function is used to generate a delay of a given number of milliseconds SYS_TIME_DelayIsComplete Determines if the given delay timer has completed SYS_TIME_FrequencyGet Gets the frequency at which the hardwaer timer counts SYS_TIME_CounterGet Get the common 32-bit system counter value SYS_TIME_Counter64Get Get the common 64-bit system counter value SYS_TIME_CounterSet Sets the common 32-bit system counter value SYS_TIME_CountToUS Converts a counter value to time interval in microseconds SYS_TIME_CountToMS Converts a counter value to time interval in milliseconds SYS_TIME_USToCount Convert the given time interval in microseconds to an equivalent counter value SYS_TIME_MSToCount Convert the given time interval in milliseconds to an equivalent counter value SYS_TIME_TimerCreate Creates and initializes a new 32-bit software timer instance SYS_TIME_TimerReload Reloads (or reinitializes) the software timer instance SYS_TIME_TimerDestroy Destroys/deallocates a software timer instance SYS_TIME_TimerCounterGet Gets the elapsed counter value of a software timer SYS_TIME_TimerStart Starts a software timer running SYS_TIME_TimerStop Stops a running software timer SYS_TIME_TimerPeriodHasExpired Reports whether or not the current period of a software timer has expired Data types and constants Name Type Description SYS_TIME_INIT Struct Defines the data required to initialize the TIME system service SYS_TIME_RESULT Enum Result of a time service client interface operation SYS_TIME_HANDLE Typedef Handle to a software timer instance SYS_TIME_HANDLE_INVALID Macro Invalid handle value to a software timer instance SYS_TIME_CALLBACK_TYPE Enum Identifies the type of callback requested (single or periodic) SYS_TIME_CALLBACK Typedef Pointer to a time system service callback function ",
							" SYS_TIME_Initialize Function ",
							" C SYS_MODULE_OBJ SYS_TIME_Initialize (  const SYS_MODULE_INDEX index   const SYS_MODULE_INIT *  const init ) ; ",
							" Summary Initializes the System Time module ",
							" Description This function initializes the instance of the System Time module ",
							" Parameters Param Description index Index for the instance to be initialized init Pointer to a data structure containing data necessary to initialize the module ",
							" Returns If successful returns a valid handle to an object Otherwise it returns SYS_MODULE_OBJ_INVALID ",
							" Example const SYS_TIME_PLIB_INTERFACE sysTimePlibAPI =  {   timerCallbackSet =  ( SYS_TIME_PLIB_CALLBACK_REGISTER ) TC0_CH0_TimerCallbackRegister    timerCounterGet =  ( SYS_TIME_PLIB_COUNTER_GET ) TC0_CH0_TimerCounterGet    timerPeriodSet =  ( SYS_TIME_PLIB_PERIOD_SET ) TC0_CH0_TimerPeriodSet    timerFrequencyGet =  ( SYS_TIME_PLIB_FREQUENCY_GET ) TC0_CH0_TimerFrequencyGet    timerCompareSet =  ( SYS_TIME_PLIB_COMPARE_SET ) TC0_CH0_TimerCompareSet    timerStart =  ( SYS_TIME_PLIB_START ) TC0_CH0_TimerStart    timerStop =  ( SYS_TIME_PLIB_STOP ) TC0_CH0_TimerStop } ;  const SYS_TIME_INIT sysTimeInitData =  {   timePlib =   sysTimePlibAPI    hwTimerIntNum = TC0_CH0_IRQn   } ; SYS_MODULE_OBJ objSysTime ; objSysTime =  SYS_TIME_Initialize ( SYS_TIME_INDEX_0   ( SYS_MODULE_INIT * )  sysTimeInitData ) ;  if  ( objSysTime == SYS_MODULE_OBJ_INVALID )  {  // Handle error  } ",
							" Remarks This routine should normally only be called once during system initialization ",
							" SYS_TIME_Deinitialize Function ",
							" C void SYS_TIME_Deinitialize ( SYS_MODULE_OBJ object ) ",
							" Summary Deinitializes the specific module instance of the SYS TIMER module ",
							" Description This function deinitializes the specific module instance disabling its operation (and any hardware for driver modules) Resets all of the internal data structures and fields for the specified instance to the default settings ",
							" Precondition The SYS_TIME_Initialize function should have been called before calling this function ",
							" Parameters Param Description object SYS TIMER object handle returned from SYS_TIME_Initialize ",
							" Returns None ",
							" Example // Handle \"objSysTime\" value must have been returned from SYS_TIME_Initialize SYS_TIME_Deinitialize ( objSysTime ) ;  if  ( SYS_TIME_Status ( objSysTime )  = SYS_STATUS_UNINITIALIZED )  {  // Check again later if you need to know  // when the SYS TIME is De-initialized  } ",
							" Remarks Once the Initialize operation has been called the De-initialize operation must be called before the Initialize operation can be called again ",
							" SYS_TIME_Status Function ",
							" C SYS_STATUS SYS_TIME_Status ( SYS_MODULE_OBJ object ) ",
							" Summary Returns System Time status ",
							" Description This function returns the current status of the System Time module ",
							" Precondition None ",
							" Parameters Param Description object SYS TIME object handle returned from SYS_TIME_Initialize ",
							" Returns SYS_STATUS_UNINITIALIZED - Indicates that the driver is not initialized SYS_STATUS_READY - Indicates that the module initialization is complete and it ready to be used ",
							" Example // Handle \"objSysTime\" value must have been returned from SYS_TIME_Initialize  if  ( SYS_TIME_Status ( objSysTime )  == SYS_STATUS_READY )  {  // Time system service is initialized and ready to accept new requests  } ",
							" Remarks None ",
							" SYS_TIME_CallbackRegisterUS Function ",
							" C SYS_TIME_HANDLE SYS_TIME_CallbackRegisterUS ( SYS_TIME_CALLBACK callback  uintptr_t context  uint32_t us  SYS_TIME_CALLBACK_TYPE type ) ; ",
							" Summary Registers a function with the time system service to be called back when the requested number of microseconds have expired (either once or repeatedly) ",
							" Description Creates a timer object and registers a function with it to be called back when the requested delay (specified in microseconds) has completed The caller must identify if the timer should call the function once or repeatedly every time the given delay period expires ",
							" Precondition The SYS_TIME_Initialize function should have been called before calling this function ",
							" Parameters Param Description callback Pointer to the function to be called For single shot timers the callback cannot be NULL For periodic timers if the callback pointer is given as NULL no callback will occur but SYS_TIME_TimerPeriodHasExpired can still be polled to determine if the period has expired for a periodic timer context A client-defined value that is passed to the callback function us Time period in microseconds type Type of callback requested If type is SYS_TIME_SINGLE the Callback function will be called once when the time period expires After the time period expires the timer object will be freed If type is SYS_TIME_PERIODIC Callback function will be called repeatedly every time the time period expires until the timer object is stopped or deleted ",
							" Returns SYS_TIME_HANDLE - A valid timer object handle if the call succeeds SYS_TIME_HANDLE_INVALID if it fails ",
							" Example Given a callback function implementation matching the following prototype: void MyCallback ( uintptr_t context ) ; The following example call will register it requesting a 500 microsecond periodic callback //Give a SYS_TIME_CALLBACK function \"MyCallback\" SYS_TIME_HANDLE handle =  SYS_TIME_CallbackRegisterUS ( MyCallback   ( uintptr_t ) 0   500  SYS_TIME_PERIODIC ) ;  if  ( handle = SYS_TIME_HANDLE_INVALID )  {  //timer is created successfully  } ",
							" Remarks Will give a callback after the requested number of microseconds or longer have elapsed depending on system performance In tick-based mode the requested delay will be ceiled to the next timer tick For example if the timer tick is set to 1 msec and the requested delay is 1500 usec a delay of 2 msec will be generated Delay values of 0 will return SYS_TIME_ERROR ",
							" SYS_TIME_CallbackRegisterMS Function ",
							" C SYS_TIME_HANDLE SYS_TIME_CallbackRegisterMS ( SYS_TIME_CALLBACK callback  uintptr_t context  uint32_t ms  SYS_TIME_CALLBACK_TYPE type ) ; ",
							" Summary Registers a function with the time system service to be called back when the requested number of milliseconds has expired (either once or repeatedly) ",
							" Description Creates a timer object and registers a function with it to be called back when the requested delay (specified in milliseconds) has completed The caller must identify if the timer should call the function once or repeatedly every time the given delay period expires ",
							" Precondition The SYS_TIME_Initialize function should have been called before calling this function ",
							" Parameters Param Description callback Pointer to the function to be called For single shot timers the callback cannot be NULL For periodic timers if the callback pointer is given as NULL no callback will occur but SYS_TIME_TimerPeriodHasExpired can still be polled to determine if the period has expired for a periodic timer context A client-defined value that is passed to the callback function ms Time period in milliseconds type Type of callback requested If type is SYS_TIME_SINGLE the Callback function will be called once when the time period expires After the time period expires the timer object will be freed If type is SYS_TIME_PERIODIC Callback function will be called repeatedly every time the time period expires until the timer object is stopped or deleted ",
							" Returns SYS_TIME_HANDLE - A valid timer object handle if the call succeeds SYS_TIME_HANDLE_INVALID if it fails ",
							" Example Given a callback function implementation matching the following prototype: void MyCallback ( uintptr_t context ) ; The following example call will register it requesting a 50 millisecond periodic callback //Give a SYS_TIME_CALLBACK function \"MyCallback\" SYS_TIME_HANDLE handle =  SYS_TIME_CallbackRegisterMS ( MyCallback   ( uintptr_t ) 0   50  SYS_TIME_PERIODIC ) ;  if  ( handle = SYS_TIME_HANDLE_INVALID )  {  //timer is created successfully  } ",
							" Remarks Will give a callback after the requested number of microseconds or longer have elapsed depending on system performance In tick-based mode the requested delay will be ceiled to the next timer tick For example if the timer tick is set to 700 usec and the requested delay is 2 msec a delay of 2 1 ms will be generated Delay values of 0 will return SYS_TIME_ERROR ",
							" SYS_TIME_DelayUS Function ",
							" C SYS_TIME_RESULT SYS_TIME_DelayUS ( uint32_t us  SYS_TIME_HANDLE * handle ) ",
							" Summary This function is used to generate a delay of a given number of microseconds ",
							" Description The function will internally create a single shot timer which will be auto deleted when the application calls SYS_TIME_DelayIsComplete routine and the delay has expired The function will return immediately requiring the caller to use SYS_TIME_DelayIsComplete routine to check the delay timer's status ",
							" Precondition The SYS_TIME_Initialize function must have been called before calling this function ",
							" Parameters Param Description us The desired number of microseconds to delay handle Address of the variable to receive the timer handle value ",
							" Returns SYS_TIME_SUCCESS - If the call succeeded SYS_TIME_ERROR - If the call failed either because the requested delay is zero or the passed handle is invalid or there is not enough room to queue in the request in the SYS Time's internal queue ",
							" Example SYS_TIME_HANDLE timer = SYS_TIME_HANDLE_INVALID ;  if  ( SYS_TIME_DelayUS ( 50    timer )  = SYS_TIME_SUCCESS )  {  // Handle error  }  else  if  ( SYS_TIME_DelayIsComplete ( timer )  = true )  {  // Wait till the delay has not expired  while  ( SYS_TIME_DelayIsComplete ( timer )  == false ) ;  } ",
							" Remarks Will delay the requested number of microseconds or longer depending on system performance In tick-based mode the requested delay will be ceiled to the next timer tick For example if the timer tick is set to 1 msec and the requested delay is 1500 usec a delay of 2 msec will be generated Delay values of 0 will return SYS_TIME_ERROR Will return SYS_TIME_ERROR if timer handle pointer is NULL ",
							" SYS_TIME_DelayMS Function ",
							" C SYS_TIME_RESULT SYS_TIME_DelayMS ( uint32_t ms  SYS_TIME_HANDLE * handle ) ",
							" Summary This function is used to generate a delay of a given number of milliseconds ",
							" Description The function will internally create a single shot timer which will be auto deleted when the application calls SYS_TIME_DelayIsComplete routine and the delay has expired The function will return immediately requiring the caller to use SYS_TIME_DelayIsComplete routine to check the delay timer's status ",
							" Precondition The SYS_TIME_Initialize function must have been called before calling this function ",
							" Parameters Param Description ms The desired number of milliseconds to delay handle Address of the variable to receive the timer handle value ",
							" Returns SYS_TIME_SUCCESS - If the call succeeded SYS_TIME_ERROR - If the call failed ",
							" Example SYS_TIME_HANDLE timer = SYS_TIME_HANDLE_INVALID ;  if  ( SYS_TIME_DelayMS ( 100    timer )  = SYS_TIME_SUCCESS )  {  // Handle error  }  else  if ( SYS_TIME_DelayIsComplete ( timer )  = true )  {  // Wait till the delay has not expired  while  ( SYS_TIME_DelayIsComplete ( timer )  == false ) ;  } ",
							" Remarks Will delay the requested number of milliseconds or longer depending on system performance In tick-based mode the requested delay will be ceiled to the next timer tick For example if the timer tick is set to 700 usec and the requested delay is 2 msec a delay of 2 1 ms will be generated Delay values of 0 will return SYS_TIME_ERROR Will return SYS_TIME_ERROR if the timer handle pointer is NULL ",
							" SYS_TIME_DelayIsComplete Function ",
							" C bool SYS_TIME_DelayIsComplete ( SYS_TIME_HANDLE handle ) ",
							" Summary Determines if the given delay timer has completed ",
							" Description This function determines if the requested delay is completed or is still in progress ",
							" Precondition A delay request must have been created using either the SYS_TIME_DelayMS or SYS_TIME_DelayUS functions ",
							" Parameters Param Description handle A SYS_TIME_HANDLE value provided by either SYS_TIME_DelayMS or SYS_TIME_DelayUS functions ",
							" Returns true - If the delay has completed false - If the delay has not completed ",
							" Example // Check if the delay has expired  if  ( SYS_TIME_DelayIsComplete ( timer )  = true )  {  // Delay has not expired  } ",
							" Remarks SYS_TIME_DelayIsComplete must be called to poll the status of the delay requested through SYS_TIME_DelayMS or SYS_TIME_DelayUS SYS_TIME_DelayIsComplete must not be used to poll the status of a periodic timer Status of a periodic timer may be polled using the SYS_TIME_TimerPeriodHasExpired routine ",
							" SYS_TIME_FrequencyGet Function ",
							" C uint32_t SYS_TIME_FrequencyGet (  void  ) ",
							" Summary Gets the frequency at which the hardwaer timer counts ",
							" Description For tick-less mode this API returns the frequency at which the hardware timer runs For tick-based mode this API returns the frequency at which the hardware timer generates a periodic tick This frequency determines the maximum resolution of all services provided by SYS_TIME ",
							" Precondition The SYS_TIME_Initialize function should have been called before calling this function ",
							" Parameters None ",
							" Returns If the timer has been initialized and is ready: For tick-less mode this API returns the frequency at which the hardware timer runs For tick-based mode this API returns the frequency at which the hardware timer generates a periodic tick Returns 0 if the timer is not initialized ",
							" Example uint32_t frequency =  SYS_TIME_FrequencyGet ( ) ; ",
							" Remarks This frequency is determined by hardware capabilities and how they are configured and initialized ",
							" SYS_TIME_CounterGet Function ",
							" C uint32_t SYS_TIME_CounterGet (  void  ) ",
							" Summary Get the common 32-bit system counter value ",
							" Description Returns the current \"live\" value of the common 32-bit system counter ",
							" Precondition The SYS_TIME_Initialize function should have been called before calling this function ",
							" Parameters None ",
							" Returns The current \"live\" value of the common 32-bit system counter ",
							" Example uint32_t timeStamp1 ; uint32_t timeStamp2 ; uint32_t timeDiffMs ;  // Take first time stamp timeStamp1 =  SYS_TIME_CounterGet ( ) ;  //Perform some tasks  // Take second time stamp timeStamp2 =  SYS_TIME_CounterGet ( ) ;  //Calculate the time difference Use the appropriate function -  //SYS_TIME_CountToMS or SYS_TIME_CountToUS to calculate the time difference timeDiffMs =  SYS_TIME_CountToMS ( ( timeStamp2 - timeStamp1 ) ) ; ",
							" Remarks The value returned may be stale as soon as it is provided as the timer is live and running at full frequency resolution (as configured and as reported by the SYS_TIME_FrequencyGet function) If additional accuracy is required use a hardware timer instance ",
							" SYS_TIME_Counter64Get Function ",
							" C uint64_t SYS_TIME_Counter64Get (  void  ) ",
							" Summary Get the common 64-bit system counter value ",
							" Description Returns the current \"live\" value of the common 64-bit system counter ",
							" Precondition The SYS_TIME_Initialize function should have been called before calling this function ",
							" Parameters None ",
							" Returns The current \"live\" value of the common 64-bit system counter ",
							" Example uint64_t timeStamp1 ; uint64_t timeStamp2 ; uint64_t timeDiffMs ;  // Take first time stamp timeStamp1 =  SYS_TIME_Counter64Get ( ) ;  //Perform some tasks  // Take second time stamp timeStamp2 =  SYS_TIME_Counter64Get ( ) ;  //Calculate the time difference timeDiffMs = timeStamp2 - timeStamp1 ; timeDiffMs =  ( uint64_t ) ( ( ( double ) timeDiffMs / SYS_TIME_FrequencyGet ( ) ) * 1000 0 ) ; ",
							" Remarks The value returned may be stale as soon as it is provided as the timer is live and running at full frequency resolution (as configured and as reported by the SYS_TIME_FrequencyGet function) If additional accuracy is required use a hardware timer instance ",
							" SYS_TIME_CounterSet Function ",
							" C void SYS_TIME_CounterSet ( uint32_t count ) ",
							" Summary Sets the common 32-bit system counter value ",
							" Description Sets the current \"live\" value of the common 32-bit system counter ",
							" Precondition The SYS_TIME_Initialize function should have been called before calling this function ",
							" Parameters Param Description count The 32-bit counter value to write to the common system counter ",
							" Returns None ",
							" Example SYS_TIME_CounterSet(1000); ",
							" Remarks None ",
							" SYS_TIME_CountToUS Function ",
							" C uint32_t SYS_TIME_CountToUS ( uint32_t count ) ",
							" Summary Converts a counter value to time interval in microseconds ",
							" Description This function converts a counter value to time interval in microseconds based on the hardware timer frequency as configured and as reported by SYS_TIME_FrequencyGet ",
							" Precondition The SYS_TIME_Initialize function should have been called before calling this function ",
							" Parameters Param Description count Counter value to be converted to an equivalent value in microseconds ",
							" Returns Number of microseconds represented by the given counter value | ",
							" Example Given a previously captured 32-bit counter value called \"timestamp\" captured using the SYS_TIME_CounterGet function the following example will calculate the number of microseconds elapsed since timestamp was captured uint32_t count =  SYS_TIME_CounterGet ( )  - timestamp ; uint32_t us =  SYS_TIME_CountToUS ( count ) ; ",
							" Remarks None ",
							" SYS_TIME_CountToMS Function ",
							" C uint32_t SYS_TIME_CountToMS ( uint32_t count ) ",
							" Summary Converts a counter value to time interval in milliseconds ",
							" Description This function converts a counter value to time interval in milliseconds based on the hardware timer frequency as configured and as reported by SYS_TIME_FrequencyGet ",
							" Precondition The SYS_TIME_Initialize function should have been called before calling this function ",
							" Parameters Param Description count Counter value to be converted to an equivalent value in milliseconds ",
							" Returns Number of milliseconds represented by the given counter value ",
							" Example Given a previously captured uint32_t counter value called \"timestamp\" captured using the SYS_TIME_CounterGet function the following example will calculate number of milliseconds elapsed since timestamp was captured uint32_t count =  SYS_TIME_CounterGet ( )  - timestamp ; uint32_t ms =  SYS_TIME_CountToMS ( count ) ; ",
							" Remarks None ",
							" SYS_TIME_USToCount Function ",
							" C uint32_t SYS_TIME_USToCount ( uint32_t us ) ",
							" Summary Convert the given time interval in microseconds to an equivalent counter value ",
							" Description This function converts a given time interval (measured in microseconds) to an equivalent 32-bit counter value based on the configured hardware timer frequency as reported by SYS_TIME_FrequencyGet ",
							" Precondition The SYS_TIME_Initialize function should have been called before calling this function ",
							" Parameters Param Description us Time interval in microseconds ",
							" Returns Number of hardware timer counts that will expire in the given time interval ",
							" Example uint32_t futureCounter =  SYS_TIME_CounterGet ( )  +  SYS_TIME_USToCount ( 200 ) ; ",
							" Remarks In tick-based mode the returned count will be ceiled to the next timer tick For example if the timer tick is set to 700 usec and the requested time is 2000 usec a count of 3 will be reported (corresponding to 2100 usec) ",
							" SYS_TIME_MSToCount Function ",
							" C uint32_t SYS_TIME_MSToCount ( uint32_t ms ) ",
							" Summary Convert the given time interval in milliseconds to an equivalent counter value ",
							" Description This function converts a given time interval (measured in milliseconds) to an equivalent 32-bit counter value based on the configured hardware timer frequency as reported by SYS_TIME_FrequencyGet ",
							" Precondition The SYS_TIME_Initialize function should have been called before calling this function ",
							" Parameters Param Description ms Time interval in milliseconds ",
							" Returns Number of hardware timer counts that will expire in the given time interval ",
							" Example uint32_t futureCounter =  SYS_TIME_CounterGet ( )  +  SYS_TIME_MSToCount ( 10 ) ; ",
							" Remarks In tick-based mode the returned count will be ceiled to the next timer tick For example if the timer tick is set to 700 usec and the requested time is 2 msec a count of 3 will be reported (corresponding to 2 1 msec) ",
							" SYS_TIME_TimerCreate Function ",
							" C SYS_TIME_HANDLE SYS_TIME_TimerCreate ( uint32_t count  uint32_t period  SYS_TIME_CALLBACK callback  uintptr_t context  SYS_TIME_CALLBACK_TYPE type ) ; ",
							" Summary Creates and initializes a new 32-bit software timer instance ",
							" Description This function creates/allocates a new instance of a 32-bit software timer A software timer provides a counter that is separate from other timer counters and is under control of the caller The counter can be started and stopped under caller control and its counter value and period value can be changed while the counter is either running or stopped ",
							" Precondition The SYS_TIME_Initialize function should have been called before calling this function ",
							" Parameters Param Description count The initial value of the counter after the timer has been created and before it has been started period The counter interval at which the timer indicates time has elapsed callback Pointer to function that will be called every time the period counts have elapsed (Actual timing will depend on system performance and the base frequency at which the time service is configured) For single shot timers the callback cannot be NULL For periodic timers if the callback pointer is given as NULL no callback will occur but SYS_TIME_TimerPeriodHasExpired can still be polled to determine if the period has expired for a periodic shot timer context A caller-defined value that's passed (unmodified) back to the client as a parameter of callback function It can be used to identify the client's context or passed with any value type Type of callback requested If type is SYS_TIME_SINGLE the Callback function will be called once when the time period expires If type is SYS_TIME_PERIODIC Callback function will be called repeatedly every time the time period expires until the timer object is stopped or deleted ",
							" Returns An opaque value used to identify software timer instance if the call succeeds in allocating/creating the software timer If the call fails SYS_TIME_HANDLE_INVALID is returned ",
							" Example Given an implementation of the following function prototype: void MyCallback ( uintptr_t context ) ; The following example creates a software timer instance SYS_TIME_HANDLE handle ;  //myData is the user-defined data that will be passed back in the registered callback function handle =  SYS_TIME_TimerCreate ( 0   SYS_TIME_MSToCount ( 200 )    MyCallback   ( uintptr_t )  myData  SYS_TIME_SINGLE ) ;  if  ( handle = SYS_TIME_HANDLE_INVALID )  {  //timer is created successfully  } ",
							" Remarks None ",
							" SYS_TIME_TimerReload Function ",
							" C SYS_TIME_RESULT SYS_TIME_TimerReload ( SYS_TIME_HANDLE handle  uint32_t count  uint32_t period  SYS_TIME_CALLBACK callback  uintptr_t context  SYS_TIME_CALLBACK_TYPE type ) ; ",
							" Summary Reloads (or reinitializes) the software timer instance ",
							" Description This function reloads the initial values for an already created/allocated instance of a software timer even if it is currently running ",
							" Precondition The SYS_TIME_Initialize must have been called and a valid handle to the software timer to be reloaded must be available ",
							" Parameters Param Description handle Handle to a software timer instance count The new value of the counter period The new period value callback The new callback function pointer For single shot timers the callback must be specified For periodic timers if the callback pointer is given as NULL no callback will occur but SYS_TIME_TimerPeriodHasExpired can still be polled to determine if the period has expired for a periodic timer context The new caller-defined value that's passed (unmodified) back to the client as a parameter of callback function type Type of callback requested If type is SYS_TIME_SINGLE the Callback function will be called once when the time period expires If type is SYS_TIME_PERIODIC Callback function will be called repeatedly every time the time period expires until the timer object is stopped or deleted ",
							" Returns SYS_TIME_SUCCESS - If the call succeeded SYS_TIME_ERROR - If the call failed (and the timer was not modified) ",
							" Example Given an implementation of the following function prototype: void MyNewCallback ( uintptr_t context ) ; The following example updates a software timer instance //myNewData is the user-defined data that will be passed back in the registered callback function  if  ( SYS_TIME_TimerReload ( timer   0   SYS_TIME_MSToCount ( 500 )    MyNewCallback   ( uintptr_t )  myNewData  SYS_TIME_PERIODIC )  = SYS_TIME_SUCCESS )  {  // Handle error  } ",
							" Remarks This function facilitates changing multiple timer parameters quickly and atomically ",
							" SYS_TIME_TimerDestroy Function ",
							" C SYS_TIME_RESULT SYS_TIME_TimerDestroy ( SYS_TIME_HANDLE handle ) ",
							" Summary Destroys/deallocates a software timer instance ",
							" Description This function deletes and deallocates a software timer instance stopping its counter and releasing the associated resources ",
							" Precondition The SYS_TIME_Initialize and a valid handle to the software timer to be destroyed must be available ",
							" Parameters Param Description handle Handle to a software timer instance ",
							" Returns SYS_TIME_SUCCESS - If the given software was successfully destroyed SYS_TIME_ERROR - If an error occured or the given handle was invalid ",
							" Example // \"timer\" is the handle to the software timer to be destroyed  if  ( SYS_TIME_TimerDestroy ( timer )  = SYS_TIME_SUCCESS )  {  // Handle Error  } ",
							" Remarks Released timer resources can be reused by other clients Single shot timers are auto destroyed on expiry Calling SYS_TIME_DelayIsComplete auto destroys the delay timer if it has expired ",
							" SYS_TIME_TimerCounterGet Function ",
							" C SYS_TIME_RESULT SYS_TIME_TimerCounterGet ( SYS_TIME_HANDLE handle  uint32_t * count ) ; ",
							" Summary Gets the elapsed counter value of a software timer ",
							" Description This function gets the elapsed counter value of the software timer identified by the handle given ",
							" Precondition The SYS_TIME_Initialize must have been called and a valid handle to the software timer must be available ",
							" Parameters Param Description handle Handle to a software timer instance count Address of the variable to receive the value of the given software timer's elapsed counter This parameter is ignored when the return value is not SYS_TIME_SUCCES ",
							" Returns SYS_TIME_SUCCESS if the operation succeeds SYS_TIME_ERROR if the operation fails (due for example to an to an invalid handle) ",
							" Example Given a \"timer\" handle the following example will get the given software timer's elapsed counter value uint32_t count ;  if  ( SYS_TIME_TimerCounterGet ( timer    count )  = SYS_TIME_SUCCESS )  {  // Handle error  } ",
							" Remarks The counter value may be stale immediately upon function return depending upon timer frequency and system performance ",
							" SYS_TIME_TimerStart Function ",
							" C SYS_TIME_RESULT SYS_TIME_TimerStart ( SYS_TIME_HANDLE handle ) ",
							" Summary Starts a software timer running ",
							" Description This function starts a previously created software timer ",
							" Precondition The SYS_TIME_Initialize must have been called and a valid handle to the software timer to be started must be available ",
							" Parameters Param Description handle Handle to a software timer instance ",
							" Returns SYS_TIME_SUCCESS if the operation succeeds SYS_TIME_ERROR if the operation fails (due for example to an to an invalid handle) ",
							" Example Given a \"timer\" handle the following example will start the timer's counter running SYS_TIME_TimerStart ( timer ) ; ",
							" Remarks Calling SYS_TIME_TimerStart on an already running timer will have no affect and will return SYS_TIME_SUCCESS Calling SYS_TIME_TimerStart on a timer that is stopped will always restart the timer from it's initial configured timer/counter value and will not resume the timer from the counter value at which it was stopped ",
							" SYS_TIME_TimerStop Function ",
							" C SYS_TIME_RESULT SYS_TIME_TimerStop ( SYS_TIME_HANDLE handle ) ",
							" Summary Stops a running software timer ",
							" Description This function stops a previously created and running software timer (i e the given timer's counter will stop incrementing) ",
							" Precondition The SYS_TIME_Initialize must have been called and a valid handle to the software timer to be stopped must be available ",
							" Parameters Param Description handle Handle to a software timer instance ",
							" Returns SYS_TIME_SUCCESS if the operation succeeds SYS_TIME_ERROR if the operation fails (due for example to an to an invalid handle) ",
							" Example Given a \"timer\" handle the following example will stops the timer's counter running SYS_TIME_TimerStop ( timer ) ; ",
							" Remarks Calling SYS_TIME_TimerStop on a timer that is not running will have no affect and will return SYS_TIME_SUCCESS ",
							" SYS_TIME_TimerPeriodHasExpired Function ",
							" C bool SYS_TIME_TimerPeriodHasExpired ( SYS_TIME_HANDLE handle ) ",
							" Summary Reports whether or not the current period of a software timer has expired ",
							" Description This function reports whether or not the current period of the given software timer has expired and clears the internal flag tracking period expiration so that each period expiration will only be reported once ",
							" Precondition The SYS_TIME_Initialize and SYS_TIME_TimerCreate or SYS_TIME_CallbackRegisterMS/ SYS_TIME_CallbackRegisterUS functions (with callback type set to SYS_TIME_PERIODIC) must have been called before calling this function ",
							" Parameters Param Description handle Handle to a software timer instance ",
							" Returns true - If the period has expired false - If the period is not expired ",
							" Example if  ( SYS_TIME_TimerPeriodHasExpired ( timer )  == true )  {  // Timer has expired Take desired action  } ",
							" Remarks For a periodic timer a call to SYS_TIME_TimerPeriodHasExpired returns true after the first time period has expired After calling this function the expiry flag is internally cleared and is set again once the ongoing period of the periodic timer expires Unlike the SYS_TIME_DelayIsComplete routine the SYS_TIME_TimerPeriodHasExpired does not delete the timer it just returns the status of the timer To poll the status of the delay timers SYS_TIME_DelayIsComplete must be used instead of the SYS_TIME_TimerPeriodHasExpired routine as SYS_TIME_DelayIsComplete additionally deletes the delay timer object once the delay has expired Since single shot timers does not support polling (registration of a callback is mandatory for single shot timers) the SYS_TIME_CallbackRegisterMS routine must not be used to poll the status of the single shot timers ",
							" SYS_TIME_INIT Struct ",
							" C typedef  struct  _SYS_TIME_INIT SYS_TIME_INIT ; ",
							" Summary Defines the data required to initialize the TIME system service ",
							" Description This data type defines the data required to initialize the TIME system service ",
							" Remarks This structure is implementation specific It is fully defined in sys_time_definitions h ",
							" SYS_TIME_RESULT Enum ",
							" C typedef  enum  {  // Operation completed with success SYS_TIME_SUCCESS   // Invalid handle or operation failed SYS_TIME_ERROR } SYS_TIME_RESULT ;  ",
							" Summary Result of a time service client interface operation ",
							" Description Identifies the result of certain time service operations ",
							" SYS_TIME_HANDLE Typedef ",
							" C typedef uintptr_t SYS_TIME_HANDLE ; ",
							" Summary Handle to a software timer instance ",
							" Description This data type is a handle to a software timer instance It can be used to access and control a software timer ",
							" Remarks Do not rely on the underlying type as it may change in different versions or implementations of the SYS Time service ",
							" SYS_TIME_HANDLE_INVALID Macro ",
							" C # define SYS_TIME_HANDLE_INVALID ((SYS_TIME_HANDLE) (-1)) ",
							" Summary Invalid handle value to a software timer instance ",
							" Description Defines the invalid handle value to a timer instance ",
							" Remarks Do not rely on the actual value as it may change in different versions or implementations of the SYS Time service ",
							" SYS_TIME_CALLBACK_TYPE Enum ",
							" C typedef  enum  {  // Requesting a single (one time) callback SYS_TIME_SINGLE   // Requesting a periodically repeating callback SYS_TIME_PERIODIC } SYS_TIME_CALLBACK_TYPE ;  ",
							" Summary Identifies the type of callback requested (single or periodic) ",
							" Remarks None ",
							" SYS_TIME_CALLBACK Typedef ",
							" C typedef  void  ( * SYS_TIME_CALLBACK )  ( uintptr_t context ) ;  ",
							" Summary Pointer to a time system service callback function ",
							" Description This data type defines a pointer to a time service callback function thus defining the function signature Callback functions may be registered by clients of the time service either when creating a software timer or using the SYS_TIME_Callback shortcut functions ",
							" Precondition The time service must have been initialized using the SYS_TIME_Initialize function before attempting to register a SYS Time callback function ",
							" Parameters Param Description context A context value returned untouched to the client when the callback occurs It can be used to identify the instance of the client who registered the callback ",
							" Returns None ",
							" Example //\"MY_APP_DATA_STRUCT\" is a user defined data structure with \"isTimerExpired\" as  //one of the structure members  void MyCallback ( uintptr_t context )  { MY_APP_DATA_STRUCT * pAppData =  ( MY_APP_DATA_STRUCT * ) context ;  if  ( pAppData =  NULL )  { pAppData - isTimerExpired = true ;  }  } ",
							" Remarks None ",
							" Software Libraries MPLAB Harmony software libraries provide simple highly abstracted C-language software interfaces These software library interfaces can be used directly by the application or by other Harmony modules like drivers Below are few Software libraries provided as part Harmony framework ",
							" Emulated EEPROM The use of FLASH memory technology over EEPROM presents several difficulties over true EEPROM memory; data must be written as a number of physical memory pages (of several bytes each) rather than being individually byte addressable and entire rows of FLASH must be erased before new data may be stored To help abstract these characteristics away from the user application an emulation scheme is implemented to present a more user-friendly API for data storage and retrieval This module provides an EEPROM emulation layer on top of the device's internal NVM controller to provide a standard interface for the reading and writing of non-volatile configuration data This data is placed into the EEPROM emulated section of the device's main FLASH memory storage section the size of which is configured using MHC There are many different algorithms that may be employed for EEPROM emulation using FLASH memory to tune the write and read latencies RAM usage wear levelling and other characteristics As a result multiple different emulator schemes may be implemented so that the most appropriate scheme for a specific application's requirements may be used ",
							" How the Library Works The Emulated EEPROM library is a single-client single-instance interface Abstraction Model The Emulated EEPROM library is built on top of NVM (Non-volatile memory) / EFC (Embedded Flash Controller) PLIB The Emulated EEPROM Library uses the APIs provided by the underlying PLIB and provides a standard interface for the reading and writing of non-volatile configuration data thereby abstracting out the device specific differences in the underlying NVM/EFC PLIBs emulated_eeprom_abstraction_model Working Flow Emulator Characteristics This emulator is designed for best reliability with a good balance of available storage and write cycle limits It is designed to ensure that page data is automatically updated so that in the event of a failed update the previous data is not lost (when used correctly) With the exception of a system reset with data cached to the internal write-cache buffer at most only the latest write to physical non-volatile memory will be lost in the event of a failed write This emulator scheme is tuned to give best write-cycle longevity when writes are confined to the same logical EEPROM page (where possible) and when writes across multiple logical EEPROM pages are made in a linear fashion through the entire emulated EEPROM space Spare Row As data needs to be preserved between row erasures a single FLASH row is kept unused to act as destination for copied data when a write request is made to an already full row When the write request is made any logical pages of data in the full row that need to be preserved are written to the spare row along with the new (updated) logical page data before the old row is erased and marked as the new spare Row Contents Each physical FLASH row initially stores the contents of N/2 logical EEPROM memory pages where N is the total number of pages in one row This halves the available storage space for the emulated EEPROM but reduces the overall number of row erases that are required As logical pages within a physical row are updated the new data is filled into the remaining unused pages in the row Once the entire row is full a new write request will copy the logical page not being written to in the current row to the spare row with the new (updated) logical page data before the old row is erased This system allows for the same logical page to be updated up to N/2 + 1 ( where N is the total number of pages in one row) times into physical memory before a row erasure procedure is needed In the case of multiple versions of the same logical EEPROM page being stored in the same physical row the right-most (highest physical FLASH memory page address) version is considered to be the most current As a small amount of information needs to be stored in a header before the contents of a logical EEPROM page in memory (for use by the emulation service) the available data in each EEPROM page is less than the total size of a single NVM memory page by 4 bytes ",
							" Using The Library The Emulated EEPROM library builds on top of NVM or EFC PLIB and provides uniform interface to read/write to the Emulated EEPROM memory space The library provides APIs to read and write data from/to a logical page It also provides APIs to read/write variable number of data across page boundaries In addition it also provides APIs to format (initialize) the Emulated EEPROM memory region and status API that lets the application know if the Emulated EEPROM region is formatted and valid or not Example application to read and write to Emulated EEPROM # define SIZEOF(s m) ((size_t) sizeof(((s *)0)- m))  # define EMU_EEPROM_READ(MEM DEST) EMU_EEPROM_BufferRead(offsetof(EEPROM_DATA MEM) (uint8_t*)DEST SIZEOF(EEPROM_DATA MEM))  # define EMU_EEPROM_WRITE(MEM DATA) EMU_EEPROM_BufferWrite(offsetof(EEPROM_DATA MEM) (const uint8_t*)DATA SIZEOF(EEPROM_DATA MEM)) APP_DATA appData ; EEPROM_DATA appTestData =  { 0 } ; EEPROM_DATA appRAMCopy =  { 0 } ;  void  APP_BufferFill ( uint8_t * buffer  uint32_t nBytes )  { uint32_t i ;  for  ( i =  0 ; i  nBytes ; i ++ )  { buffer [ i ]  = i ;  }  }  void APP_Initialize (  void  )  {  /* Place the App state machine in its initial state */ appData  state = APP_STATE_INIT ;  }  void APP_Tasks (  void  )  { EMU_EEPROM_STATUS libStatus ;  /* Check the application's current state */  switch  ( appData  state )  {  /* Application's initial state */  case APP_STATE_INIT : libStatus =  EMU_EEPROM_StatusGet ( ) ;  if  ( libStatus == EMU_EEPROM_STATUS_OK )  { appData  state = APP_STATE_WRITE_DATA ;  }  else  if  ( ( libStatus == EMU_EEPROM_STATUS_ERR_BAD_FORMAT )  ||  ( libStatus == EMU_EEPROM_STATUS_ERR_NOT_INITIALIZED ) )  {  /* Format EEPROM memory space */  EMU_EEPROM_FormatMemory ( ) ; appData  state = APP_STATE_LIB_STATUS_VERIFY ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  case APP_STATE_LIB_STATUS_VERIFY :  /* Make sure the EEPROM Emulator is initialized successfully after it was formatted */ libStatus =  EMU_EEPROM_StatusGet ( ) ;  if  ( libStatus == EMU_EEPROM_STATUS_OK )  { appData  state = APP_STATE_WRITE_DATA ;  }  else  { appData  state = APP_STATE_ERROR ;  }  break ;  case APP_STATE_WRITE_DATA :  /* For demonstration purpose write some random values to EEPROM memory region */ appTestData  var_1 =  0x0A ;  EMU_EEPROM_WRITE ( var_1    appTestData  var_1 ) ; appTestData  var_2 =  0x1234 ;  EMU_EEPROM_WRITE ( var_2    appTestData  var_2 ) ; appTestData  var_3 =  0x33445566 ;  EMU_EEPROM_WRITE ( var_3    appTestData  var_3 ) ; appTestData  var_7 =  0x3189AB1C ;  EMU_EEPROM_WRITE ( var_7    appTestData  var_7 ) ; appTestData  var_7 =  0x9A7BC123 ;  EMU_EEPROM_WRITE ( var_7    appTestData  var_7 ) ; appTestData  var_2 =  0x1256 ;  EMU_EEPROM_WRITE ( var_2    appTestData  var_2 ) ; appTestData  var_7 =  0x882B7C9A ;  EMU_EEPROM_WRITE ( var_7    appTestData  var_7 ) ; appTestData  var_2 =  0x7788 ;  EMU_EEPROM_WRITE ( var_2    appTestData  var_2 ) ;  APP_BufferFill ( appTestData  buffer_1   sizeof  ( appTestData  buffer_1 ) ) ;  EMU_EEPROM_WRITE ( buffer_1    appTestData  buffer_1 ) ; appTestData  var_11 =  0x7498AFDD ;  EMU_EEPROM_WRITE ( var_11    appTestData  var_11 ) ; appTestData  var_7 =  0x1788BB8D ;  EMU_EEPROM_WRITE ( var_7    appTestData  var_7 ) ; appTestData  var_10 =  0x7744AABB ;  EMU_EEPROM_WRITE ( var_10    appTestData  var_10 ) ; appTestData  var_2 =  0x9922 ;  EMU_EEPROM_WRITE ( var_2    appTestData  var_2 ) ; appTestData  var_5 =  0x59AF ;  EMU_EEPROM_WRITE ( var_5    appTestData  var_5 ) ; appTestData  var_9 =  0x99AA ;  EMU_EEPROM_WRITE ( var_9    appTestData  var_9 ) ; appTestData  var_10 =  0x88888888 ;  EMU_EEPROM_WRITE ( var_10    appTestData  var_10 ) ; appTestData  var_12 =  0x5577 ;  EMU_EEPROM_WRITE ( var_12    appTestData  var_12 ) ; appTestData  var_10 =  0x1AC87439 ;  EMU_EEPROM_WRITE ( var_10    appTestData  var_10 ) ; appTestData  var_8 =  0x752B9ACE ;  EMU_EEPROM_WRITE ( var_8    appTestData  var_8 ) ; appTestData  var_2 =  0xA765 ;  EMU_EEPROM_WRITE ( var_2    appTestData  var_2 ) ; appTestData  var_4 =  0xA7 ;  EMU_EEPROM_WRITE ( var_4    appTestData  var_4 ) ; appTestData  var_9 =  0xEEF1 ;  EMU_EEPROM_WRITE ( var_9    appTestData  var_9 ) ; appTestData  var_6 =  0xF497 ;  EMU_EEPROM_WRITE ( var_6    appTestData  var_6 ) ;  /* Commit any data that may be in EEPROM Emulator library's cache to physical memory */  EMU_EEPROM_PageBufferCommit ( ) ; appData  state = APP_STATE_READ_DATA ;  break ;  case APP_STATE_READ_DATA :  /* Randomly read back the written values */  EMU_EEPROM_READ ( var_2    appRAMCopy  var_2 ) ;  EMU_EEPROM_READ ( var_3    appRAMCopy  var_3 ) ;  EMU_EEPROM_READ ( var_7    appRAMCopy  var_7 ) ;  EMU_EEPROM_READ ( var_9    appRAMCopy  var_9 ) ;  EMU_EEPROM_READ ( var_10    appRAMCopy  var_10 ) ;  EMU_EEPROM_READ ( var_12    appRAMCopy  var_12 ) ;  EMU_EEPROM_READ ( var_1    appRAMCopy  var_1 ) ;  EMU_EEPROM_READ ( var_6    appRAMCopy  var_6 ) ;  EMU_EEPROM_READ ( var_8    appRAMCopy  var_8 ) ;  EMU_EEPROM_READ ( var_11    appRAMCopy  var_11 ) ;  EMU_EEPROM_READ ( buffer_1    appRAMCopy  buffer_1 ) ;  EMU_EEPROM_READ ( var_4    appRAMCopy  var_4 ) ;  EMU_EEPROM_READ ( var_5    appRAMCopy  var_5 ) ; appData  state = APP_STATE_VERIFY ;  break ;  case APP_STATE_VERIFY :  if  ( memcmp ( ( void  const * )  appRAMCopy   ( void  const * )  appTestData   sizeof  ( EEPROM_DATA ) )  ==  0 )  {  LED_On ( ) ;  }  else  {  LED_Off ( ) ;  } appData  state = APP_STATE_IDLE ;  break ;  case APP_STATE_IDLE :  break ;  case APP_STATE_ERROR :  break ;  /* TODO: implement your application state machine */  /* The default state should never be executed */  default :  {  /* TODO: Handle error in application's state machine */  break ;  }  }  }  ",
							" Configuring The Library Emulated EEPROM Library should be configured via MHC The following figures show the MHC configuration window for Emulated EEPROM and brief description Emulated EEPROM in Project Gaph emulated_eeprom_mhc_config_project_graph Emulated EEPROM library with Main Array region used for EEPROM Emulation address space on Cortex M0+ devices The EEPROM size is configured through fuse settings in MHC on M0+ devices emulated_eeprom_mhc_config_with_main_array_cortex_m0 Emulated EEPROM library with RWWEE region used for EEPROM Emulation address space on Cortex M0+ devices The RWWEE size is fixed and it uses the full RWWEE space available on that device emulated_eeprom_mhc_config_with_rwwee_cortex_m0 Emulated EEPROM library with Main Array region used for EEPROM Emulation address space on Cortex M4/M7 devices emulated_eeprom_mhc_config_with_main_array_cortex_m4_m7 Configuration Options EEPROM Emulation Address Space Indicates the memory space used for EEPROM Emulation EEPROM Size (in Erase Sectors) Size of EEPROM Emulation region specified by user in terms of Erase sectors For example on SAM E70 the erase sector size is 8192 bytes Hence EEPROM Emulation region must be atleast 16384 bytes or more This is because one sector will be reserved as spare and the data from full row will be copied to the spare row when a write request is made to the full row EEPROM Start Address / EEPROM Emulation Start Address Indicates the start address of the EEPROM Emulation region If main array is used then the EEPROM Emulation region is allocated from the end of the main array For example if the total size of main array is 256 KB (0x40000) and the EEPROM Emulation size is 2048 bytes then the 2048 bytes will be allocated from the end of the main array and the EEPROM Emulation region will start from 256KB - 2KB = 254KB (0x3F800) If RWWEE region is used the EEPROM Emulation region is allocated from the start of the RWWEE region and the entire RWWEE region is used as EEPROM Emulation region Number of Physical Pages Indicates total number of physical pages in the EEPROM Emulation region For example on M0+ devices a page is of 64 bytes Hence if EEPROM Emulation region size is 2048 bytes total number of physical pages will be 2048/64 = 32 Number of Logical Pages Indicates total number of logical pages in the EEPROM Emulation region For example on M0+ devices a row consists of 4 pages On such devices each row only stores data for 2 logical pages Hence the total number of logical pages is halved In addition one row (4 pages) are reserved for spare row Hence if the total number of physical pages in EEPROM Emulation region is 32 (i e 8 rows) the number of local pages will be: Total Rows - Spare Row = 8 - 1 = 7 rows Each row can store 2 logical pages Hence total logical pages = 7 * 2 = 14 logical pages Logical EEPROM Size (Bytes) Indicates total logical space available in terms of bytes Each page reserves 4 bytes for storing internal data which is used by the EEPROM Emulation library Hence if the total number of logical pages is 14 and if the page size is 64 bytes then total logical EEPROM size in bytes will be 14 x (64-4) = 14 x 60 = 840 bytes Note: In each case the total size of EEPROM Emulation region must be greater than or equal to two Erase Sectors For example on SAM C21 the erase size is one row Size of one row is 256 bytes Hence EEPROM Emulation region must be 512 bytes or more Similarly on SAM E70 the erase size is 8192 bytes Hence EEPROM Emulation region must be atleast 16384 bytes or more ",
							" Library Interface Emulated EEPROM library provides the following interfaces: Functions Name Description EMU_EEPROM_Initialize Initializes the EEPROM Emulator library EMU_EEPROM_StatusGet Gets the current status of the EEPROM Emulator library EMU_EEPROM_FormatMemory Erases the entire emulated EEPROM memory space EMU_EEPROM_ParametersGet Returns EEPROM Emulation configuration parameters EMU_EEPROM_PageBufferCommit Commits any cached data to physical non-volatile memory EMU_EEPROM_PageWrite Writes a page of data to an emulated EEPROM memory page EMU_EEPROM_PageRead Reads a page of data from an emulated EEPROM memory page EMU_EEPROM_BufferWrite Writes a buffer of data to the emulated EEPROM memory space EMU_EEPROM_BufferRead Reads a buffer of data from the emulated EEPROM memory space Data types and constants Name Type Description EMU_EEPROM_STATUS Enum Identifies the current status/state of EEPROM operation EMU_EEPROM_PARAMETERS Struct Provides different Emulated EEPROM configuration paramters ",
							" EMU_EEPROM_Initialize Function ",
							" C SYS_MODULE_OBJ EMU_EEPROM_Initialize ( const SYS_MODULE_INDEX drvIndex   const SYS_MODULE_INIT *  const init ) ",
							" Summary Initializes the EEPROM Emulator library ",
							" Description Initializes the emulated EEPROM memory space; if the emulated EEPROM memory has not been previously initialized it will need to be explicitly formatted via EMU_EEPROM_EraseMemory() The EEPROM memory space will not be automatically erased by the initialization function so that partial data may be recovered by the user application manually if the service is unable to initialize successfully ",
							" Precondition None ",
							" Parameters Param Description drvIndex Identifier for the instance to be initialized init Pointer to the init data structure containing any data necessary to initialize the driver ",
							" Returns If successful returns a valid handle to a driver instance object Otherwise returns SYS_MODULE_OBJ_INVALID ",
							" Example // The following code snippet shows an example I2C driver initialization sysObj  libEMULATED_EEPROM0 =  EMU_EEPROM_Initialize ( EMULATED_EEPROM0   ( SYS_MODULE_INIT * ) NULL ) ;  ",
							" Remarks This routine must be called before any other EEPROM Emulation library routine is called This routine should only be called once during system initialization ",
							" EMU_EEPROM_StatusGet Function ",
							" C EMU_EEPROM_STATUS EMU_EEPROM_StatusGet (  void  ) ",
							" Summary Gets the current status of the EEPROM Emulator library ",
							" Description This routine provides the status of the EEPROM Emulator library ",
							" Precondition Function EMU_EEPROM_Initialize should have been called before calling this function ",
							" Parameters None ",
							" Returns EMU_EEPROM_STATUS - Enum of type EMU_EEPROM_STATUS Status code indicating the status of the operation ",
							" Example if  ( EMU_EEPROM_StatusGet ( )  == EMU_EEPROM_STATUS_ERR_BAD_FORMAT )  {  //Format the EEPROM Emulation memory if the initialization failed  EMU_EEPROM_FormatMemory ( ) ;  } ",
							" Remarks None ",
							" EMU_EEPROM_FormatMemory Function ",
							" C bool EMU_EEPROM_FormatMemory ( void ) ",
							" Summary Erases the entire emulated EEPROM memory space ",
							" Description Erases the entire emulated EEPROM memory space and formats it ",
							" Precondition Function EMU_EEPROM_Initialize should have been called before calling this function ",
							" Parameters None ",
							" Returns True - Memory is formatted successfully False - Error during formatting ",
							" Example if  ( EMU_EEPROM_Status ( )  == SYS_STATUS_UNINITIALIZED )  {  //Format the EEPROM Emulation memory if the initialization failed  EMU_EEPROM_FormatMemory ( ) ;  } ",
							" Remarks None ",
							" EMU_EEPROM_ParametersGet Function ",
							" C EMU_EEPROM_STATUS EMU_EEPROM_ParametersGet ( EMU_EEPROM_PARAMETERS * const parameters ) ",
							" Summary Returns EEPROM Emulation configuration parameters ",
							" Description Retrieves the configuration parameters of the EEPROM Emulator ",
							" Precondition Function EMU_EEPROM_Initialize should have been called before calling this function ",
							" Parameters Param Description parameters pointer to variable of type EMU_EEPROM_PARAMETERS ",
							" Returns EMU_EEPROM_STATUS - Enum of type EMU_EEPROM_STATUS ",
							" Example EMU_EEPROM_PARAMETERS param ;  EMU_EEPROM_ParametersGet (  param ) ; ",
							" Remarks None ",
							" EMU_EEPROM_PageBufferCommit Function ",
							" C EMU_EEPROM_STATUS EMU_EEPROM_PageBufferCommit ( void ) ",
							" Summary Commits any cached data to physical non-volatile memory ",
							" Description Commits the internal SRAM caches to physical non-volatile memory to ensure that any outstanding cached data is preserved This function should be called prior to a system reset or shutdown to prevent data loss ",
							" Precondition Function EMU_EEPROM_Initialize should have been called before calling this function ",
							" Parameters None ",
							" Returns EMU_EEPROM_STATUS - Enum of type EMU_EEPROM_STATUS Status code indicating the status of the operation ",
							" Example EMU_EEPROM_PageBufferCommit ( ) ; ",
							" Remarks None ",
							" EMU_EEPROM_PageWrite Function ",
							" C EMU_EEPROM_STATUS EMU_EEPROM_PageWrite (  const uint8_t logical_page   const uint8_t * const data ) ; ",
							" Summary Writes a page of data to an emulated EEPROM memory page ",
							" Description Writes an emulated EEPROM page of data to the emulated EEPROM memory space ",
							" Precondition Function EMU_EEPROM_Initialize should have been called before calling this function ",
							" Parameters Param Description logical_page Logical EEPROM page number to write to data Pointer to the data buffer containing source data to write ",
							" Returns EMU_EEPROM_STATUS - Enum of type EMU_EEPROM_STATUS Status code indicating the status of the operation ",
							" Example uint8_t my_buffer [ EMU_EEPROM_PAGE_DATA_SIZE ] ;  EMU_EEPROM_PageWrite ( 0  my_buffer ) ; ",
							" Remarks Data stored in pages may be cached in volatile RAM memory; to commit any cached data to physical non-volatile memory the EMU_EEPROM_CachedDataCommit() function should be called ",
							" EMU_EEPROM_PageRead Function ",
							" C EMU_EEPROM_STATUS EMU_EEPROM_PageRead (  const uint8_t logical_page  uint8_t * const dat ) ; ",
							" Summary Reads a page of data from an emulated EEPROM memory page ",
							" Description Reads an emulated EEPROM page of data from the emulated EEPROM memory space ",
							" Precondition Function EMU_EEPROM_Initialize should have been called before calling this function ",
							" Parameters Param Description logical_page Logical EEPROM page number to read from data Pointer to the destination data buffer to fill ",
							" Returns EMU_EEPROM_STATUS - Enum of type EMU_EEPROM_STATUS Status code indicating the status of the operation ",
							" Example uint8_t my_buffer [ EMU_EEPROM_PAGE_DATA_SIZE ] ;  EMU_EEPROM_PageRead ( 0  my_buffer ) ; ",
							" Remarks None ",
							" EMU_EEPROM_BufferWrite Function ",
							" C EMU_EEPROM_STATUS EMU_EEPROM_BufferWrite (  const uint16_t offset   const uint8_t * const data   const uint16_t length ) ; ",
							" Summary Writes a buffer of data to the emulated EEPROM memory space ",
							" Description Writes a buffer of data to a section of emulated EEPROM memory space The source buffer may be of any size and the destination may lie outside of an emulated EEPROM page boundary ",
							" Precondition Function EMU_EEPROM_Initialize should have been called before calling this function ",
							" Parameters Param Description offset Starting byte offset to write to in emulated EEPROM memory space data Pointer to the data buffer containing source data to write length Length of the data to write in bytes ",
							" Returns EMU_EEPROM_STATUS - Enum of type EMU_EEPROM_STATUS Status code indicating the status of the operation ",
							" Example uint8_t my_buffer [ 5 ] ;  EMU_EEPROM_BufferWrite ( 0  my_buffer   5 ) ; ",
							" Remarks Data stored in pages may be cached in volatile RAM memory; to commit any cached data to physical non-volatile memory the EMU_EEPROM_CachedDataCommit() function should be called ",
							" EMU_EEPROM_BufferRead Function ",
							" C EMU_EEPROM_STATUS EMU_EEPROM_BufferRead (  const uint16_t offset  uint8_t * const data   const uint16_t length ) ; ",
							" Summary Reads a buffer of data from the emulated EEPROM memory space ",
							" Description Reads a buffer of data from a section of emulated EEPROM memory space The destination buffer may be of any size and the source may lie outside of an emulated EEPROM page boundary ",
							" Precondition Function EMU_EEPROM_Initialize should have been called before calling this function ",
							" Parameters Param Description offset Starting byte offset to read from in emulated EEPROM memory space data Pointer to the destination data buffer to fill length Length of the data to read in bytes ",
							" Returns EMU_EEPROM_STATUS - Enum of type EMU_EEPROM_STATUS Status code indicating the status of the operation ",
							" Example uint8_t my_buffer [ 5 ] ;  EMU_EEPROM_BufferRead ( 0  my_buffer   5 ) ; ",
							" Remarks None } ",
							" EMU_EEPROM_STATUS Enum ",
							" C typedef  enum  {  /* Operation is successful or EEPROM Emulator is successfully initialized */ EMU_EEPROM_STATUS_OK   /* No EEPROM section has been allocated in the device */ EMU_EEPROM_STATUS_ERR_NO_MEMORY   /* If an address outside the valid emulated EEPROM memory space was supplied */ EMU_EEPROM_STATUS_ERR_BAD_ADDRESS   /* Emulated EEPROM memory is corrupt or not formatted or is incompatible with this version or scheme of the EEPROM emulator*/ EMU_EEPROM_STATUS_ERR_BAD_FORMAT   /* Emulated EEPROM is not initialized */ EMU_EEPROM_STATUS_ERR_NOT_INITIALIZED } EMU_EEPROM_STATUS ;  ",
							" Summary Identifies the current status/state of EEPROM operation ",
							" Description This enumeration identifies the current status/state of the EEPROM operation ",
							" Remarks None ",
							" EMU_EEPROM_PARAMETERS Struct ",
							" C typedef  struct  {  /** Number of bytes per emulated EEPROM page */ uint16_t page_size ;  /** Number of emulated pages of EEPROM */ uint16_t eeprom_num_logical_pages ;  /** Logical size of emulated EEPROM */ uint32_t eeprom_logical_size ;  } EMU_EEPROM_PARAMETERS ;  ",
							" Summary Provides different Emulated EEPROM configuration paramters ",
							" Description This structure provides configuration parameters for the Emulated EEPROM This structure object has to be passed to EMU_EEPROM_ParametersGet() API to retreive the current configured parameters ",
							" Remarks None ",
							" I2C Bit Bang The I2C bit bang library is a software library that implements the I2C master mode serial communication standard The I2C bit bang library uses a timer peripheral to generate the I2C waveforms at the configured I2C clock speed ",
							" How the Library Works The I2C Bit Bang library is a single-client single-instance interface Working Flow It uses a timer peripheral to generate the I2C waveforms at the configured I2C clock speed The block of data is transferred in a non-blocking manner using the timer peripheral interrupt Application can register a callback to get notified when the I2C transfer is complete Once the transfer is complete the lirary calls the callback registered by the application from the timer interrupt context or the application can poll the status of the transfer ",
							" Using The Library The I2C bit bang library supports the following I2C transfers: Master Write: The master writes a block of data to the slave Master Read: The master reads a block of data from the slave Master Write/Read: The master writes and then reads back a block of data from slave The I2C Bit bang library can be directly used by application or can be used with I2C driver to perform read and write operations Example application to write using callback method # define APP_SLAVE_ADDR 0x0057  # define NUM_BYTES 10 uint8_t myWriteData [ NUM_BYTES ]  =  { '1'   '0'   ' '   'B'   'Y'   'T'   'E'   'S'   ' '   ' '  } ;  void  I2C_BB_Callback ( uintptr_t context )  {  if ( I2C_BB_ErrorGet ( )  == I2CBB_ERROR_NONE )  {  //Transfer is completed successfully  }  else  {  //Error occurred during transfer  }  }  int  main ( void )  {  /* Register Callback function */  I2C_BB_CallbackRegister ( I2C_BB_Callback   ( uintptr_t ) NULL ) ;  /* Submit Write Request */  I2C_BB_Write ( APP_SLAVE_ADDR    myWriteData [ 0 ]  NUM_BYTES ) ;  /* Perform other tasks The I2C_BB_Callback will be called when the write transfer is complete */  }  ",
							" Configuring The Library I2C Bit Bang Library should be configured via MHC The following figures show the MHC configuration window for I2C Bit Bang and brief description I2C Bit Bang Configuration i2c_bb_mhc_config I2C Bit Bang Configuration wih I2C Driver i2c_bb_mhc_config_with_i2c_driver Configuration Options I2CBB Operation Mode: Indicates the I2C mode used by the library The I2C bit bang library only supports master mode I2CBB Clock Speed: Specifies the I2C clock speed in Hz I2CBB Data Pin: Specifies the GPIO pin number to be configured as I2C Data Line The specified pin has to be configured as GPIO input and open drain has to be enabled I2CBB Clock Pin: Specifies the GPIO pin number to be configured as I2C Clock Line The specified pin has to be configured as GPIO input and open drain has to be enabled Include Force Write I2C Function: when enabled generates the I2C force write API which can be used to perform force writes to I2C slave The generated API ignores any NACK from slave during the write Used in Master mode only ",
							" Library Interface I2C Bit Bang library provides the following interfaces: Functions Name Description I2C_BB_Initialize Initializes the instance of the I2C bit bang library I2C_BB_Read Reads data from the slave I2C_BB_Write Writes data to the slave I2C_BB_WriteForced Force writes data to the slave I2C_BB_WriteRead Write and Read data from Slave I2C_BB_ErrorGet Returns the error occurred during transfer I2C_BB_IsBusy Returns the state of the library I2C_BB_TransferSetup Dynamic setup of I2C Bit Bang Library I2C_BB_CallbackRegister Sets the pointer to the function (and it's context) to be called when the given I2C's transfer events occur Data types and constants Name Type Description I2CBB_ERROR Enum I2C Bit Bang Transfer Status data type I2CBB_TRANSFER_SETUP Struct I2C Bit Bang Transfer Setup Data Structure I2CBB_CALLBACK Typedef I2C bit bang library callback function pointer ",
							" I2C_BB_Initialize Function ",
							" C void  I2C_BB_Initialize ( void ) ",
							" Summary Initializes the instance of the I2C bit bang library ",
							" Description This function initializes the given instance of the I2C bit bang as configured by the user from the MHC ",
							" Precondition None ",
							" Parameters None ",
							" Returns None ",
							" Example I2C_BB_Initialize ( ) ; ",
							" Remarks None ",
							" I2C_BB_Read Function ",
							" C bool I2C_BB_Read ( uint16_t address  uint8_t * pdata  size_t length ) ",
							" Summary Reads data from the slave ",
							" Description This function reads the data from a slave on the bus The function will attempt to read length number of bytes into pdata buffer from a slave whose address is specified as address The I2C Master generates a Start condition reads the data and then generates a Stop Condition If the slave NAKs the request the transfer is terminated The application can call I2C_BB_ErrorGet() function to know the cause of the error The function is non-blocking It initiates bus activity and returns immediately The transfer is completed in the timer peripheral interrupt A transfer request cannot be placed when another transfer is in progress Calling the read function when another function is already in progress will cause the function to return false The library will call the registered callback function when the transfer has terminated if callback is registered ",
							" Precondition I2C_BB_Initialize must have been called for the associated I2C instance ",
							" Parameters Param Description address 7-bit / 10-bit slave address pdata pointer to destination data buffer where the received data should be stored length length of data buffer in number of bytes Also the number of bytes to be read ",
							" Returns true - The request was placed successfully and the bus activity was initiated false - The request fails if there was already a transfer in progress when this function was called ",
							" Example uint8_t myData [ NUM_BYTES ] ;  void  MyI2CCallback ( uintptr_t context )  {  // This function will be called when the transfer completes Note  // that this function executes in the context of the timer peripheral  // interrupt  }  I2C_BB_Initialize ( ) ;  I2C_BB_CallbackRegister ( MyI2CCallback   NULL ) ;  if ( I2C_BB_Read ( SLAVE_ADDR    myData [ 0 ]  NUM_BYTES )  == false )  {  // error handling  }  ",
							" Remarks None ",
							" I2C_BB_Write Function ",
							" C bool I2C_BB_Write ( uint16_t address  uint8_t * pdata  size_t length ) ",
							" Summary Writes data to the slave ",
							" Description This function writes data to a slave on the bus The function will attempt to write length number of bytes from pdata buffer to a slave whose address is specified by address The I2C Master will generate a Start condition write the data and then generate a Stop Condition If the slave NAKs the request the transfer is terminated The application can call the I2C_BB_ErrorGet() function to know that cause of the error The function is non-blocking It initiates bus activity and returns immediately The transfer is then completed in the timer peripheral interrupt A transfer request cannot be placed when another transfer is in progress Calling the write function when another function is already in progress will cause the function to return false The library will call the registered callback function when the transfer has terminated ",
							" Precondition I2C_BB_Initialize must have been called for the associated I2C instance ",
							" Parameters Param Description address 7-bit / 10-bit slave address pdata pointer to source data buffer that contains the data to be written length length of data buffer in number of bytes Also the number of bytes to be written ",
							" Returns true - The request was placed successfully and the bus activity was initiated false - The request fails if there was already a transfer in progress when this function was called ",
							" Example uint8_t myData [ NUM_BYTES ] ;  void  MyI2CCallback ( uintptr_t context )  {  // This function will be called when the transfer completes Note  // that this function executes in the context of the I2C interrupt  }  I2C_BB_Initialize ( ) ;  I2C_BB_CallbackRegister ( MyI2CCallback   NULL ) ;  if ( I2C_BB_Write ( SLAVE_ADDR    myData [ 0 ]  NUM_BYTES )  == false )  {  // error handling  }  ",
							" Remarks None ",
							" I2C_BB_WriteForced Function ",
							" C bool I2C_BB_WriteForced ( uint16_t address  uint8_t * pdata  size_t length ) ",
							" Summary Force writes data to the slave ",
							" Description I2C Master calls this function to transmit the entire buffer to the slave even if the slave ACKs or NACKs the address or any of the data bytes This is typically used for slaves that have to initiate a reset sequence by sending a dummy I2C transaction Since the slave is still in reset any or all the bytes can be NACKed In the normal operation if the address or data byte is NACKed then the transmission is aborted and a STOP condition is asserted on the bus The function is non-blocking It initiates bus activity and returns immediately The transfer is then completed in the timer peripheral interrupt A transfer request cannot be placed when another transfer is in progress Calling the write forced function when another function is already in progress will cause the function to return false The library will call the registered callback function when the transfer has terminated ",
							" Precondition I2C_BB_Initialize must have been called for the associated I2C instance ",
							" Parameters Param Description address 7-bit / 10-bit slave address pdata pointer to source data buffer that contains the data to be written length length of data buffer in number of bytes Also the number of bytes to be written ",
							" Returns true - The request was placed successfully and the bus activity was initiated false - The request fails if there was already a transfer in progress when this function was called ",
							" Example uint8_t myData [ NUM_BYTES ] ;  void  MyI2CCallback ( uintptr_t context )  {  // This function will be called when the transfer completes Note  // that this function executes in the context of the I2C interrupt  }  I2C_BB_Initialize ( ) ;  I2C_BB_CallbackRegister ( MyI2CCallback   NULL ) ;  if ( I2C_BB_WriteForced ( SLAVE_ADDR    myData [ 0 ]  NUM_BYTES )  == false )  {  // error handling  }  ",
							" Remarks This API will be generated only if Forced Write option is enabled in MHC ",
							" I2C_BB_WriteRead Function ",
							" C bool I2C_BB_WriteRead ( uint16_t address  uint8_t * wdata  size_t wlength  uint8_t * rdata  size_t rlength ) ",
							" Summary Write and Read data from Slave ",
							" Description This function writes data from the wdata to the bus and then reads data from the slave and stores the received in the rdata The function generates a Start condition on the bus and will then send wlength number of bytes contained in wdata The function will then insert a Repeated start condition and proceed to read rlength number of bytes from the slave The received bytes are stored in rdata buffer A Stop condition is generated after the last byte has been received If the slave NAKs the request the transfer is terminated The application can call I2C_BB_ErrorGet() function to know that cause of the error The function is non-blocking It initiates bus activity and returns immediately The transfer is then completed in the timer peripheral interrupt A transfer request cannot be placed when another transfer is in progress Calling this function when another function is already in progress will cause the function to return false The library will call the registered callback function when the transfer has terminated ",
							" Precondition I2C_BB_Initialize must have been called for the associated I2C instance ",
							" Parameters Param Description address 7-bit / 10-bit slave address wdata pointer to write data buffer wlength write data length in bytes rdata pointer to read data buffer rlength read data length in bytes ",
							" Returns true - The request was placed successfully and the bus activity was initiated false - The request fails if there was already a transfer in progress when this function was called ",
							" Example uint8_t myTxData [ NUM_TX_BYTES ]  =  { '1'   '0'   ' '   'B'   'Y'   'T'   'E'   'S' } ; uint8_t myRxData [ NUM_RX_BYTES ]  =  { 0 } ;  void  MyI2CCallback ( uintptr_t context )  {  // This function will be called when the transfer completes Note  // that this function executes in the context of the I2C interrupt  }  I2C_BB_Initialize ( ) ;  I2C_BB_CallbackRegister ( MyI2CCallback   NULL ) ;  if ( I2C_BB_WriteRead ( SLAVE_ADDR    myTxData [ 0 ]  NUM_TX_BYTES  myRxData  NUM_RX_BYTES )  == false )  {  // error handling  }  ",
							" Remarks Calling this function is not the same as calling the I2C_BB_Write() function and then calling the I2C_BB_Read() function The I2C_BB_WriteRead function will insert a Repeated Start condition between the Write and the Read stages The I2C_BB_Write() and the I2C_BB_Read() function insert a stop condition after the write and the read has completed ",
							" I2C_BB_ErrorGet Function ",
							" C I2CBB_ERROR I2C_BB_ErrorGet ( void ) ",
							" Summary Returns the error occurred during transfer ",
							" Description This function returns the error during transfer ",
							" Precondition I2C_BB_Initialize must have been called for the associated I2C instance ",
							" Parameters None ",
							" Returns Returns a I2CBB_ERROR type of status identifying the error that has occurred ",
							" Example if ( I2C_BB_ErrorGet ( )  == I2CBB_ERROR_NONE )  {  //I2C transfer is completed go to next state  } ",
							" Remarks None ",
							" I2C_BB_IsBusy Function ",
							" C bool I2C_BB_IsBusy ( void ) ",
							" Summary Returns the state of the library ",
							" Description This function returns if the library is busy performing a read/write operation This API can be used to poll for the state of library if no callback is registered ",
							" Precondition I2C_BB_Initialize must have been called for the associated I2C instance ",
							" Parameters None ",
							" Returns true - If busy performing Read or Write operation false - If ready to accept new Read or Write request ",
							" Example I2C_BB_Initialize ( ) ;  if ( I2C_BB_WriteRead ( SLAVE_ADDR    myTxData [ 0 ]  NUM_TX_BYTES  myRxData  NUM_RX_BYTES )  == false )  {  // error handling  }  while  ( I2C_BB_IsBusy ( )  == true )  {  //I2C transfer is in progress  }  ",
							" Remarks None ",
							" I2C_BB_TransferSetup Function ",
							" C bool I2C_BB_TransferSetup ( I2CBB_TRANSFER_SETUP * setup  uint32_t tmrSrcClkFreq ) ",
							" Summary Dynamic setup of I2C Bit Bang Library ",
							" Description This API is generally used when there are multiple clients on the same I2C bus having different I2C clock speed In such a case the I2C_BB_TransferSetup API must be called to set the appropriate I2C bus speed before starting the I2C transfer for the I2C slave ",
							" Precondition I2C_BB_Initialize must have been called for the associated I2C instance The transfer status should not be busy ",
							" Parameters Param Description setup Pointer to the structure containing the transfer setup tmrSrcClkFreq Timer Peripheral Clock Source Frequency ",
							" Returns true - Transfer setup was updated Successfully false - Failure while updating transfer setup ",
							" Example I2C_TRANSFER_SETUP setup ; setup  clkSpeed =  400000 ;  // Make sure that the I2C is not busy before changing the I2C clock frequency  if  ( I2C_BB_IsBusy ( )  == false )  {  if  ( I2C_BB_TransferSetup (   setup   0  )  == true )  {  // Transfer Setup updated successfully  }  } ",
							" Remarks The timer period will be changed based on the new I2C clock speed when an I2C request is submitted ",
							" I2C_BB_CallbackRegister Function ",
							" C void  I2C_BB_CallbackRegister ( I2CBB_CALLBACK callback  uintptr_t contextHandle ) ",
							" Summary Sets the pointer to the function (and it's context) to be called when the given I2C's transfer events occur ",
							" Description This function sets the pointer to a client function to be called \"back\" when the given I2C transfer events occur It also passes a context value (usually a pointer to a context structure) that is passed into the function when it is called The specified callback function will be called from the timer peripheral interrupt context ",
							" Precondition I2C_BB_Initialize must have been called for the associated I2C instance ",
							" Parameters Param Description callback A pointer to a function with a calling signature defined by the I2CBB_CALLBACK data type Setting this to NULL disables the callback feature contextHandle A value (usually a pointer) passed (unused) into the function identified by the callback parameter ",
							" Returns None ",
							" Example void  MyI2CCallback ( uintptr_t context )  {  // This function will be called when the transfer completes Note  // that this function executes in the context of the I2C interrupt  }  I2C_BB_Initialize ( ) ;  I2C_BB_CallbackRegister ( MyI2CCallback   NULL ) ; ",
							" Remarks None ",
							" I2CBB_ERROR Enum ",
							" C typedef  enum  {  /* No error has occurred */ I2CBB_ERROR_NONE   /* A bus transaction was NAK'ed */ I2CBB_ERROR_NAK   /* A bus error has occurred */ I2CBB_ERROR_BUS   } I2CBB_ERROR ;  ",
							" Summary I2C Bit Bang Transfer Status data type ",
							" Description This data type defines the I2C Bit Bang Transfer Status ",
							" Remarks None ",
							" I2CBB_TRANSFER_SETUP Struct ",
							" C typedef  struct  {  /* I2C Clock Speed */ uint32_t clkSpeed ;  } I2CBB_TRANSFER_SETUP ;  ",
							" Summary I2C Bit Bang Transfer Setup Data Structure ",
							" Description This data structure defines the I2C Bit Bang Transfer Setup Data ",
							" Remarks None ",
							" I2CBB_CALLBACK Typedef ",
							" C typedef  void  ( * I2CBB_CALLBACK ) ( uintptr_t context ) ;  ",
							" Summary I2C bit bang library callback function pointer ",
							" Description This data type defines the I2C callback function pointer ",
							" Example void  MyI2CCallback ( uintptr_t context )  {  // This function will be called when the transfer completes Note  // that this function executes in the context of the I2C interrupt  }  I2C_BB_Initialize ( ) ;  I2C_BB_CallbackRegister ( MyI2CCallback   NULL ) ; ",
							" Remarks None ",
							" OSAL Library The Operating System Abstraction Layer (OSAL) provides a consistent interface to allow MPLAB Harmony-compliant libraries to take advantage of Operating System constructs when running in an OS environment or when operating without one It is designed to take care of the underlying differences between the available OS Kernels or when no kernel is present The OSAL provides the interface to commonly available Real-Time Operating Systems (RTOS) such that MPLAB Harmony libraries may be written using a single interface to a minimal set of OS features needed to provide thread safety The OSAL interface can be implemented appropriately to support almost any desired RTOS For systems where no RTOS is available or desired a bare version of the OSAL supports either polled or interrupt-driven environments running directly on the hardware This allows applications designed using MPLAB Harmony libraries to be executed in all three common embedded environments: polled (shared multi-tasking) interrupt-driven or RTOS-based Note: It is possible to make RTOS independent applications using the OSAL However as explained in the following section that is not its purpose Use and selection of an RTOS is usually determined by the availability of its unique features And utilizing those features will of course make an application OS-specific osal_h3_architecture Scope By design the OSAL is a minimal API intended only to enable thread-safe operation for MPLAB Harmony libraries It only exposes a very small subset of the capabilities of an operating system so that MPLAB Harmony libraries can use semaphores mutexes and critical sections (and a few other things) necessary to protect shared resources (data structures peripheral registers and other memory objects) from corruption by unsynchronized access by multiple threads This is done to allow MPLAB Harmony libraries to be made compatible with the largest variety of operating systems by using a minimal subset of some of the most common OS features The OSAL is not intended to provide a complete abstraction of an RTOS which is what you would normally do to implement a complete application Abstracting an entire operating system is a much more complex task that is roughly equivalent to defining your own RTOS The OSAL is not designed to replace a commercial kernel and therefore the user is encouraged to use any of the specific features of their chosen RTOS in order to achieve best performance As such the OSAL can be considered to be an Operating System Compatibility Layer offering MPLAB Harmony-compliant libraries the required common functions to ensure correct operation in both RTOS and non-RTOS environments The common interface presented by the OSAL is designed to offer a set of services typically found on micro-kernel and mini-scheduler systems Because of this it has no aspirations to provide an equivalent set of capabilities as those found on large multi-tasking systems such as µCLinux The common services are designed to allow MPLAB Harmony to implement thread-safe Drivers and Middleware The design intention is that drivers will use the minimal set of OSAL features necessary to ensure that they can safely operate in a multi-threaded environment yet can also compile and run correctly when no underlying RTOS is present The range of features used by a driver is typically limited to these OSAL features: Semaphore Functions Mutex Functions Critical Section Functions Supported RTOS RTOS Release Type CMSIS FreeRTOS Production Micrium OS III Production Azure RTOS ThreadX Production Mbed OS RTOS Production ",
							" How The Library Works Abstraction Model The common interface can easily be ported to many host Real-Time Operating Systems (RTOS) by third parties and the set of functions provides a basic level of RTOS compatibility Where a specific RTOS does not implement a given architectural feature (e g events) the OSAL port for that RTOS should endeavor to imitate that feature using the constructs that are available Although it is recognized that this may have a detrimental effect on the performance of that system it does allow MPLAB Harmony developers the broadest scope for using RTOS features in their designs The following diagram illustrates the OSAL Abstraction model osal_abstraction_model Library Overview The OSAL Library provides a defined interface such that driver and middleware developers will be able to create MPLAB Harmony code that can safely operate in a multi-threaded environment when a supported RTOS is present yet will still compile and function correctly when MPLAB Harmony is being used in a non-RTOS environment with an interrupt or non-interrupt driven application model At the application layer the developer is encouraged to use the specific features of a chosen RTOS once it has been selected since this is likely to provide a more effective and rich programming environment The OSAL Library is deliberately designed to be a thin layer over an underlying RTOS which presents a predefined interface to the common features used by the majority of Real-Time Operating Systems which includes: Library Interface Section Description Semaphore Functions Binary and counting semaphores Mutex Functions Thread and resource locking mechanism Critical Section Functions Application and scheduler locking mechanism Memory Allocation Functions Memory allocation primitives or wrappers OSAL Control Functions OSAL initialization One of the primary design guidelines is that a host operating system may not be present and so any operations that the OSAL presents are designed to compile out to safe default implementations if no RTOS is present This can mean the following: Implementing a dummy function that mimics typical RTOS behavior Implementing a #define or inline function that returns a 'safe' generic return value such as 'true' or a 'call succeeded' status Returning a OSAL_RESULT_NOT_IMPLEMENTED value to indicate an unsupported operation Throwing an OSAL_ASSERT failure to indicate a terminal error that prevents operation under specific circumstances ",
							" Using The Library Interface Header File: osal h The interface to the OSAL Library is defined in the osal h header file Any C language source ( c) file that uses the OSAL System Service library should include osal h Library File: osal c Source files added to the project if using the \"BareMetal\" OSAL basic implementation used when no RTOS is present osal_ vendor-specified RTOS name c (i e FreeRTOS etc ) The OSAL Library consists of a basic implementation and individual ports of the OSAL to target operating systems The basic implementation is used when any of the Third-Party Library RTOS is not instantiated When an RTOS is being used (i e if any of Third-Party Library RTOS is instantiated Ex: FreeRTOS) then an external implementation file which provides the required interface wrappers should be added to the project For instance for the FreeRTOS operating system the file osal_freertos c should be added while for the Micriµm µC/OS-III operating system the file osal_ucos3 c should be added The basic implementation and some generic ports are provided with the Library however it is the responsibility of third-party vendors to supply an implementation file for operating systems that are not already supported When the OSAL is using an underlying RTOS it may be necessary to allow the RTOS to perform one-time initialization before any calls to it are made For instance the RTOS might implement multiple memory pools for managing queues and semaphores and it must be given the chance to create these pools before any of the objects are created For this reason the application program should call OSAL_Initialize() early on and certainly before any MPLAB Harmony drivers or middleware is initialized (since these may also create OSAL objects at creation time) Once the OSAL is initialized and any other remaining parts of the system are configured correctly the specific RTOS can be started ",
							" Semaphore Operations The semaphore implements a method for thread synchronization This synchronization can be either between one thread and another or between an ISR and a thread A semaphore once signalled will unblock the highest priority thread currently pending on it A semaphore can be used to lock a shared resource although it is more normal to use a mutex for such an activity Once obtained a semaphore should be posted back to enable it to be retaken at a later time or in another thread /* mainline code prior to OS start */  /* declare a variable of type semaphore handle */  OSAL_SEM_DECLARE ( semSync ) ;  /* create the semaphore */  OSAL_SEM_Create (  semSync  OSAL_SEM_TYPE_BINARY   0   0 ) ;  /* thread one */      /* take the semaphore without waiting */  OSAL_SEM_Pend ( semSync   0 ) ;     perform some actions /* return the semaphore */  OSAL_SEM_Post ( semSync ) ;      /* thread two must not execute until thread one has finished its operations*/      /* block on the semaphore */  OSAL_SEM_Pend ( semSync  OSAL_WAIT_FOREVER ) ;     perform some more actions /* return the semaphore */  OSAL_SEM_Post ( semSync ) ; A semaphore can be signalled multiple times and so provides a method for an ISR to release a thread waiting on it Even though the blocked thread never returns the semaphore because the asynchronous ISR repeatedly posts it the next time the thread wants to pend on the semaphore it will be available By moving the majority of interrupt service processing from the ISR to a high priority thread the system response time is improved and the eventual processing can take advantage of OSAL features such as mutexes and queues which would normally be harder to implement inside the ISR This technique is known as deferred interrupt processing /* an example interrupt handler called from an ISR that performs task synchronization using a semaphore */  void  _ISRTasksRX ( void )  /* N B pseudo-code ISR */  {      _DRV_USART_InterruptSourceStatusClear ( _DRV_USART_GET_INT_SRC_RX ( _DRV_USART_OBJ ( dObj  rxInterruptSource ) ) ) ;  /* Release the receive semaphore unblocking any tasks */  OSAL_SEM_PostISR ( _DRV_USART_OBJ ( dObj  rxSemID ) ) ;  }  /* DRV_USART_TasksRX */ ",
							" Mutex Operations A mutex or mutual exclusion is used to protect a shared resource from access by multiple threads at the same time A shared resource may be a common data structure in RAM or it may be a hardware peripheral In either case a mutex can be used to ensure the integrity of the entire resource by only allowing one thread to access it at a time The library must be written in such a way that before the shared resources is accessed the mutex has to be obtained Once obtained the accesses should occur and once complete the mutex should then be released While no restrictions are enforced the sequence of operations between the lock and unlock should ideally take as few lines of code as possible to ensure good system performance The mutex may be implemented as a form of binary semaphore but an underlying RTOS will often add other features It is normal to add the restriction that a mutex may only be unlocked from the thread that originally obtained the lock in the first place The RTOS may also provide features to mitigate priority inversion problems (where a high priority thread blocks on a lower priority one holding a mutex) by providing priority inheritance allowing lower priority threads to be temporarily raised to complete and release a locked mutex /* perform operations on a shared data structure */  struct  myDataStructure  { uint16_t x ; uint8_t y ;  } myDataStructure ;      OSAL_MUTEX_DECLARE ( mutexDS ) ;  OSAL_MUTEX_Create (  mutexDS ) ;      /* wait 2 seconds to obtain the mutex */  if  ( OSAL_MUTEX_Lock ( mutexDS   2000 )  == OSAL_RESULT_TRUE )  {  /* operate on the data structure */ myDataStructure  x =  32 ;  OSAL_MUTEX_Unlock ( mutexDS ) ;  } ",
							" Critical Section Operations This section describes how critical sections are used Critical sections are used to form sequences of code that must operate in an atomic manner The interface allows for the possibility of two types of critical section When the critical section is entered all interrupts on the microcontroller are disabled This prevents the protected sequence of code from being interrupted and ensures the complete atomicity of the operation This is denoted by the OSAL_CRIT_TYPE_HIGH value When the critical section is entered the RTOS scheduler is disabled In this second case other threads are prevented from running however interrupts can still occur which allows any asynchronous events to still be received and for the temporal accuracy of the RTOS scheduler to be maintained This is denoted by the OSAL_CRIT_TYPE_LOW value Since the behavior in the two cases is different the type of critical section must be identified in both the call to enter and leave /* enter and leave a critical section disabling interrupts */  OSAL_CRIT_Enter ( OSAL_CRIT_TYPE_HIGH ) ;  /* perform an atomic sequence of code */      /* leave the critical section */  OSAL_CRIT_Leave ( OSAL_CRIT_TYPE_HIGH ) ; Note: The underlying RTOS may not support the second scenario in which case the OSAL implementation will default to disabling all interrupts ",
							" Memory Operations This section describes the memory operation using the OSAL Library The OSAL Library provides an interface to a memory allocation mechanism The memory required for dynamic instantiation of variables is normally provided by allocating it from the heap However the standard C library implementation of malloc and free are not considered thread safe and so OSAL specific functions must be used if MPLAB Harmony or the application requires dynamic memory during operation When operating without an underlying RTOS the OSAL memory allocators default to using standard malloc and free functions However when operating with an RTOS the calls will defer to the specific scheme used by the RTOS This may involve multiple memory pools or it may simply involve adding a critical section around calls to malloc and free It is left to the implementation to define the most appropriate scheme /* allocate a large buffer */ uint8_t * buffer ; buffer =  OSAL_Malloc ( 8000 ) ;  if  ( buffer =  NULL )  {     manipulate the buffer /* free the buffer */  OSAL_Free ( buffer ) ; buffer =  NULL ;  } ",
							" Configuring the Library The OSAL can be configured through the MHC The following figure shows the MHC configuration window for configuring the OSAL and a brief description of various configuration options osal_configuration The OSAL can be enabled by the user in two ways: User can manually enable OSAL which is part of Harmony Core component OSAL will get auto enabled and set to \"BareMetal\" when Middleware or any Driver is instantiated If any Third-Party Library i e RTOS is added then the respective OSAL Layer code will get generated For instance if user instantiates FreeRTOS then OSAL is set to FreeRTOS and osal_freertos c code will get generated during code generation ",
							" Library Interface OSAL library provides the following interfaces: Functions Name Description OSAL_SEM_Create Creates an OSAL Semaphore OSAL_SEM_Delete Deletes an OSAL Semaphore OSAL_SEM_Pend Waits on a semaphore Returns true if the semaphore was obtained within the time limit OSAL_SEM_Post Posts a semaphore or increments a counting semaphore OSAL_SEM_PostISR Posts a semaphore or increments a counting semaphore from within an Interrupt Service Routine (ISR) OSAL_SEM_GetCount Returns the current value of a counting semaphore OSAL_CRIT_Enter Enters a critical section with the specified severity level OSAL_CRIT_Leave Leaves a critical section with the specified severity level OSAL_MUTEX_Create Creates a mutex OSAL_MUTEX_Delete Deletes a mutex OSAL_MUTEX_Lock Locks a mutex OSAL_MUTEX_Unlock Unlocks a mutex OSAL_Malloc Allocates memory using the OSAL default allocator OSAL_Free Deallocates a block of memory and return to the default pool OSAL_Initialize Performs OSAL initialization OSAL_Name Obtains the name of the underlying RTOS Data types and constants Name Type Description OSAL_SEM_TYPE Enum Enumerated type representing the possible types of semaphore OSAL_CRIT_TYPE Enum Enumerated type representing the possible types of critical section OSAL_RESULT Enum Enumerated type representing the general return value from OSAL functions OSAL_SEM_DECLARE Macro Declares an OSAL semaphore OSAL_MUTEX_DECLARE Macro Declares an OSAL mutex ",
							" OSAL_SEM_Create Function ",
							" C OSAL_RESULT OSAL_SEM_Create ( OSAL_SEM_HANDLE_TYPE * semID  OSAL_SEM_TYPE type  uint8_t maxCount  uint8_t initialCount ) ",
							" Summary Creates an OSAL Semaphore ",
							" Description This function creates an OSAL binary or counting semaphore If OSAL_SEM_TYPE_BINARY is specified the maxcount and initialCount values are ignored ",
							" Precondition Semaphore must have been declared ",
							" Parameters Param Description semID Pointer to the Semaphore ID Updated with valid semaphore handle if call was successful type If OSAL_SEM_TYPE_BINARY create a binary semaphore If OSAL_SEM_TYPE_COUNTING create a counting semaphore with the specified count values maxCount Maximum value for a counting semaphore (ignored for a BINARY semaphore) This parameter is ignored for ThreadX and Micrium/OS-III as these RTOS libraries do not support this parameter initialCount Starting count value for the semaphore (ignored for a BINARY semaphore) This should be less than or equal to maxCount when used with a RTOS library that supports the maxCount parameter (i e FreeRTOS and OPENRTOS) ",
							" Returns OSAL_RESULT_TRUE - Semaphore created OSAL_RESULT_FALSE - Semaphore creation failed ",
							" Example OSAL_SEM_Create (  mySemID  OSAL_SEM_TYPE_COUNTING   10   5 ) ; ",
							" Remarks None ",
							" OSAL_SEM_Delete Function ",
							" C OSAL_RESULT OSAL_SEM_Delete ( OSAL_SEM_HANDLE_TYPE * semID ) ",
							" Summary Deletes an OSAL Semaphore ",
							" Description This function deletes an OSAL semaphore ",
							" Precondition Semaphore must have been created ",
							" Parameters Param Description semID Pointer to the Semaphore ID ",
							" Returns OSAL_RESULT_TRUE - Semaphore deleted OSAL_RESULT_FALSE - Semaphore deletion failed ",
							" Example OSAL_SEM_Delete (  mySemID ) ; ",
							" Remarks None ",
							" OSAL_SEM_Pend Function ",
							" C OSAL_RESULT OSAL_SEM_Pend ( OSAL_SEM_HANDLE_TYPE * semID  uint16_t waitMS ) ",
							" Summary Waits on a semaphore Returns true if the semaphore was obtained within the time limit ",
							" Description This function is a blocking function call that waits (i e pends) on a semaphore The function will return true if the semaphore has been obtained or false if it was not available or the time limit was exceeded ",
							" Precondition Semaphore must have been created ",
							" Parameters Param Description semID Pointer to the Semaphore ID waitMS Time limit to wait in milliseconds: 0 - do not wait OSAL_WAIT_FOREVER - return only when semaphore is obtained Other values - time-out delay ",
							" Returns OSAL_RESULT_TRUE - Semaphore obtained OSAL_RESULT_FALSE - Semaphore not obtained or time-out occurred ",
							" Example if  ( OSAL_SEM_Pend (  semUARTRX   50 )  == OSAL_RESULT_TRUE )  {  // character available c =  DRV_USART_ReadByte ( drvID ) ;      }  else  {  // character not available resend prompt      } ",
							" Remarks None ",
							" OSAL_SEM_Post Function ",
							" C OSAL_RESULT OSAL_SEM_Post ( OSAL_SEM_HANDLE_TYPE * semID ) ",
							" Summary Posts a semaphore or increments a counting semaphore ",
							" Description This function posts a binary semaphore or increments a counting semaphore The highest priority task currently blocked on the semaphore will be released and made ready to run ",
							" Precondition Semaphore must have been created ",
							" Parameters Param Description semID Pointer to the Semaphore ID ",
							" Returns OSAL_RESULT_TRUE - Semaphore posted OSAL_RESULT_FALSE - Semaphore not posted ",
							" Example OSAL_SEM_Post (  semSignal ) ; ",
							" Remarks None ",
							" OSAL_SEM_PostISR Function ",
							" C OSAL_RESULT OSAL_SEM_PostISR ( OSAL_SEM_HANDLE_TYPE * semID ) ",
							" Summary Posts a semaphore or increments a counting semaphore from within an Interrupt Service Routine (ISR) ",
							" Description This function posts a binary semaphore or increments a counting semaphore The highest priority task currently blocked on the semaphore will be released and made ready to run This form of the post function should be used inside an ISR ",
							" Precondition Semaphore must have been created ",
							" Parameters Param Description semID Pointer to the Semaphore ID ",
							" Returns OSAL_RESULT_TRUE - Semaphore posted OSAL_RESULT_FALSE - Semaphore not posted ",
							" Example void  __ISR ( UART_2_VECTOR )  _UART2RXHandler ( )  {  char c ;  // read the character c = U2RXREG ;  // clear the interrupt flag IFS1bits  U2IF =  0 ;  // post a semaphore indicating a character has been received  OSAL_SEM_PostISR (  semSignal ) ;  } ",
							" Remarks This version of the OSAL_SEM_Post function should be used if the program is or may be operating inside an ISR The OSAL will take the necessary steps to ensure correct operation possibly disabling interrupts or entering a critical section The exact requirements will depend upon the particular RTOS being used ",
							" OSAL_SEM_GetCount Function ",
							" C uint8_t OSAL_SEM_GetCount ( OSAL_SEM_HANDLE_TYPE * semID ) ",
							" Summary Returns the current value of a counting semaphore ",
							" Description This function returns the current value of a counting semaphore The value returned is assumed to be a single value ranging from 0-255 ",
							" Precondition Semaphore must have been created ",
							" Parameters Param Description semID Pointer to the Semaphore ID ",
							" Returns 0 - Semaphore is unavailable 1-255 - Current value of the counting semaphore ",
							" Example uint8_t semCount ; semCount =  OSAL_SEM_GetCount ( semUART ) ;  if  ( semCount   0 )  {  // obtain the semaphore  if  ( OSAL_SEM_Pend (  semUART )  == OSAL_RESULT_TRUE )  {  // perform processing on the comm channel      }  }  else  {  // no comm channels available      } ",
							" Remarks None ",
							" OSAL_CRIT_Enter Function ",
							" C OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter ( OSAL_CRIT_TYPE severity ) ",
							" Summary Enters a critical section with the specified severity level ",
							" Description This function enters a critical section of code It is assumed that the sequence of operations bounded by the enter and leave critical section operations is treated as one atomic sequence that will not be disturbed This function should be paired with OSAL_CRIT_Leave() ",
							" Precondition None ",
							" Parameters Param Description severity OSAL_CRIT_TYPE_LOW The RTOS should disable all other running tasks effectively locking the scheduling mechanism OSAL_CRIT_TYPE_HIGH The RTOS should disable all possible interrupts sources including the scheduler ensuring that the sequence of code operates without interruption The state of interrupts are returned to the user before they are disabled ",
							" Returns A data type of OSAL_CRITSECT_DATA_TYPE this value represents the state of interrupts before entering the critical section ",
							" Example OSAL_CRITSECT_DATA_TYPE IntState ;  // prevent other tasks preempting this sequence of code IntState =  OSAL_CRIT_Enter ( OSAL_CRIT_TYPE_HIGH ) ;  // modify the peripheral  DRV_USART_Reinitialize ( objUSART    initData ) ;  OSAL_CRIT_Leave ( OSAL_CRIT_TYPE_HIGH  IntState ) ; ",
							" Remarks The sequence of operations bounded by the OSAL_CRIT_Enter and OSAL_CRIT_Leave form a critical section The severity level defines whether the RTOS should perform task locking or completely disable all interrupts ",
							" OSAL_CRIT_Leave Function ",
							" C void  OSAL_CRIT_Leave ( OSAL_CRIT_TYPE severity  OSAL_CRITSECT_DATA_TYPE status ) ",
							" Summary Leaves a critical section with the specified severity level ",
							" Description This function leaves a critical section of code It is assumed that the sequence of operations bounded by the enter and leave critical section operations is treated as one atomic sequence that will not be disturbed The severity should match the severity level used in the corresponding OSAL_CRIT_Enter call to ensure that the RTOS carries out the correct action ",
							" Precondition None ",
							" Parameters Param Description severity OSAL_CRIT_TYPE_LOW The scheduler will be unlocked if no other nested calls to OSAL_CRIT_ENTER have been made OSAL_CRIT_TYPE_HIGH Interrupts are returned to the state passed into this function The state should of been saved by an earlier call to OSAL_CRIT_Enter status The value which will be used to set the state of global interrupts if OSAL_CRIT_TYPE_HIGH is passed in ",
							" Returns None ",
							" Example OSAL_CRITSECT_DATA_TYPE IntState ;  // prevent other tasks preempting this sequence of code intState =  OSAL_CRIT_Enter ( OSAL_CRIT_TYPE_LOW ) ;  // modify the peripheral  DRV_USART_Reinitialize ( objUSART    initData ) ;  OSAL_CRIT_Leave ( OSAL_CRIT_TYPE_LOW  IntState ) ; ",
							" Remarks The sequence of operations bounded by the OSAL_CRIT_Enter and OSAL_CRIT_Leave form a critical section The severity level defines whether the RTOS should perform task locking or completely disable all interrupts ",
							" OSAL_MUTEX_Create Function ",
							" C OSAL_RESULT OSAL_MUTEX_Create ( OSAL_MUTEX_HANDLE_TYPE * mutexID ) ",
							" Summary Creates a mutex ",
							" Description This function creates a mutex allocating storage if required and placing the mutex handle into the passed parameter ",
							" Precondition Mutex must have been declared ",
							" Parameters Param Description mutexID Pointer to the mutex handle ",
							" Returns OSAL_RESULT_TRUE - Mutex successfully created OSAL_RESULT_FALSE - Mutex failed to be created ",
							" Example OSAL_MUTEX_HANDLE_TYPE mutexData ;  OSAL_MUTEX_Create (  mutexData ) ;      if  ( OSAL_MUTEX_Lock (  mutexData   1000 )  == OSAL_RESULT_TRUE )  {  // manipulate the shared data      } ",
							" Remarks None ",
							" OSAL_MUTEX_Delete Function ",
							" C OSAL_RESULT OSAL_MUTEX_Delete ( OSAL_MUTEX_HANDLE_TYPE * mutexID ) ",
							" Summary Deletes a mutex ",
							" Description This function deletes a mutex and frees associated storage if required ",
							" Precondition None ",
							" Parameters Param Description mutexID Pointer to the mutex handle ",
							" Returns OSAL_RESULT_TRUE - Mutex successfully deleted OSAL_RESULT_FALSE - Mutex failed to be deleted ",
							" Example OSAL_MUTEX_Delete (  mutexData ) ; ",
							" Remarks None ",
							" OSAL_MUTEX_Lock Function ",
							" C OSAL_RESULT OSAL_MUTEX_Lock ( OSAL_MUTEX_HANDLE_TYPE * mutexID  uint16_t waitMS ) ",
							" Summary Locks a mutex ",
							" Description This function locks a mutex waiting for the specified time-out If it cannot be obtained or the time-out period elapses 'false' is returned ",
							" Precondition Mutex must have been created ",
							" Parameters Param Description mutexID Pointer to the mutex handle waitMS Time-out value in milliseconds: 0 - do not wait return immediately OSAL_WAIT_FOREVER - wait until mutex is obtained before returning Other values - time-out delay ",
							" Returns OSAL_RESULT_TRUE - Mutex successfully obtained OSAL_RESULT_FALSE - Mutex failed to be obtained or time-out occurred ",
							" Example     if  ( OSAL_MUTEX_Lock (  mutexData   1000 )  == OSAL_RESULT_TRUE )  {  // manipulate the shared data      // unlock the mutex  OSAL_MUTEX_Unlock (  mutexData ) ;  } ",
							" Remarks None ",
							" OSAL_MUTEX_Unlock Function ",
							" C OSAL_RESULT OSAL_MUTEX_Unlock ( OSAL_MUTEX_HANDLE_TYPE * mutexID ) ",
							" Summary Unlocks a mutex ",
							" Description This function unlocks a previously obtained mutex ",
							" Precondition Mutex must have been created ",
							" Parameters Param Description mutexID Pointer to the mutex handle ",
							" Returns OSAL_RESULT_TRUE - Mutex released OSAL_RESULT_FALSE - Mutex failed to be released or error occurred ",
							" Example     if  ( OSAL_MUTEX_Lock (  mutexData   1000 )  == OSAL_RESULT_TRUE )  {  // manipulate the shared data      // unlock the mutex  OSAL_MUTEX_Unlock (  mutexData ) ;  } ",
							" Remarks None ",
							" OSAL_Malloc Function ",
							" C void *  OSAL_Malloc ( size_t size ) ",
							" Summary Allocates memory using the OSAL default allocator ",
							" Description This function allocates a block of memory from the default allocator from the underlying RTOS If no RTOS is present it defaults to malloc Many operating systems incorporate their own memory allocation scheme using pools blocks or by wrapping the standard C library functions in a critical section Since a MPLAB Harmony application may not know what target OS is being used (if any) this function ensures that the correct thread-safe memory allocator will be used ",
							" Precondition None ",
							" Parameters Param Description size Size of the requested memory block in bytes ",
							" Returns Pointer to the block of allocated memory NULL is returned if memory could not be allocated ",
							" Example // create a working array uint8_t * pData ; pData =  OSAL_Malloc ( 32 ) ;  if  ( pData =  NULL )  {      } ",
							" Remarks None ",
							" OSAL_Free Function ",
							" C void  OSAL_Free ( void * pData ) ",
							" Summary Deallocates a block of memory and return to the default pool ",
							" Description This function deallocates memory and returns it to the default pool In an RTOS-based application the memory may have been allocated from multiple pools or simply from the heap In non-RTOS applications this function calls the C standard function free ",
							" Precondition None ",
							" Parameters Param Description pData Pointer to the memory block to be set free ",
							" Returns None ",
							" Example // create a working array uint8_t * pData ; pData =  OSAL_Malloc ( 32 ) ;  if  ( pData =  NULL )  {      // deallocate the memory  OSAL_Free ( pData ) ;  // and prevent it accidentally being used again pData =  NULL ;  } ",
							" Remarks None ",
							" OSAL_Initialize Function ",
							" C OSAL_RESULT OSAL_Initialize ( void ) ",
							" Summary Performs OSAL initialization ",
							" Description This function performs OSAL initialization This function should be called near the start of main in an application that will use an underlying RTOS This permits the RTOS to perform any one time initialization before the application attempts to create drivers or other items that may use the RTOS Typical actions performed by OSAL_Initialize would be to allocate and prepare any memory pools for later use ",
							" Precondition None ",
							" Parameters None ",
							" Returns OSAL_RESULT_TRUE - Initialization completed successfully ",
							" Example int  main ( )  {  OSAL_Initialize ( ) ;  App_Init ( ) ;  OSAL_Start ( ) ;  } ",
							" Remarks None ",
							" OSAL_Name Function ",
							" C const  char * OSAL_Name ( void ) ",
							" Summary Obtains the name of the underlying RTOS ",
							" Description This function returns a const char* to the textual name of the RTOS The name is a NULL terminated string ",
							" Precondition None ",
							" Parameters None ",
							" Returns Name of the underlying RTOS or NULL ",
							" Example // get the RTOS name  const  char * sName ; sName =  OSAL_Name ( ) ;  sprintf ( buff   \"RTOS: %s\"  sName ) ; ",
							" Remarks None ",
							" OSAL_SEM_TYPE Enum ",
							" C typedef  enum  OSAL_SEM_TYPE  { OSAL_SEM_TYPE_BINARY  OSAL_SEM_TYPE_COUNTING } OSAL_SEM_TYPE ; ",
							" Summary Enumerated type representing the possible types of semaphore ",
							" Description This enum represents possible semaphore types OSAL_SEM_TYPE_BINARY - Simple binary type that can be taken once OSAL_SEM_TYPE_COUNTING - Complex type that can be taken set number of times defined at creation time ",
							" Remarks Binary and counting semaphore type ",
							" OSAL_CRIT_TYPE Enum ",
							" C typedef  enum  OSAL_CRIT_TYPE  { OSAL_CRIT_TYPE_LOW  OSAL_CRIT_TYPE_HIGH } OSAL_CRIT_TYPE ; ",
							" Summary Enumerated type representing the possible types of critical section ",
							" Description This enum represents possible critical section types OSAL_CRIT_TYPE_LOW - Low priority critical section can be formed by locking the scheduler (if supported by RTOS) OSAL_CRIT_TYPE_HIGH - High priority critical section will be formed by disabling all interrupts ",
							" Remarks Critical section types ",
							" OSAL_RESULT Enum ",
							" C typedef  enum  OSAL_RESULT  { OSAL_RESULT_NOT_IMPLEMENTED =  - 1  OSAL_RESULT_FALSE =  0  OSAL_RESULT_TRUE =  1  } OSAL_RESULT ; ",
							" Summary Enumerated type representing the general return value from OSAL functions ",
							" Description This enum represents possible return types from OSAL functions ",
							" Remarks These enum values are the possible return values from OSAL functions where a standard success/fail type response is required The majority of OSAL functions will return this type with a few exceptions ",
							" OSAL_SEM_DECLARE Macro ",
							" C # define OSAL_SEM_DECLARE(semID) OSAL_SEM_HANDLE_TYPE semID ",
							" Summary Declares an OSAL semaphore ",
							" Description This function declares a data item of type OSAL_SEM_HANDLE_TYPE ",
							" Remarks None ",
							" OSAL_MUTEX_DECLARE Macro ",
							" C # define OSAL_MUTEX_DECLARE(mutexID) OSAL_MUTEX_HANDLE_TYPE mutexID ",
							" Summary Declares an OSAL mutex ",
							" Description This function declares a data item of type OSAL_MUTEX_HANDLE_TYPE ",
							" Remarks None ",
							" Third party Products MPLAB Harmony enables seamless integration of third-party solutions such as RTOS Middleware Drivers and so on into the software framework MPLAB Harmony is a flexible abstracted fully integrated firmware development platform for PIC32 and SAM microcontrollers which enables seamless integration of third-party solutions such as RTOS Middleware Drivers and so on into the software framework Important Licensing Information FreeRTOS : Refer Source code and licensing information at CMSIS-FreeRTOS Micrium OS III : To obtain the source code and proper licensing agreement go to the Micriµm website Micrium OS III Azure RTOS ThreadX : Refer Source code and licensing information at Azure RTOS ThreadX Mbed OS RTOS : Refer Source code and licensing information at Mbed OS RTOS Software License Agreement Refer to the MPLAB Harmony Integrated Software Framework Software License Agreement for complete licensing information A copy of this agreement is available in the /doc folder of your MPLAB Harmony installation Third party RTOS RTOS Description FreeRTOS FreeRTOS is a real-time operating system kernel for embedded devices Micrium OS III Micrium OS III is a preemptive highly portable and scalable real-time kernel Azure RTOS ThreadX Azure RTOS ThreadX is an advanced real-time operating system (RTOS) designed specifically for deeply embedded applications Mbed OS RTOS Mbed OS RTOS includes an RTX and all RTOS APIs ",
							" FreeRTOS FreeRTOS is a small footprint portable preemptive open source real time kernel that has been designed specifically for use on micro-controllers that makes small low-power edge devices easy to program deploy secure connect and manage More Information For more information please read the FreeRTOS Quick Start Guide which is available at: http://www freertos org/FreeRTOS-quick-start-guide html Additional information is also available from the Microchip Third-Party RTOS web page: http://www microchip com/devtoolthirdparty/ Demonstrations See FreeRTOS Applications for information ",
							" Micrium OS III Micriµm µC/OS-III are highly portable ROMable scalable preemptive real-time deterministic multitasking kernels for microprocessors microcontrollers and DSPs More Information For more information please read the related documentation which is available at: https://www silabs com/developers/micrium Additional information is also available from the Microchip Third-Party RTOS web page: http://www microchip com/devtoolthirdparty/ Demonstrations See Micrium RTOS Applications at Micrium µC/OS-III  ",
							" Azure RTOS ThreadX This advanced real-time operating system (RTOS) is designed specifically for deeply embedded applications Among the multiple benefits it provides are advanced scheduling facilities message passing interrupt management and messaging services Azure RTOS ThreadX has many advanced features including picokernel architecture preemption threshold event chaining and a rich set of system services More Information For more information please read the related documentation which is available at: https://github com/azure-rtos/threadx Additional information is also available at: https://rtos com/platform/microchip-technology-inc and from the Microchip Third-Party RTOS web page: http://www microchip com/devtoolthirdparty/ Demonstrations See Azure RTOS ThreadX Applications at Azure RTOS  ",
							" Mbed OS RTOS Arm Mbed OS is an open source embedded operating system designed specifically for the \"things\" in the Internet of Things It includes all the features you need to develop a connected product based on an Arm Cortex-M microcontroller including security connectivity an RTOS and drivers for sensors and I/O devices More Information For more information please read the related documentation which is available at: https://github com/ARMmbed/mbed-os Additional information is also available at: https://rtos com/platform/microchip-technology-inc and from the Microchip Third-Party RTOS web page: http://www microchip com/devtoolthirdparty/ Demonstrations See Mbed OS RTOS Applications at Mbed OS RTOS Applications  ",
							" Configuring The Harmony Core Library Harmony Core library component provides common configurations to drivers system services and middlewares It also provides options to create application template files for the user to kick-start on developing the application Key points to be noted All the drivers system services and middlewares are dependent on the Harmony Core component If you add any of these modules in project graph and Harmony core component is not already activated a pop-up appears to activate Harmony core Failure to activate Harmony Core component may result in build failures as these modules are dependent on it As Harmony Core component is dependent on RTOS a pop-up will appear the first time Harmony Core is activated to add FreeRTOS if it was cloned As this is optional dependency user can choose to not activate it If FreeRTOS is activated all the existing modules will run in RTOS environment and each module may have its own RTOS settings If not activated all the existing modules will run in Bare-Metal environment The following figures show the MHC configuration window for Harmony core component and brief description harmony_core_mhc_config All of below mentioned options are enabled or disabled automatically based on the any driver system service or middleware components added into the project graph Disabling any of these symbols may lead to build errors in the dependent module configuration h header file will be generated only when one of the below common symbols or application file option is selected For Example: In above snapshot as Memory driver is added to project graph few of the common symbols are enabled and made Read-Only to avoid accidental disabling Refer to Individual Library help for more details Configuration Options Generate Harmony Application Files: This option can be used to generate Harmony application template source and header files These generated files can be used as starting point by the developer to develop his application Application Configuration: Number of Applications: Specifies the number of application template source and header files to be generated Application n Configuration: Enable Application n Configuration: This option can be used to disable or enable generation of current instance of application files Application Name: Specifies the name of the application source and header files to be generated By default a number sequence will be prefixed based on instances Below are the files generated if name is app app c app h User can update this field to provide custom names as required The name must be valid C-language identifier short and in lowercase An asscociated task routine APP_Tasks() will be generated in application source file and will be called from SYS_Tasks() routine RTOS Settings: This configuration is displayed when any RTOS is added into project graph Stack Size (in bytes): Specifies the number of bytes to be allocated on the stack for the current application task Task Priority: Specifies priority for the application task thread The value can vary based on RTOS used Use Task Delay When enabled the application task will be scheduled out voluntarily after every run based on the delay configured Task Delay: Specifies the duration the task has to go to sleep after every run Should be configured carefully based on the application need and number of task running along in the system Generate Harmony Driver Common Files: When enabled generates the driver common header files required by all Harmony Drivers Generate Harmony System Service Common Files: When enabled generates the system service common header files required by all Harmony System services and Drivers Generate Harmony System Media Files: When enabled generates the system media header file required by Media block drivers and File System Service Enable System Interrupt: This option can be used to enable System Interrupt library Enable System Ports: This option can be used to enable System Ports library Enable System Cache: This option can be used to enable System Cache library Enable System DMA: This option can be used to enable System DMA library Enable System Reset: This option can be used to enable System Reset library Enable OSAL: This option can be used to enable OSAL (Operating System Abstraction Layer) library OSAL will get auto enabled and set to \"BareMetal\" when Middleware or any Driver is instantiated If any Third-Party Library i e RTOS is added then the respective OSAL Layer code will get generated For instance if user instantiates FreeRTOS then OSAL is set to FreeRTOS and osal_freertos c code will get generated during code generation RTOS Settings For MicriumOS-III RTOS Below additional options are visible in Application instance RTOS settings when the MicriumOS-III is added into project graph rtos_settings_micrium_os_iii Maximum Message Queue Size: This argument specifies the maximum number of messages that the task can receive through internal message queue A MicriumOS-III task contains an optional internal message queue (if OS_CFG_TASK_Q_EN is set to DEF_ENABLED in os_cfg h) The user may specify that the task is unable to receive messages by setting this argument to 0 Task Time Quanta: The amount of time (in clock ticks) for the time quanta when Round Robin is enabled If you specify 0 then the default time quanta will be used which is the tick rate divided by 10 Task Specific Options: Contains task-specific options Each option consists of one bit The option is selected when the bit is set The current version of MicriumOS-III supports the following options: Stack checking is allowed for the task: Specifies whether stack checking is allowed for the task Stack needs to be cleared: Specifies whether the stack needs to be cleared Floating-point registers needs to be saved: Specifies whether floating-point registers are saved This option is only valid if the processor has floating-point hardware and the processor-specific code saves the floating-point registers TLS (Thread Local Storage) support needed for the task: If the caller doesn�t want or need TLS (Thread Local Storage) support for the task being created If you do not include this option TLS will be supported by default TLS support was added in V3 03 00 "];

