# DRV\_AT25DF\_Write Function

**Parent topic:**[Library Interface](GUID-6D9FA3F1-00EF-4C4D-AC06-CF95F5137ACB.md)

## C

```c
bool DRV_AT25DF_Write(const DRV_HANDLE handle, void *txData, uint32_t txDataLength, uint32_t address)
```

## Summary

Writes 'n' bytes of data starting at the specified address.

## Description

This function schedules a non-blocking write operation for writing<br />txDataLength bytes of data starting from given address of FLASH.

The requesting client should call DRV\_AT25DF\_TransferStatusGet API to know<br />the current status of the request OR the requesting client can register a<br />callback function with the driver to get notified of the status.

## Preconditions

DRV\_AT25DF\_Open must have been called to obtain a valid opened device handle.

## Parameters

|Param|Description|
|-----|-----------|
|handle|A valid open-instance handle, returned from the driver's open routine|
|txData|The source buffer containing data to be programmed into AT25DF FLASH|
|txDataLength|Total number of bytes to be written.|
|address|Memory start address from where the data should be written|

## Returns

*true*

-   if the write request is accepted.


*false*

-   if handle is invalid

-   if the pointer to transmit buffer is NULL or number of bytes to write is 0

-   if the driver is busy handling another transfer request


## Example

```c
#define PAGE_SIZE 256
#define BUFFER_SIZE 1024
#define MEM_ADDRESS 0x00

uint8_t CACHE_ALIGN writeBuffer[BUFFER_SIZE];

// myHandle is the handle returned from DRV_AT25DF_Open API.
// In the below example, the transfer status is polled. However, application can
// register a callback and get notified when the transfer is complete.

if (DRV_AT25DF_Write(myHandle, writeBuffer, BUFFER_SIZE, MEM_ADDRESS) != true)
{
    // Error handling here
}
else
{
    // Wait for write to be completed
    while(DRV_AT25DF_TransferStatusGet(myHandle) == DRV_AT25DF_TRANSFER_STATUS_BUSY);
}
```

## Remarks

None.

