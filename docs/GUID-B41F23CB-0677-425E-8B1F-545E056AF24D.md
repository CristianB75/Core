# Using The Library

The AT25 driver provides non-blocking API's to read, write AT25 EEPROM.

**The AT25 driver can be used in following ways:**

-   To perform reads and writes from/to any EEPROM memory address, with number of bytes spanning multiple pages

-   To perform page write to AT25 EEPROM. Here, the memory start address must be aligned to the page boundary

-   To interface with the Memory driver to perform block operations on the AT25 EEPROM

-   Application can either register a callback to get notified once the data transfer is complete or can poll the status of the data transfer


**Example application to Write and Read AT25 EEPROM**

```c
#define BUFFER_SIZE     512
#define MEM_ADDRESS     0x0

APP_DATA CACHE_ALIGN appData;

static uint32_t erase_index = 0;
static uint32_t write_index = 0;

static void APP_EEPROM_EventHandler(DRV_AT25_TRANSFER_STATUS event, uintptr_t context)
{
    switch(event)
    {
        case DRV_AT25_TRANSFER_STATUS_COMPLETED:
        {
            appData.isTransferDone = true;
            break;
        }

        case DRV_AT25_TRANSFER_STATUS_ERROR:
        default:
        {
            appData.isTransferDone = false;
            appData.state = APP_STATE_ERROR;
            break;
        }
    }
}

void APP_Initialize ( void )
{
    uint32_t i = 0;

    /* Place the App state machine in its initial state. */
    appData.state = APP_STATE_INIT;

    for (i = 0; i < BUFFER_SIZE; i++)
    {
        appData.writeBuffer[i] = i;
    }

    appData.isTransferDone = false;
}

void APP_Tasks ( void )
{
    uint32_t i;
    
    /* Check the application's current state. */
    switch ( appData.state )
    {
        /* Application's initial state. */
        case APP_STATE_INIT:
        {
            appData.drvHandle = DRV_AT25_Open(DRV_AT25_INDEX, DRV_IO_INTENT_READWRITE);

            if (appData.drvHandle != DRV_HANDLE_INVALID)
            {
                DRV_AT25_EventHandlerSet(appData.drvHandle, APP_EEPROM_EventHandler, 0);

                appData.state = APP_STATE_WRITE;
            }
            else
            {
                appData.state = APP_STATE_ERROR;
            }
            break;
        }

        case APP_STATE_WRITE:
        {
            /* Set the next state first as callback may be fired before the state
             * is changed; potentially over-writing error state set from the callback */
            appData.state = APP_STATE_WAIT_WRITE_COMPLETE;

            if (DRV_AT25_Write(appData.drvHandle,
                    appData.writeBuffer,
                    BUFFER_SIZE,
                    AT25_EEPROM_MEM_ADDR) == false)
            {
                appData.state = APP_STATE_ERROR;
            }
            break;
        }

        case APP_STATE_WAIT_WRITE_COMPLETE:
        {
            if (appData.isTransferDone == true)
            {
                appData.isTransferDone = false;
                appData.state = APP_STATE_READ;
            }
            break;
        }

        case APP_STATE_READ:
        {
            appData.state = APP_STATE_WAIT_READ_COMPLETE;

            if (DRV_AT25_Read(appData.drvHandle,
                    appData.readBuffer,
                    BUFFER_SIZE,
                    AT25_EEPROM_MEM_ADDR) == false)
            {
                appData.state = APP_STATE_ERROR;
            }
            break;
        }

        case APP_STATE_WAIT_READ_COMPLETE:
        {
            if (appData.isTransferDone == true)
            {
                appData.isTransferDone = false;
                appData.state = APP_STATE_VERIFY;
            }
            break;
        }

        case APP_STATE_VERIFY:
        {
            if (memcmp(appData.writeBuffer, appData.readBuffer, BUFFER_SIZE ) == 0)
            {
                appData.state = APP_STATE_SUCCESS;
            }
            else
            {
                appData.state = APP_STATE_ERROR;
            }
            break;
        }

        case APP_STATE_SUCCESS:
        {
            appData.state = APP_STATE_IDLE;
            break;
        }

        case APP_STATE_ERROR:
        {
            appData.state = APP_STATE_IDLE;
            break;
        }

        case APP_STATE_IDLE:
            DRV_AT25_Close(appData.drvHandle);
        default:
        {
            break;
        }
    }
}

```

**Parent topic:**[AT25 Driver](GUID-78C407C0-91E3-468C-9D3A-F01AF5A9CCB9.md)

