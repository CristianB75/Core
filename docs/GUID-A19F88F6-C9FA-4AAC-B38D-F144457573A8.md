# SYS\_DMA\_ChannelTransfer Function

**Parent topic:**[Direct Memory Access \(DMA\) System Service](GUID-DB773A68-76AC-4900-8C7C-3AC9C38BE0BD.md)

## C

```c
bool SYS_DMA_ChannelTransfer
(
SYS_DMA_CHANNEL channel,
const void *srcAddr,
const void *destAddr,
size_t blockSize
)
```

## Summary

Adds a data transfer to a DMA channel and enables the channel to start data transfer.

## Description

This function adds a single block data transfer characteristics for a<br />specific DMA channel id it is not busy already. It also enables the<br />channel to start data transfer.

If the requesting client registered an event callback with the PLIB,<br />the PLIB will issue a SYS\_DMA\_TRANSFER\_COMPLETE event if the transfer was<br />processed successfully and SYS\_DMA\_TRANSFER\_ERROR event if the transfer was<br />not processed successfully.

## Precondition

DMA Controller should have been initialized.

## Parameters

|Param|Description|
|-----|-----------|
|channel|A specific DMA channel|
|srcAddr|Source of the DMA transfer|
|destAddr|Destination of the DMA transfer|
|blockSize|Size of the transfer block|

## Returns

*- True* - If transfer request is accepted.

*- False* - If previous transfer is in progress and the request is rejected.

## Example

```c
// Transfer 10 bytes of data to UART TX using DMA channel 1
// DMA Channel has been configured and initialized by appropriate PLIB call.

MY_APP_OBJ myAppObj;
uint8_t buf[10] = {0,1,2,3,4,5,6,7,8,9};
    void *srcAddr = (uint8_t *) buf;
    void *destAddr = (uin8_t*) &U1TXREG;
    size_t size = 10;
    
    // User registers an event handler with PLIB. This is done once.
    SYS_DMA_ChannelCallbackRegister(APP_DMA_TransferEventHandler,(uintptr_t)&myAppObj);
    
    if (SYS_DMA_ChannelTransfer(SYS_DMA_CHANNEL_1, srcAddr, destAddr, size) == true)
    {
        // do something else
    }
    else
    {
        // try again?
    }
```

## Remarks

When DMA transfer buffers are placed in cacheable memory, cache maintenance operation must be performed by cleaning and invalidating cache for DMA buffers located in cacheable SRAM region using CMSIS APIs. The buffer start address must be aligned to cache line and buffer size must be multiple of cache line. Refer to device documentation to find the cache line size. Invalidate cache lines having received buffer before using it to load the latest data in the actual memory to the cache SCB\_InvalidateDCache\_by\_Addr\(\(uint32\_t \*\)&readBuffer, sizeof\(readBuffer\)\); Clean cache lines having source buffer before submitting a transfer request to DMA to load the latest data in the cache to the actual memory SCB\_CleanDCache\_by\_Addr\(\(uint32\_t \*\)&writeBuffer, sizeof\(writeBuffer\)\);

