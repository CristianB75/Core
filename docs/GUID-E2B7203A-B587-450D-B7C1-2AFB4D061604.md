# DRV\_IO\_INTENT Enum

**Parent topic:**[Common Driver Library](GUID-DFB9A1FE-5BBB-4A10-A4B0-430BA7B9AF94.md)

## C

```c
typedef enum
{
    /* Read */
    DRV_IO_INTENT_READ                = 1 << 0,

    /* Write */
    DRV_IO_INTENT_WRITE               = 1 << 1,

    /* Read and Write*/
    DRV_IO_INTENT_READWRITE           = DRV_IO_INTENT_READ | DRV_IO_INTENT_WRITE,

    /* The driver will block and will return when the operation is complete */
    DRV_IO_INTENT_BLOCKING            = 0 << 2,

    /* The driver will return immediately */
    DRV_IO_INTENT_NONBLOCKING         = 1 << 2,

    /* The driver will support only one client at a time */
    DRV_IO_INTENT_EXCLUSIVE           = 1 << 3,

    /* The driver will support multiple clients at a time */
    DRV_IO_INTENT_SHARED              = 0 << 3

} DRV_IO_INTENT;

```

## Summary

Identifies the intended usage of the device when it is opened.

## Description

This enumeration identifies the intended usage of the device when the<br />caller opens the device. It identifies the desired behavior of the device<br />driver for the following:

-   Blocking or non-blocking I/O behavior \(do I/O calls such as read and write<br />block until the operation is finished or do they return immediately and<br />require the caller to call another routine to check the status of the<br />operation\)

-   Support reading and/or writing of data from/to the device

-   Identify the buffering behavior \(sometimes called "double buffering" of<br />the driver. Indicates if the driver should maintain its own read/write<br />buffers and copy data to/from these buffers to/from the caller's buffers.

-   Identify the DMA behavior of the peripheral


## Remarks

The buffer allocation method is not identified by this enumeration.

Buffers can be allocated statically at build time, dynamically at run-time, or even allocated by the caller and passed to the driver for its own usage if a driver-specific routine is provided for such. This choice is left to the design of the individual driver and is considered part of its interface.

These values can be considered "flags". One selection from each of the groups below can be ORed together to create the complete value passed to the driver's open routine.

