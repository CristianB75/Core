# Using The Library

The NAND Flash driver provides the blocking API's to read, write and erase NAND Flash memory.

**The NAND Flash driver can be used in following ways:**

-   To perform page and block write to NAND Flash.

-   To perform page and block read from NAND Flash.

-   To perform block erase operation

-   To read flash identifier codes, Parameter page and geometry of the NAND Flash

-   To reset the flash device and enable/disable target specific features

-   To check whether NAND Flash block is bad or good, and tag the NAND Flash block to bad or good


**Example application to Erase, Write and Read NAND Flash Memory**

```c
#define PAGE_SIZE                         4096
#define SPARE_SIZE                        224
#define BUFFER_SIZE                       (PAGE_SIZE + SPARE_SIZE)
#define NAND_FLASH_ADDR_ONFI_SIGNATURE    0x20

static APP_DATA appData;

static uint16_t blockNum = 3;
static uint16_t pageNum = 0;
static char *ptrReadId = 0;

void APP_Initialize ( void )
{
    uint32_t i = 0;

    /* Place the App state machine in its initial state. */
    appData.state = APP_STATE_INIT;

    for (i = 0; i < PAGE_SIZE; i++)
    {
        appData.writeBuffer[i] = i;
    }

}

void APP_Tasks ( void )
{
    /* Check the application's current state. */
    switch ( appData.state )
    {
        /* Application's initial state. */
        case APP_STATE_INIT:
        {
            if (DRV_NAND_FLASH_Status(DRV_NAND_FLASH_INDEX) == SYS_STATUS_READY)
            {
                appData.state = APP_STATE_OPEN_DRIVER;
            }
            break;
        }
        case APP_STATE_OPEN_DRIVER:
        {
            appData.handle = DRV_NAND_FLASH_Open((SYS_MODULE_INDEX)DRV_NAND_FLASH_INDEX, DRV_IO_INTENT_READWRITE);

            if (appData.handle != DRV_HANDLE_INVALID)
            {
                appData.state = APP_STATE_ID_GET;
            }
            break;
        }
        case APP_STATE_ID_GET:
        {
            if (DRV_NAND_FLASH_IdRead(appData.handle, &appData.readId, NAND_FLASH_ADDR_ONFI_SIGNATURE) != true)
            {
                appData.state = APP_STATE_ERROR;
            }
            else
            {
                ptrReadId = (char *)&appData.readId;
                if (ptrReadId[0] == 'O' && ptrReadId[1] == 'N' && ptrReadId[2] == 'F' && ptrReadId[3] == 'I')
                {
                    appData.state = APP_STATE_GEOMETRY_GET;
                }
            }
            break;
        }
        case APP_STATE_GEOMETRY_GET:
        {
            if (DRV_NAND_FLASH_GeometryGet(appData.handle, &appData.geometry) != true)
            {
                appData.state = APP_STATE_ERROR;
            }
            else
            {
                appData.state = APP_STATE_ERASE_FLASH;
            }
            break;
        }

        case APP_STATE_ERASE_FLASH:
        {
            if (DRV_NAND_FLASH_SkipBlock_BlockErase(appData.handle, blockNum, 0) != true)
            {
                appData.state = APP_STATE_ERROR;
            }
            else
            {
                appData.state = APP_STATE_WRITE_MEMORY;
            }
            break;
        }
        case APP_STATE_WRITE_MEMORY:
        {
            if (DRV_NAND_FLASH_SkipBlock_PageWrite(appData.handle, blockNum, pageNum, appData.writeBuffer, 0, false) != true)
            {
                appData.state = APP_STATE_ERROR;
            }
            else
            {
                appData.state = APP_STATE_READ_MEMORY;
            }
            break;
        }
        case APP_STATE_READ_MEMORY:
        {
            if (DRV_NAND_FLASH_SkipBlock_PageRead(appData.handle, blockNum, pageNum, appData.readBuffer, 0, false) != true)
            {
                appData.state = APP_STATE_ERROR;
            }
            else
            {
                appData.state = APP_STATE_VERIFY_DATA;
            }
            break;
        }
        case APP_STATE_VERIFY_DATA:
        {
            if (!memcmp(appData.writeBuffer, appData.readBuffer, appData.geometry.pageSize))
            {
                appData.state = APP_STATE_SUCCESS;
            }
            else
            {
                appData.state = APP_STATE_ERROR;
            }
            break;
        }

        case APP_STATE_SUCCESS:
        {
            DRV_NAND_FLASH_Close(appData.handle);

            appData.state = APP_STATE_IDLE;
            break;
        }

        case APP_STATE_ERROR:
        case APP_STATE_IDLE:
        default:
            break;
    }
}

```

**Parent topic:**[NAND Flash Driver](GUID-BFFB8AD8-CD11-49AB-8C23-F860A883EFE6.md)

