# DRV\_AT25\_Read Function

**Parent topic:**[Library Interface](GUID-FC2766BD-E5AF-4007-BA9A-D1E179E8AF51.md)

## C

```c
bool DRV_AT25_Read(const DRV_HANDLE handle, void *rxData, uint32_t rxDataLength, uint32_t address )
```

## Summary

Reads 'n' bytes of data from the specified start address of EEPROM.

## Description

This function schedules a non-blocking read operation for the requested number<br />of data bytes from the given address of the EEPROM.

The requesting client should call DRV\_AT25\_TransferStatusGet API to know<br />the current status of the request OR the requesting client can register a<br />callback function with the driver to get notified of the status.

## Precondition

DRV\_AT25\_Open must have been called to obtain a valid opened device handle.

## Parameters

|Param|Description|
|-----|-----------|
|handle|A valid open-instance handle, returned from the driver's open routine|
|rxData|Buffer pointer into which the data read from the DRV\_AT25 Flash memory will be placed.|
|rxDataLength|Total number of bytes to be read.|
|address|Memory start address from where the data should be read.|

## Returns

*true*

-   if the read request is accepted.


*false*

-   if handle is invalid

-   if the pointer to the receive buffer is NULL or number of bytes to read is 0

-   if the driver is busy handling another transfer request


## Example

```c
#define BUFFER_SIZE 1024
#define MEM_ADDRESS 0x00

uint8_t readBuffer[BUFFER_SIZE];

// myHandle is the handle returned from DRV_AT25_Open API.
// In the below example, the transfer status is polled. However, application can
// register a callback and get notified when the transfer is complete.

if (DRV_AT25_Read(myHandle, readBuffer, BUFFER_SIZE, MEM_ADDRESS) != true)
{
    // Error handling here
}
else
{
    // Wait for read to be completed
    while(DRV_AT25_TransferStatusGet(myHandle) == DRV_AT25_TRANSFER_STATUS_BUSY);
}

```

## Remarks

None.

