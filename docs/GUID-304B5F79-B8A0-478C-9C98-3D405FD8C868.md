# DRV\_MX25L\_PageWrite Function

**Parent topic:**[Library Interface](GUID-410DBBCC-D224-45B2-B881-7BFB0DFF0EFC.md)

## C

```c
bool DRV_MX25L_PageWrite( const DRV_HANDLE handle, void *tx_data, uint32_t tx_data_length, uint32_t address );
```

## Summary

Writes one page of data starting at the specified address.

## Description

This function schedules a non-blocking write operation for writing maximum one page<br />of data into flash memory.

The requesting client should call DRV\_MX25L\_TransferStatusGet\(\) API to know<br />the current status of the request.

The request is sent in QUAD\_MODE to flash device.

## Preconditions

The DRV\_MX25L\_Open\(\) routine must have been called for the specified MX25L driver instance. The flash address location which has to be written, must have been erased before using the MX25L\_xxxErase\(\) routine. The flash address has to be a Page aligned address.

## Parameters

|Param|Description|
|-----|-----------|
|handle|A valid open-instance handle, returned from the driver's open routine|
|\*tx\_data|The source buffer containing data to be programmed into MX25L Flash|
|tx\_data\_length|Total number of bytes to be written. should not be greater than page size|
|address|Write memory start address from where the data should be written|

## Returns

*true*

-   if the write request is successfully sent to the flash


*false*

-   if Write enable fails before sending sector erase command to flash

-   if write command itself fails


## Example

```c
#define PAGE_SIZE 256
#define BUFFER_SIZE 1024
#define MEM_ADDRESS 0x0

DRV_HANDLE handle; // Returned from DRV_MX25L_Open
uint8_t CACHE_ALIGN writeBuffer[BUFFER_SIZE];
bool status = false;

if(DRV_MX25L_SectorErase(handle) == false)
{
    // Error handling here
}

// Wait for erase to be completed
while(DRV_MX25L_TransferStatusGet(handle) == DRV_MX25L_TRANSFER_BUSY);

for (uint32_t j = 0; j < BUFFER_SIZE; j += PAGE_SIZE)
{
    if (DRV_MX25L_PageWrite(handle, (void *)&writeBuffer[j], (MEM_ADDRESS + j)) == false)
    {
        status = false;
        break;
    }
    
    // Wait for write to be completed
    while(DRV_MX25L_TransferStatusGet(handle) == DRV_MX25L_TRANSFER_BUSY);
    status = true;
}

if(status == false)
{
    // Error handling here
}

```

## Remarks

This routine will block wait until write request is submitted successfully.

Client should wait until write is complete to send next transfer request.

