# DRV\_MEMORY\_AsyncWrite Function

**Parent topic:**[Library Interface](GUID-E18B0923-4286-4E08-A2EB-9A482E0063AE.md)

## C

```c
void DRV_MEMORY_AsyncWrite
(
    const DRV_HANDLE handle,
    DRV_MEMORY_COMMAND_HANDLE *commandHandle,
    void *sourceBuffer,
    uint32_t blockStart,
    uint32_t nBlock
);
```

## Summary

Writes data for the specified number of memory blocks in Asynchronous mode.

## Description

This function schedules a non-blocking write operation for writing blocks<br />of data into attached devices memory.

The function returns with a valid command handle in the commandHandle argument<br />if the write request was scheduled successfully.

The function adds the request to the hardware instance queue and returns immediately.<br />While the request is in the queue, the application buffer is owned by the driver<br />and should not be modified.

The function returns DRV\_MEMORY\_COMMAND\_HANDLE\_INVALID in the commandHandle argument<br />under the following circumstances:

-   if a buffer object could not be allocated to the request

-   if the source buffer pointer is NULL

-   if the client opened the driver for read only

-   if the number of blocks to be written is either zero or more than the number of blocks actually available

-   if the driver handle is invalid


If the requesting client registered an event callback with the driver, the<br />driver will issue a DRV\_MEMORY\_EVENT\_COMMAND\_COMPLETE event if the buffer<br />was processed successfully or DRV\_MEMORY\_EVENT\_COMMAND\_ERROR event if the<br />buffer was not processed successfully.

If the requesting client has not registered any transfer handler callback<br />with the driver, he can call DRV\_MEMORY\_CommandStatusGetGet\(\) API to know<br />the current status of the request.

## Preconditions

DRV\_MEMORY\_Open\(\) routine must have been called to obtain a valid opened device handle.

The memory address location which has to be written, must have been erased before using the DRV\_MEMORY\_xxxErase\(\) routine.

## Parameters

|Param|Description|
|-----|-----------|
|handle|A valid open-instance handle, returned from the driver's open function|
|commandHandle|Pointer to an argument that will contain the return buffer handle|
|sourceBuffer|The source buffer containing data to be programmed into media device memory|
|blockStart|Block start from where the data should be written to.|
|nBlock|Total number of blocks to be written.|

## Returns

The command handle is returned in the commandHandle argument. It will be DRV\_MEMORY\_COMMAND\_HANDLE\_INVALID if the request was not successful.

## Example

```c
#define BUFFER_SIZE 4096
uint8_t writeBuffer[BUFFER_SIZE];

// Use DRV_MEMORY_GeometryGet () to find the write region geometry.
uint32_t blockStart = 0x0;
uint32_t nBlock = BUFFER_SIZE / block_size; // block_size for write geometry
bool xfer_done = false;

DRV_MEMORY_COMMAND_HANDLE commandHandle;

// memoryHandle is the handle returned by the DRV_MEMORY_Open function.

// Event is received when the write request is completed.
void appTransferHandler
(
    DRV_MEMORY_EVENT event,
    DRV_MEMORY_COMMAND_HANDLE commandHandle,
    uintptr_t context
)
{
    switch(event)
    {
        case DRV_MEMORY_EVENT_COMMAND_COMPLETE:
        {
            xfer_done = true;
            break;
        }

        case DRV_MEMORY_EVENT_COMMAND_ERROR:
        {
            // Handle Error
            break;
        }

        default:
        {
            break;
        }
    }
}

DRV_MEMORY_TransferHandlerSet(memoryHandle, appTransferHandler, (uintptr_t)NULL);

DRV_MEMORY_AsyncErase(memoryHandle, &commandHandle, blockStart, nBlock);

if(DRV_MEMORY_COMMAND_HANDLE_INVALID == commandHandle)
{
    // Error handling here
}

// Wait for erase to be completed
while(!xfer_done);

DRV_MEMORY_AsyncWrite(memoryHandle, &commandHandle, &writeBuffer, blockStart, nBlock);

if(DRV_MEMORY_COMMAND_HANDLE_INVALID == commandHandle)
{
    // Error handling here
}

// Wait for write to be completed
while(!xfer_done);

```

## Remarks

This API is supported in Both Bare-Metal and RTOS environment.

