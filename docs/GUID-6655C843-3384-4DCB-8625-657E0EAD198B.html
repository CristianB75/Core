<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="DC.type" content="topic" />
<meta name="DC.title" content="DRV_MEMORY_AsyncWrite Function" />
<meta name="DC.relation" scheme="URI" content="GUID-E18B0923-4286-4E08-A2EB-9A482E0063AE.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="drv-memory-asyncwrite-function" />
<link rel="stylesheet" type="text/css" href="stylesheets/commonltr.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<link rel="stylesheet" type="text/css" href="./stylesheets/common-extended.css" /><title>DRV_MEMORY_AsyncWrite Function</title>
<meta name="Microsoft.Help.Id" content="GUID-EDFB1AB8-CD6B-446F-8E25-F2167287A1AF-drv-memory-asyncwrite-function" />
<meta name="Microsoft.Help.TocParent" content="GUID-EDFB1AB8-CD6B-446F-8E25-F2167287A1AF" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLABÂ® Harmony Core Library Reference A 11/2021" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
        function cpy(id, button) {
        
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                    button.textContent = "Copy";
                    button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
              console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
        }
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?GUID-6655C843-3384-4DCB-8625-657E0EAD198B"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style></head>
<body id="drv-memory-asyncwrite-function">
<h1 class="title topictitle1" id="ariaid-title1">DRV_MEMORY_AsyncWrite Function</h1><div class="body"></div>
<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="GUID-E18B0923-4286-4E08-A2EB-9A482E0063AE.html">Library Interface</a></div>
</div>
</div><div class="topic nested1" aria-labelledby="ariaid-title2" id="c"><h2 class="title topictitle2" id="ariaid-title2">C</h2><div class="body"><pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d18349e21', this);">Copy</button><code id="d18349e21" content="void DRV_MEMORY_AsyncWrite&#xA;(&#xA;    const DRV_HANDLE handle,&#xA;    DRV_MEMORY_COMMAND_HANDLE *commandHandle,&#xA;    void *sourceBuffer,&#xA;    uint32_t blockStart,&#xA;    uint32_t nBlock&#xA;);"><span class="ph token keyword">void</span> DRV_MEMORY_AsyncWrite
<span class="ph token punctuation">(</span>
    <span class="ph token keyword">const</span> DRV_HANDLE handle<span class="ph token punctuation">,</span>
    DRV_MEMORY_COMMAND_HANDLE <span class="ph token operator">*</span>commandHandle<span class="ph token punctuation">,</span>
    <span class="ph token keyword">void</span> <span class="ph token operator">*</span>sourceBuffer<span class="ph token punctuation">,</span>
    uint32_t blockStart<span class="ph token punctuation">,</span>
    uint32_t nBlock
<span class="ph token punctuation">)</span><span class="ph token punctuation">;</span></code></pre></div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title3" id="summary"><h2 class="title topictitle2" id="ariaid-title3">Summary</h2><div class="body"><p class="p">Writes data for the specified number of memory blocks in Asynchronous mode.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title4" id="description"><h2 class="title topictitle2" id="ariaid-title4">Description</h2><div class="body"><p class="p">This function schedules a non-blocking write operation for writing blocks
of data into attached devices memory.</p>
<p class="p">The function returns with a valid command handle in the commandHandle argument
if the write request was scheduled successfully.</p>
<p class="p">The function adds the request to the hardware instance queue and returns immediately.
While the request is in the queue, the application buffer is owned by the driver
and should not be modified.</p>
<p class="p">The function returns DRV_MEMORY_COMMAND_HANDLE_INVALID in the commandHandle argument
under the following circumstances:</p>
<ul class="ul"><li class="li"><p class="p">if a buffer object could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the source buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the client opened the driver for read only</p>
</li>
<li class="li"><p class="p">if the number of blocks to be written is either zero or more than the number of blocks actually available</p>
</li>
<li class="li"><p class="p">if the driver handle is invalid</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the
driver will issue a DRV_MEMORY_EVENT_COMMAND_COMPLETE event if the buffer
was processed successfully or DRV_MEMORY_EVENT_COMMAND_ERROR event if the
buffer was not processed successfully.</p>
<p class="p">If the requesting client has not registered any transfer handler callback
with the driver, he can call DRV_MEMORY_CommandStatusGetGet() API to know
the current status of the request.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title5" id="preconditions"><h2 class="title topictitle2" id="ariaid-title5">Preconditions</h2><div class="body"><p class="p">DRV_MEMORY_Open() routine must have been called to obtain a valid opened device handle.</p>
<p class="p">The memory address location which has to be written, must have been erased before using the DRV_MEMORY_xxxErase() routine.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title6" id="parameters"><h2 class="title topictitle2" id="ariaid-title6">Parameters</h2><div class="body">
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d18349e113"><span>Param</span></th>
<th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d18349e115"><span>Description</span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d18349e113 "><span>handle</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d18349e115 "><span>A valid open-instance handle, returned from the driver's open function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d18349e113 "><span>commandHandle</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d18349e115 "><span>Pointer to an argument that will contain the return buffer handle</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d18349e113 "><span>sourceBuffer</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d18349e115 "><span>The source buffer containing data to be programmed into media device memory</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d18349e113 "><span>blockStart</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d18349e115 "><span>Block start from where the data should be written to.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d18349e113 "><span>nBlock</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d18349e115 "><span>Total number of blocks to be written.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title7" id="returns"><h2 class="title topictitle2" id="ariaid-title7">Returns</h2><div class="body"><p class="p">The command handle is returned in the commandHandle argument. It will be DRV_MEMORY_COMMAND_HANDLE_INVALID if the request was not successful.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title8" id="example"><h2 class="title topictitle2" id="ariaid-title8">Example</h2><div class="body"><pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d18349e153', this);">Copy</button><code id="d18349e153" content="#define BUFFER_SIZE 4096&#xA;uint8_t writeBuffer[BUFFER_SIZE];&#xA;&#xA;// Use DRV_MEMORY_GeometryGet () to find the write region geometry.&#xA;uint32_t blockStart = 0x0;&#xA;uint32_t nBlock = BUFFER_SIZE / block_size; // block_size for write geometry&#xA;bool xfer_done = false;&#xA;&#xA;DRV_MEMORY_COMMAND_HANDLE commandHandle;&#xA;&#xA;// memoryHandle is the handle returned by the DRV_MEMORY_Open function.&#xA;&#xA;// Event is received when the write request is completed.&#xA;void appTransferHandler&#xA;(&#xA;    DRV_MEMORY_EVENT event,&#xA;    DRV_MEMORY_COMMAND_HANDLE commandHandle,&#xA;    uintptr_t context&#xA;)&#xA;{&#xA;    switch(event)&#xA;    {&#xA;        case DRV_MEMORY_EVENT_COMMAND_COMPLETE:&#xA;        {&#xA;            xfer_done = true;&#xA;            break;&#xA;        }&#xA;&#xA;        case DRV_MEMORY_EVENT_COMMAND_ERROR:&#xA;        {&#xA;            // Handle Error&#xA;            break;&#xA;        }&#xA;&#xA;        default:&#xA;        {&#xA;            break;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;DRV_MEMORY_TransferHandlerSet(memoryHandle, appTransferHandler, (uintptr_t)NULL);&#xA;&#xA;DRV_MEMORY_AsyncErase(memoryHandle, &amp;commandHandle, blockStart, nBlock);&#xA;&#xA;if(DRV_MEMORY_COMMAND_HANDLE_INVALID == commandHandle)&#xA;{&#xA;    // Error handling here&#xA;}&#xA;&#xA;// Wait for erase to be completed&#xA;while(!xfer_done);&#xA;&#xA;DRV_MEMORY_AsyncWrite(memoryHandle, &amp;commandHandle, &amp;writeBuffer, blockStart, nBlock);&#xA;&#xA;if(DRV_MEMORY_COMMAND_HANDLE_INVALID == commandHandle)&#xA;{&#xA;    // Error handling here&#xA;}&#xA;&#xA;// Wait for write to be completed&#xA;while(!xfer_done);&#xA;"><span class="ph token macro property">#<span class="ph token directive keyword">define</span> BUFFER_SIZE 4096</span>
uint8_t writeBuffer<span class="ph token punctuation">[</span>BUFFER_SIZE<span class="ph token punctuation">]</span><span class="ph token punctuation">;</span>

<span class="ph token comment">// Use DRV_MEMORY_GeometryGet () to find the write region geometry.</span>
uint32_t blockStart <span class="ph token operator">=</span> <span class="ph token number">0x0</span><span class="ph token punctuation">;</span>
uint32_t nBlock <span class="ph token operator">=</span> BUFFER_SIZE <span class="ph token operator">/</span> block_size<span class="ph token punctuation">;</span> <span class="ph token comment">// block_size for write geometry</span>
bool xfer_done <span class="ph token operator">=</span> false<span class="ph token punctuation">;</span>

DRV_MEMORY_COMMAND_HANDLE commandHandle<span class="ph token punctuation">;</span>

<span class="ph token comment">// memoryHandle is the handle returned by the DRV_MEMORY_Open function.</span>

<span class="ph token comment">// Event is received when the write request is completed.</span>
<span class="ph token keyword">void</span> appTransferHandler
<span class="ph token punctuation">(</span>
    DRV_MEMORY_EVENT event<span class="ph token punctuation">,</span>
    DRV_MEMORY_COMMAND_HANDLE commandHandle<span class="ph token punctuation">,</span>
    uintptr_t context
<span class="ph token punctuation">)</span>
<span class="ph token punctuation">{</span>
    <span class="ph token keyword">switch</span><span class="ph token punctuation">(</span>event<span class="ph token punctuation">)</span>
    <span class="ph token punctuation">{</span>
        <span class="ph token keyword">case</span> DRV_MEMORY_EVENT_COMMAND_COMPLETE<span class="ph token operator">:</span>
        <span class="ph token punctuation">{</span>
            xfer_done <span class="ph token operator">=</span> true<span class="ph token punctuation">;</span>
            <span class="ph token keyword">break</span><span class="ph token punctuation">;</span>
        <span class="ph token punctuation">}</span>

        <span class="ph token keyword">case</span> DRV_MEMORY_EVENT_COMMAND_ERROR<span class="ph token operator">:</span>
        <span class="ph token punctuation">{</span>
            <span class="ph token comment">// Handle Error</span>
            <span class="ph token keyword">break</span><span class="ph token punctuation">;</span>
        <span class="ph token punctuation">}</span>

        <span class="ph token keyword">default</span><span class="ph token operator">:</span>
        <span class="ph token punctuation">{</span>
            <span class="ph token keyword">break</span><span class="ph token punctuation">;</span>
        <span class="ph token punctuation">}</span>
    <span class="ph token punctuation">}</span>
<span class="ph token punctuation">}</span>

<span class="ph token function">DRV_MEMORY_TransferHandlerSet</span><span class="ph token punctuation">(</span>memoryHandle<span class="ph token punctuation">,</span> appTransferHandler<span class="ph token punctuation">,</span> <span class="ph token punctuation">(</span>uintptr_t<span class="ph token punctuation">)</span><span class="ph token constant">NULL</span><span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>

<span class="ph token function">DRV_MEMORY_AsyncErase</span><span class="ph token punctuation">(</span>memoryHandle<span class="ph token punctuation">,</span> <span class="ph token operator">&amp;</span>commandHandle<span class="ph token punctuation">,</span> blockStart<span class="ph token punctuation">,</span> nBlock<span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>

<span class="ph token keyword">if</span><span class="ph token punctuation">(</span>DRV_MEMORY_COMMAND_HANDLE_INVALID <span class="ph token operator">==</span> commandHandle<span class="ph token punctuation">)</span>
<span class="ph token punctuation">{</span>
    <span class="ph token comment">// Error handling here</span>
<span class="ph token punctuation">}</span>

<span class="ph token comment">// Wait for erase to be completed</span>
<span class="ph token keyword">while</span><span class="ph token punctuation">(</span><span class="ph token operator">!</span>xfer_done<span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>

<span class="ph token function">DRV_MEMORY_AsyncWrite</span><span class="ph token punctuation">(</span>memoryHandle<span class="ph token punctuation">,</span> <span class="ph token operator">&amp;</span>commandHandle<span class="ph token punctuation">,</span> <span class="ph token operator">&amp;</span>writeBuffer<span class="ph token punctuation">,</span> blockStart<span class="ph token punctuation">,</span> nBlock<span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>

<span class="ph token keyword">if</span><span class="ph token punctuation">(</span>DRV_MEMORY_COMMAND_HANDLE_INVALID <span class="ph token operator">==</span> commandHandle<span class="ph token punctuation">)</span>
<span class="ph token punctuation">{</span>
    <span class="ph token comment">// Error handling here</span>
<span class="ph token punctuation">}</span>

<span class="ph token comment">// Wait for write to be completed</span>
<span class="ph token keyword">while</span><span class="ph token punctuation">(</span><span class="ph token operator">!</span>xfer_done<span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
</code></pre></div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title9" id="remarks"><h2 class="title topictitle2" id="ariaid-title9">Remarks</h2><div class="body"><p class="p">This API is supported in Both Bare-Metal and RTOS environment.</p>
</div>
</div>
</body>
</html>