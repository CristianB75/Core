# DRV\_AT24\_Read Function

**Parent topic:**[Library Interface](GUID-354A36E3-7E0B-4DD0-8485-DDFD792B525C.md)

## C

```c
bool DRV_AT24_Read(const DRV_HANDLE handle, void *rxData, uint32_t rxDataLength, uint32_t address )
```

## Summary

Reads 'n' bytes of data from the specified start address of EEPROM.

## Description

This function schedules a non-blocking read operation for the requested number<br />of data bytes from the given address of the EEPROM.

The requesting client should call DRV\_AT24\_TransferStatusGet API to know<br />the current status of the request OR the requesting client can register a<br />callback function with the driver to get notified of the status.

## Precondition

DRV\_AT24\_Open must have been called to obtain a valid opened device handle.

## Parameters

|Param|Description|
|-----|-----------|
|handle|A valid open-instance handle, returned from the driver's open routine|
|rxData|Buffer pointer into which the data read from the DRV\_AT24 Flash memory will be placed.|
|rxDataLength|Total number of bytes to be read.|
|address|Memory start address from where the data should be read.|

## Returns

*true*

-   if the read request is accepted.


*false*

-   if handle is invalid

-   if the pointer to the receive buffer is NULL or number of bytes to read is 0

-   if the driver is busy handling another transfer request


## Example

```c
#define BUFFER_SIZE 1024
#define MEM_ADDRESS 0x00

uint8_t CACHE_ALIGN readBuffer[BUFFER_SIZE];

// myHandle is the handle returned from DRV_AT24_Open API.
// In the below example, the transfer status is polled. However, application can
// register a callback and get notified when the transfer is complete.

if (DRV_AT24_Read(myHandle, readBuffer, BUFFER_SIZE, MEM_ADDRESS) != true)
{
    // Error handling here
}
else
{
    // Wait for read to be completed
    while(DRV_AT24_TransferStatusGet(myHandle) == DRV_AT24_TRANSFER_STATUS_BUSY);
}

```

## Remarks

None.

